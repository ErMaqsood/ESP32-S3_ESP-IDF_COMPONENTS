.TH "drivers" 3 "ESP-IDF Components by K0I05" \" -*- nroff -*-
.ad l
.nh
.SH NAME
drivers \- guva-s12sd uv sensor
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBs12sd_config_s\fP"
.br
.RI "S12SD configuration structure definition\&. "
.ti -1c
.RI "struct \fBs12sd_context_t\fP"
.br
.RI "S12SD context structure\&. "
.ti -1c
.RI "struct \fBahtxx_config_s\fP"
.br
.RI "AHTXX configuration structure definition\&. "
.ti -1c
.RI "struct \fBahtxx_context_t\fP"
.br
.RI "AHTXX context structure\&. "
.ti -1c
.RI "struct \fBak8975_magnetic_axes_data_s\fP"
.br
.RI "AK8975 processed compass axes data structure and axes have a range +/-1229 uT\&. "
.ti -1c
.RI "struct \fBak8975_axes_data_s\fP"
.br
.RI "AK8975 axes data registers (HX, HZ, HZ) structure\&. "
.ti -1c
.RI "struct \fBak8975_config_s\fP"
.br
.RI "AK8975 configuration structure\&. "
.ti -1c
.RI "struct \fBak8975_context_t\fP"
.br
.RI "AK8975 context structure\&. "
.ti -1c
.RI "struct \fBas3935_config_s\fP"
.br
.RI "I2C AS3935 device configuration structure\&. "
.ti -1c
.RI "struct \fBas3935_context_t\fP"
.br
.RI "I2C AS3935 device handle structure\&. "
.ti -1c
.RI "struct \fBas3935_monitor_base_s\fP"
.br
.RI "AS3935 device event object structure\&. "
.ti -1c
.RI "struct \fBas3935_monitor_context_s\fP"
.br
.RI "esp AS3935 device state machine structure\&. "
.ti -1c
.RI "struct \fBas7341_channels_basic_counts_data_s\fP"
.br
.RI "AS7341 channels basic counts data structure\&. "
.ti -1c
.RI "struct \fBas7341_channels_spectral_data_s\fP"
.br
.RI "AS7341 channels spectral data structure\&. "
.ti -1c
.RI "struct \fBas7341_config_s\fP"
.br
.RI "AS7341 configuration structure\&. "
.ti -1c
.RI "struct \fBas7341_context_t\fP"
.br
.RI "AS7341 context structure\&. "
.ti -1c
.RI "struct \fBbh1750_config_s\fP"
.br
.RI "BH1750 device configuration structure\&. "
.ti -1c
.RI "struct \fBbh1750_context_t\fP"
.br
.RI "BH1750 I2C device handle structure\&. "
.ti -1c
.RI "struct \fBbme680_cal_factors_s\fP"
.br
.RI "BME680 calibration factors structure definition\&. "
.ti -1c
.RI "struct \fBbme680_data_s\fP"
.br
.RI "BME680 data structure definition\&. "
.ti -1c
.RI "struct \fBbme680_adc_data_s\fP"
.br
.RI "BME680 ADC data structure definition\&. "
.ti -1c
.RI "struct \fBbme680_config_s\fP"
.br
.RI "BME680 configuration structure definition\&. "
.ti -1c
.RI "struct \fBbme680_context_t\fP"
.br
.RI "BME680 context structure\&. "
.ti -1c
.RI "struct \fBbmp280_cal_factors_s\fP"
.br
.RI "BMP280 temperature and pressure calibration factors structure definition\&. "
.ti -1c
.RI "struct \fBbmp280_config_s\fP"
.br
.RI "BMP280 configuration structure definition\&. "
.ti -1c
.RI "struct \fBbmp280_context_t\fP"
.br
.RI "BMP280 context structure\&. "
.ti -1c
.RI "struct \fBbmp390_cal_factors_s\fP"
.br
.RI "BMP390 temperature and pressure calibration factors structure\&. "
.ti -1c
.RI "struct \fBbmp390_conv_cal_factors_s\fP"
.br
.RI "BMP390 temperature and pressure converted calibration factors structure\&. "
.ti -1c
.RI "struct \fBbmp390_config_s\fP"
.br
.RI "BMP390 configuration structure\&. "
.ti -1c
.RI "struct \fBbmp390_context_t\fP"
.br
.RI "BMP390 context structure\&. "
.ti -1c
.RI "struct \fBccs811_thresholds_register_s\fP"
.br
.RI "CCS811 thresholds register structure\&. "
.ti -1c
.RI "struct \fBccs811_environmental_data_register_s\fP"
.br
.RI "CCS811 environmental data register structure\&. "
.ti -1c
.RI "struct \fBccs811_error_row_s\fP"
.br
.RI "CCS811 error row definition structure\&. "
.ti -1c
.RI "struct \fBccs811_measure_mode_row_s\fP"
.br
.RI "CCS811 measure mode row definition structure\&. "
.ti -1c
.RI "struct \fBccs811_config_t\fP"
.br
.RI "CCS811 configuration structure\&. "
.ti -1c
.RI "struct \fBccs811_context_t\fP"
.br
.RI "CCS811 context structure\&. "
.ti -1c
.RI "union \fBens160_app_version_u\fP"
.br
.RI "ENS160 application version register structure\&. "
.ti -1c
.RI "struct \fBens160_air_quality_data_s\fP"
.br
.RI "ENS160 air quality data structure\&. "
.ti -1c
.RI "struct \fBens160_air_quality_raw_data_s\fP"
.br
.RI "ENS160 air quality raw data structure\&. "
.ti -1c
.RI "struct \fBens160_aqi_uba_row_s\fP"
.br
.RI "ENS160 air quality index of the UBA row definition structure\&. "
.ti -1c
.RI "struct \fBens160_config_s\fP"
.br
.RI "ENS160 configuration structure\&. "
.ti -1c
.RI "struct \fBens160_context_t\fP"
.br
.RI "ENS160 context structure\&. "
.ti -1c
.RI "struct \fBhdc1080_config_s\fP"
.br
.RI "HDC1080 configuration structure definition\&. "
.ti -1c
.RI "struct \fBhdc1080_context_t\fP"
.br
.RI "HDC1080 context structure\&. "
.ti -1c
.RI "struct \fBhmc5883l_axes_data_s\fP"
.br
.ti -1c
.RI "struct \fBhmc5883l_magnetic_axes_data_s\fP"
.br
.ti -1c
.RI "struct \fBhmc5883l_offset_axes_data_s\fP"
.br
.ti -1c
.RI "struct \fBhmc5883l_gain_error_axes_data_s\fP"
.br
.ti -1c
.RI "struct \fBhmc5883l_config_s\fP"
.br
.RI "HMC5883L device configuration structure\&. "
.ti -1c
.RI "struct \fBhmc5883l_context_t\fP"
.br
.RI "HMC5883L context structure\&. "
.ti -1c
.RI "struct \fBina226_config_s\fP"
.br
.RI "INA226 device configuration\&. "
.ti -1c
.RI "struct \fBina226_context_t\fP"
.br
.RI "INA226 context structure\&. "
.ti -1c
.RI "struct \fBltr390uv_config_s\fP"
.br
.RI "LTR390UV configuration structure\&. "
.ti -1c
.RI "struct \fBltr390uv_context_t\fP"
.br
.RI "LTR390UV context structure\&. "
.ti -1c
.RI "struct \fBmax30105_config_s\fP"
.br
.RI "MAX30105 configuration structure\&. "
.ti -1c
.RI "struct \fBmax30105_context_t\fP"
.br
.RI "MAX30105 context structure\&. "
.ti -1c
.RI "struct \fBmlx90614_config_s\fP"
.br
.RI "MLX90614 configuration structure\&. "
.ti -1c
.RI "struct \fBmlx90614_context_t\fP"
.br
.RI "MLX90614 context structure\&. "
.ti -1c
.RI "struct \fBmmc56x3_magnetic_axes_data_s\fP"
.br
.RI "MMC56X3 magnetic axes data structure\&. "
.ti -1c
.RI "struct \fBmmc56x3_selftest_axes_data_s\fP"
.br
.RI "MMC56X3 self-test axes data structure\&. "
.ti -1c
.RI "struct \fBmmc56x3_config_s\fP"
.br
.RI "MMC56X3 configuration structure\&. "
.ti -1c
.RI "struct \fBmmc56x3_context_t\fP"
.br
.RI "MMC56X3 context structure\&. "
.ti -1c
.RI "struct \fBmpu6050_data_axes_s\fP"
.br
.RI "MPU6050 raw data axes structure\&. "
.ti -1c
.RI "struct \fBmpu6050_gyro_data_axes_s\fP"
.br
.ti -1c
.RI "struct \fBmpu6050_accel_data_axes_s\fP"
.br
.ti -1c
.RI "struct \fBmpu6050_attitude_s\fP"
.br
.ti -1c
.RI "struct \fBmpu6050_config_s\fP"
.br
.RI "MPU6050 configuration structure definition\&. "
.ti -1c
.RI "struct \fBmpu6050_context_t\fP"
.br
.RI "MPU6050 context structure\&. "
.ti -1c
.RI "struct \fBsgp4x_config_t\fP"
.br
.RI "SGP4X device configuration structure\&. "
.ti -1c
.RI "struct \fBsgp4x_context_t\fP"
.br
.RI "SGP4X context structure\&. "
.ti -1c
.RI "union \fBi2c_sht4x_data___t\fP"
.br
.ti -1c
.RI "struct \fBsht4x_config_s\fP"
.br
.RI "SHT4X configuration structure definition\&. "
.ti -1c
.RI "struct \fBsht4x_context_t\fP"
.br
.RI "SHT4X context structure\&. "
.ti -1c
.RI "struct \fBssd1306_page_s\fP"
.br
.RI "SSD1306 page structure definition\&. "
.ti -1c
.RI "struct \fBssd1306_panel_s\fP"
.br
.RI "SSD1306 panel structure definition\&. "
.ti -1c
.RI "struct \fBssd1306_bdf_font_s\fP"
.br
.RI "SSD1306 BDF font structure definition\&. "
.ti -1c
.RI "struct \fBssd1306_config_s\fP"
.br
.RI "SSD1306 configuration structure definition\&. "
.ti -1c
.RI "struct \fBssd1306_context_t\fP"
.br
.RI "SSD1306 context structure\&. "
.ti -1c
.RI "struct \fBtbi2cxxx_config_s\fP"
.br
.RI "TBI2CXXX configuration structure\&. "
.ti -1c
.RI "struct \fBtbi2cxxx_context_t\fP"
.br
.RI "TBI2CXXX context structure\&. "
.ti -1c
.RI "struct \fBtlv493d_raw_data_s\fP"
.br
.ti -1c
.RI "struct \fBtlv493d_data_s\fP"
.br
.ti -1c
.RI "struct \fBtlv493d_config_s\fP"
.br
.RI "TLV493D configuration structure\&. "
.ti -1c
.RI "struct \fBtlv493d_context_t\fP"
.br
.RI "TLV493D context structure\&. "
.ti -1c
.RI "struct \fBveml6040_config_s\fP"
.br
.RI "VEML6040 configuration structure\&. "
.ti -1c
.RI "struct \fBveml6040_context_t\fP"
.br
.RI "VEML6040 context structure\&. "
.ti -1c
.RI "struct \fBveml7700_config_s\fP"
.br
.RI "VEML7700 device configuration structure\&. "
.ti -1c
.RI "struct \fBveml7700_context_t\fP"
.br
.RI "VEML7700 context structure\&. "
.ti -1c
.RI "struct \fBds18b20_config_s\fP"
.br
.RI "DS18B20 device configuration structure\&. "
.ti -1c
.RI "struct \fBds18b20_context_t\fP"
.br
.RI "DS18B20 context structure\&. "
.ti -1c
.RI "struct \fBspi_max31865_config_t\fP"
.br
.RI "MAX31865 SPI device configuration structure\&. "
.ti -1c
.RI "struct \fBspi_max31865_t\fP"
.br
.RI "MAX31865 SPI device structure\&. "
.ti -1c
.RI "struct \fBdatatable_event_tag\fP"
.br
.RI "Data-table event structure\&. "
.ti -1c
.RI "struct \fBdatatable_id_column_data_type_tag\fP"
.br
.RI "Data-table record identifier column data-type structure\&. "
.ti -1c
.RI "struct \fBdatatable_ts_column_data_type_tag\fP"
.br
.RI "Data-table record timestamp (utc) column data-type structure\&. "
.ti -1c
.RI "struct \fBdatatable_vector_column_data_type_tag\fP"
.br
.RI "Data-table vector data-type column structure\&. "
.ti -1c
.RI "struct \fBdatatable_bool_column_data_type_tag\fP"
.br
.RI "Data-table bool data-type column structure\&. "
.ti -1c
.RI "struct \fBdatatable_float_column_data_type_tag\fP"
.br
.RI "Data-table float data-type column structure\&. "
.ti -1c
.RI "struct \fBdatatable_fp16_column_data_type_tag\fP"
.br
.RI "Data-table float 16-bit data-type column structure\&. "
.ti -1c
.RI "struct \fBdatatable_int16_column_data_type_tag\fP"
.br
.RI "Data-table int16 data-type column structure\&. "
.ti -1c
.RI "struct \fBdatatable_column_name_tag\fP"
.br
.RI "Data-table column name structure\&. "
.ti -1c
.RI "struct \fBdatatable_column_tag\fP"
.br
.RI "Data-table column structure\&. The data-table record identifier and timestamp columns are created by default when the data-table is created\&. The record identifier and record timestamp data-types are excluded from data processing\&. "
.ti -1c
.RI "struct \fBdatatable_process_tag\fP"
.br
.RI "Data-table process structure\&. "
.ti -1c
.RI "union \fBdatatable_buffer_tag\fP"
.br
.RI "Data-table buffer union structure\&. "
.ti -1c
.RI "union \fBdatatable_row_data_column_tag\fP"
.br
.RI "Data-table row data column structure\&. This structure is a data model that represents data storage of the record based on the data-table's column column data-type\&. "
.ti -1c
.RI "struct \fBdatatable_row_tag\fP"
.br
.RI "Data-table row structure\&. This structure is a data model that represents data storage of record by data-table row and configured data-table columns\&. "
.ti -1c
.RI "struct \fBdatatable_config_tag\fP"
.br
.RI "Data-table configuration structure definition\&. "
.ti -1c
.RI "struct \fBdatatable_t\fP"
.br
.RI "Data-table state object structure definition\&. Do not modify these fields once the data-table handle is created, these are read-only, and represent a state machine\&. "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBADC_S12SD_UNIT_DEFAULT\fP   ADC_UNIT_1"
.br
.ti -1c
.RI "#define \fBADC_S12SD_CHANNEL_DEFAULT\fP   ADC_CHANNEL_0"
.br
.ti -1c
.RI "#define \fBADC_S12SD_SAMPLE_SIZE\fP   (1000)"
.br
.ti -1c
.RI "#define \fBADC_S12SD_ATTEN\fP   ADC_ATTEN_DB_12"
.br
.ti -1c
.RI "#define \fBADC_S12SD_DIGI_BIT_WIDTH\fP   (12)"
.br
.RI "adc bit width at 12-bits "
.ti -1c
.RI "#define \fBADC_S12SD_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fRadc_s12sd_config_t\fP to default configuration settings\&. "
.ti -1c
.RI "#define \fBI2C_AHTXX_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.ti -1c
.RI "#define \fBI2C_AHTXX_DEV_ADDR\fP   UINT8_C(0x38)"
.br
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_AHT30_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fR\fBahtxx_config_t\fP\fP to default configuration settings for the aht30 sensor type\&. "
.ti -1c
.RI "#define \fBI2C_AHT25_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fR\fBahtxx_config_t\fP\fP to default configuration settings for the aht25 sensor type\&. "
.ti -1c
.RI "#define \fBI2C_AHT21_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fR\fBahtxx_config_t\fP\fP to default configuration settings for the aht21 sensor type\&. "
.ti -1c
.RI "#define \fBI2C_AHT20_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fR\fBahtxx_config_t\fP\fP to default configuration settings for the aht20 sensor type\&. "
.ti -1c
.RI "#define \fBI2C_AHT10_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fR\fBahtxx_config_t\fP\fP to default configuration settings for the aht10 sensor type\&. "
.ti -1c
.RI "#define \fBI2C_AK8975_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "ak8975 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_AK8975_DEV_ADDR_CAD1_0_CAD0_0\fP   UINT8_C(0x0c)"
.br
.RI "ak8975 I2C address when CAD1 and CAD0 are low "
.ti -1c
.RI "#define \fBI2C_AK8975_DEV_ADDR_CAD1_0_CAD0_1\fP   UINT8_C(0x0d)"
.br
.RI "ak8975 I2C address when CAD1 is low and CAD0 is high "
.ti -1c
.RI "#define \fBI2C_AK8975_DEV_ADDR_CAD1_1_CAD0_0\fP   UINT8_C(0x0e)"
.br
.RI "ak8975 I2C address when CAD1 is high and CAD0 is low "
.ti -1c
.RI "#define \fBI2C_AK8975_DEV_ADDR_CAD1_1_CAD0_1\fP   UINT8_C(0x0f)"
.br
.RI "ak8975 I2C address when CAD1 and CAD0 are high "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_AK8975_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fRi2c_ak8975_config_t\fP to default configuration settings\&. "
.ti -1c
.RI "#define \fBI2C_AS3935_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "AS3935 definitions\&. "
.ti -1c
.RI "#define \fBI2C_AS3935_DEV_ADDR_1\fP   UINT8_C(0x01)"
.br
.RI "as3935 I2C address when ADD1 pin floating/low and ADD0 pin high "
.ti -1c
.RI "#define \fBI2C_AS3935_DEV_ADDR_2\fP   UINT8_C(0x02)"
.br
.RI "as3935 I2C address when ADD0 pin floating/low and ADD1 pin high "
.ti -1c
.RI "#define \fBI2C_AS3935_DEV_ADDR_3\fP   UINT8_C(0x03)"
.br
.RI "as3935 I2C address when ADD0 and ADD1 pins high "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBAS3935_REG_00\fP   UINT8_C(0x00)"
.br
.RI "as3935 I2C register to access AFE gain boost and power-down "
.ti -1c
.RI "#define \fBAS3935_REG_01\fP   UINT8_C(0x01)"
.br
.RI "as3935 I2C register to access noise floor level and watchdog threshold (0-15) "
.ti -1c
.RI "#define \fBAS3935_REG_02\fP   UINT8_C(0x02)"
.br
.RI "as3935 I2C register to access clearing statistics, minimum number of lightning, and spike rejection "
.ti -1c
.RI "#define \fBAS3935_REG_03\fP   UINT8_C(0x03)"
.br
.RI "as3935 I2C register to access frequency division ratio and mask disturber "
.ti -1c
.RI "#define \fBAS3935_REG_04\fP   UINT8_C(0x04)"
.br
.RI "as3935 I2C register to access energy of lightning (LSBYTE) "
.ti -1c
.RI "#define \fBAS3935_REG_05\fP   UINT8_C(0x05)"
.br
.RI "as3935 I2C register to access energy of lightning (MSBYTE) "
.ti -1c
.RI "#define \fBAS3935_REG_06\fP   UINT8_C(0x06)"
.br
.RI "as3935 I2C register to access energy of lightning (MMSBYTE) "
.ti -1c
.RI "#define \fBAS3935_REG_07\fP   UINT8_C(0x07)"
.br
.RI "as3935 I2C register to access distance estimation of lightning "
.ti -1c
.RI "#define \fBAS3935_REG_08\fP   UINT8_C(0x08)"
.br
.RI "as3935 I2C register to access internal tuning caps and display (LCO, SRCO, TRCO) on IRQ pin "
.ti -1c
.RI "#define \fBAS3935_REG_RST\fP   UINT8_C(0x96)"
.br
.RI "as3935 I2C register to either calibrate or reset registers to default "
.ti -1c
.RI "#define \fBAS3935_CMD_PRESET_DEFAULT\fP   UINT8_C(0x3c)"
.br
.RI "as3935 I2C command to set all registers in default mode "
.ti -1c
.RI "#define \fBAS3935_CMD_CALIB_RCO\fP   UINT8_C(0x3d)"
.br
.RI "as3935 I2C command to automatically calibrate the internal RC oscillators "
.ti -1c
.RI "#define \fBAS3935_POWERUP_DELAY_MS\fP   (25)"
.br
.ti -1c
.RI "#define \fBAS3935_APPSTART_DELAY_MS\fP   (25)"
.br
.ti -1c
.RI "#define \fBAS3935_STARTUP_DELAY_MS\fP   (2)"
.br
.RI "as3935 I2C LCO start-up delay in milliseconds "
.ti -1c
.RI "#define \fBAS3935_INTERRUPT_DELAY_MS\fP   (2)"
.br
.RI "as3935 I2C interrupt delay in milliseconds "
.ti -1c
.RI "#define \fBAS3935_CALIBRATION_DELAY_MS\fP   (2)"
.br
.RI "as3935 I2C calibration delay in milliseconds for RC oscillators "
.ti -1c
.RI "#define \fBAS3935_TX_RX_DELAY_MS\fP   UINT16_C(10)"
.br
.ti -1c
.RI "#define \fBI2C_AS3935_CONFIG_DEFAULT\fP"
.br
.RI "CJMCU-3935 Board Wiring (I2C interface): ADD0 & ADD1 pin to VCC (3\&.3v) -> I2C address 0x03 SI pin to VCC (3\&.3v) -> enable I2C interface SCL pin 10k-ohm pull-up resistor to VCC (3\&.3v) SCL pin to MCU SCL pin MOSI (SDA) pin to MCU SDA pin IRQ pin to MCU interrupt pin VCC pin to 3\&.3v GND pin to common ground\&. "
.ti -1c
.RI "#define \fBI2C_AS7341_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "as7341 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_AS7341_DEV_ADDR\fP   UINT8_C(0x39)"
.br
.RI "as7341 I2C address "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_AS7341_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBI2C_BH1750_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "bh1750 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_BH1750_DEV_ADDR_LO\fP   UINT8_C(0x23)"
.br
.RI "bh1750 I2C address when ADDR pin floating/low "
.ti -1c
.RI "#define \fBI2C_BH1750_DEV_ADDR_HI\fP   UINT8_C(0x5C)"
.br
.RI "bh1750 I2C address when ADDR pin high "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_BH1750_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBI2C_BME680_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "bme680 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_BME680_DEV_ADDR_LO\fP   UINT8_C(0x76)"
.br
.RI "bme680 I2C address when ADDR pin floating/low "
.ti -1c
.RI "#define \fBI2C_BME680_DEV_ADDR_HI\fP   UINT8_C(0x77)"
.br
.RI "bme680 I2C address when ADDR pin high "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBBME680_HEATER_TEMP_MIN\fP   UINT8_C(200)"
.br
.ti -1c
.RI "#define \fBBME680_HEATER_TEMP_MAX\fP   UINT8_C(400)"
.br
.ti -1c
.RI "#define \fBBME680_HEATER_PROFILE_SIZE\fP   UINT8_C(10)"
.br
.ti -1c
.RI "#define \fBI2C_BME680_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBI2C_BMP280_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "bmp280 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_BMP280_DEV_ADDR_LO\fP   UINT8_C(0x76)"
.br
.RI "bmp280 I2C address when ADDR pin floating/low "
.ti -1c
.RI "#define \fBI2C_BMP280_DEV_ADDR_HI\fP   UINT8_C(0x77)"
.br
.RI "bmp280 I2C address when ADDR pin high "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_BMP280_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fR\fBbmp280_config_t\fP\fP to default configuration settings\&. "
.ti -1c
.RI "#define \fBI2C_BMP390_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "bmp390 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_BMP390_DEV_ADDR_LO\fP   UINT8_C(0x76)"
.br
.RI "bmp390 I2C address when ADDR pin low "
.ti -1c
.RI "#define \fBI2C_BMP390_DEV_ADDR_HI\fP   UINT8_C(0x77)"
.br
.RI "bmp390 I2C address when ADDR pin high "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_BMP390_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBI2C_CCS811_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "ccs811 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_CCS811_DEV_ADDR_LO\fP   UINT8_C(0x5a)"
.br
.RI "ccs811 I2C address when ADDR pin floating/low "
.ti -1c
.RI "#define \fBI2C_CCS811_DEV_ADDR_HI\fP   UINT8_C(0x5b)"
.br
.RI "ccs811 I2C address when ADDR pin high "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBCCS811_ERROR_TABLE_SIZE\fP   (6)"
.br
.RI "ccs811 I2C error table size "
.ti -1c
.RI "#define \fBCCS811_MEASURE_MODE_TABLE_SIZE\fP   (5)"
.br
.RI "ccs811 I2C measure mode table size "
.ti -1c
.RI "#define \fBI2C_CCS811_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBI2C_ENS160_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "ens160 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_ENS160_DEV_ADDR_LO\fP   UINT8_C(0x52)"
.br
.RI "ens160 I2C address ADDR pin low "
.ti -1c
.RI "#define \fBI2C_ENS160_DEV_ADDR_HI\fP   UINT8_C(0x53)"
.br
.RI "ens160 I2C address ADDR pin high "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBENS160_TVOC_MIN\fP   UINT16_C(0)"
.br
.ti -1c
.RI "#define \fBENS160_TVOC_MAX\fP   UINT16_C(65000)"
.br
.ti -1c
.RI "#define \fBENS160_ECO2_MIN\fP   UINT16_C(400)"
.br
.ti -1c
.RI "#define \fBENS160_ECO2_MAX\fP   UINT16_C(65000)"
.br
.ti -1c
.RI "#define \fBENS160_AQI_MIN\fP   UINT16_C(1)"
.br
.ti -1c
.RI "#define \fBENS160_AQI_MAX\fP   UINT16_C(5)"
.br
.ti -1c
.RI "#define \fBENS160_ERROR_MSG_SIZE\fP   (80)"
.br
.RI "ens160 I2C error message size "
.ti -1c
.RI "#define \fBENS160_ERROR_MSG_TABLE_SIZE\fP   (7)"
.br
.RI "ens160 I2C error message table size "
.ti -1c
.RI "#define \fBI2C_ENS160_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fRi2c_ens160_config_t\fP to default configuration settings\&. "
.ti -1c
.RI "#define \fBI2C_HDC1080_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "hdc1080 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_HDC1080_DEV_ADDR_0\fP   UINT8_C(0x40)"
.br
.RI "hdc1080 I2C address when ADR1 = 0, ADR0 = 0 "
.ti -1c
.RI "#define \fBI2C_HDC1080_DEV_ADDR_1\fP   UINT8_C(0x41)"
.br
.RI "hdc1080 I2C address when ADR1 = 0, ADR0 = 1 "
.ti -1c
.RI "#define \fBI2C_HDC1080_DEV_ADDR_2\fP   UINT8_C(0x42)"
.br
.RI "hdc1080 I2C address when ADR1 = 1, ADR0 = 0 "
.ti -1c
.RI "#define \fBI2C_HDC1080_DEV_ADDR_3\fP   UINT8_C(0x43)"
.br
.RI "hdc1080 I2C address when ADR1 = 1, ADR0 = 1 "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_HDC1080_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fRi2c_hdc1080_config_t\fP to default configuration settings\&. "
.ti -1c
.RI "#define \fBI2C_HMC5883L_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "hmc5883l I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_HMC5883L_DEV_ADDR\fP   UINT8_C(0x1e)"
.br
.RI "hmc5883l I2C address when ADDR pin floating/low "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_HMC5883L_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBI2C_INA226_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "ina226 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_GND_GND\fP   UINT8_C(0x40)"
.br
.RI "ina226 I2C address, A1 pin - GND, A0 pin - GND "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_GND_VS\fP   UINT8_C(0x41)"
.br
.RI "ina226 I2C address, A1 pin - GND, A0 pin - VS+ "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_GND_SDA\fP   UINT8_C(0x42)"
.br
.RI "ina226 I2C address, A1 pin - GND, A0 pin - SDA "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_GND_SCL\fP   UINT8_C(0x43)"
.br
.RI "ina226 I2C address, A1 pin - GND, A0 pin - SCL "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_VS_GND\fP   UINT8_C(0x44)"
.br
.RI "ina226 I2C address, A1 pin - VS+, A0 pin - GND "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_VS_VS\fP   UINT8_C(0x45)"
.br
.RI "ina226 I2C address, A1 pin - VS+, A0 pin - VS+ "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_VS_SDA\fP   UINT8_C(0x46)"
.br
.RI "ina226 I2C address, A1 pin - VS+, A0 pin - SDA "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_VS_SCL\fP   UINT8_C(0x47)"
.br
.RI "ina226 I2C address, A1 pin - VS+, A0 pin - SCL "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_SDA_GND\fP   UINT8_C(0x48)"
.br
.RI "ina226 I2C address, A1 pin - SDA, A0 pin - GND "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_SDA_VS\fP   UINT8_C(0x49)"
.br
.RI "ina226 I2C address, A1 pin - SDA, A0 pin - VS+ "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_SDA_SDA\fP   UINT8_C(0x4a)"
.br
.RI "ina226 I2C address, A1 pin - SDA, A0 pin - SDA "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_SDA_SCL\fP   UINT8_C(0x4b)"
.br
.RI "ina226 I2C address, A1 pin - SDA, A0 pin - SCL "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_SCL_GND\fP   UINT8_C(0x4c)"
.br
.RI "ina226 I2C address, A1 pin - SCL, A0 pin - GND "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_SCL_VS\fP   UINT8_C(0x4d)"
.br
.RI "ina226 I2C address, A1 pin - SCL, A0 pin - VS+ "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_SCL_SDA\fP   UINT8_C(0x4e)"
.br
.RI "ina226 I2C address, A1 pin - SCL, A0 pin - SDA "
.ti -1c
.RI "#define \fBI2C_INA226_ADDR_SCL_SCL\fP   UINT8_C(0x4f)"
.br
.RI "ina226 I2C address, A1 pin - SCL, A0 pin - SCL "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_INA226_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBI2C_LTR390UV_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "ltr390uv I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_LTR390UV_DEV_ADDR\fP   UINT8_C(0x53)"
.br
.RI "ltr390uv I2C address "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_LTR390UV_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fR\fBltr390uv_config_t\fP\fP to default configuration settings\&. "
.ti -1c
.RI "#define \fBI2C_MAX30105_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "max30105 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_MAX30105_DEV_ADDR\fP   UINT8_C(0x38)"
.br
.RI "max30105 I2C address "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_MAX30105_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBI2C_MLX90614_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "mlx90614 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_MLX90614_DEV_ADDR\fP   UINT8_C(0x5A)"
.br
.RI "mlx90614 I2C address when ADDR pin floating/low "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_MLX90614_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBI2C_MMC56X3_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "mmc56x3 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_MMC56X3_DEV_ADDR\fP   UINT8_C(0x30)"
.br
.RI "mmc56x3 I2C address "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_MMC56X3_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fR\fBmmc56x3_config_t\fP\fP to default configuration settings\&. "
.ti -1c
.RI "#define \fBI2C_MPU6050_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "mpu6050 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_MPU6050_DEV_ADDR_H\fP   UINT8_C(0x69)"
.br
.RI "mpu6050 I2C address when AD0 = 1 or to vcc "
.ti -1c
.RI "#define \fBI2C_MPU6050_DEV_ADDR_L\fP   UINT8_C(0x68)"
.br
.RI "mpu6050 I2C address when AD0 = 0 or to gnd "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_MPU6050_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBI2C_SGP4X_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "sgp4x I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_SGP4X_DEV_ADDR\fP   UINT8_C(0x59)"
.br
.RI "sgp4x I2C address "
.ti -1c
.RI "#define \fBI2C_SGP4X_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_SGP41_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBI2C_SHT4X_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "sht4x i2c default scl clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_SHT4X_DEV_ADDR_LO\fP   UINT8_C(0x44)"
.br
.RI "sht4x i2c address when ADDR pin floating/low "
.ti -1c
.RI "#define \fBI2C_SHT4X_DEV_ADDR_HI\fP   UINT8_C(0x45)"
.br
.RI "sht4x i2c address when ADDR pin high "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_SHT4X_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fRi2c_sht4x_config_t\fP to default configuration settings\&. "
.ti -1c
.RI "#define \fBFONT_LATIN_8x8_COLS_SIZE\fP   8"
.br
.ti -1c
.RI "#define \fBFONT_LATIN_8x8_ROWS_SIZE\fP   256"
.br
.ti -1c
.RI "#define \fBI2C_SSD1306_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "ssd1306 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_SSD1306_DEV_ADDR\fP   UINT8_C(0x3c)"
.br
.RI "ssd1306 I2C address "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBSSD1306_PAGE_SEGMENT_SIZE\fP   128"
.br
.RI "ssd1306 segment size "
.ti -1c
.RI "#define \fBSSD1306_PAGE_128x32_SIZE\fP   4"
.br
.RI "ssd1306 128x32 page size "
.ti -1c
.RI "#define \fBSSD1306_PAGE_128x64_SIZE\fP   8"
.br
.RI "ssd1306 128x64 page size "
.ti -1c
.RI "#define \fBSSD1306_PAGE_128x128_SIZE\fP   16"
.br
.RI "ssd1306 128x128 page size "
.ti -1c
.RI "#define \fBSSD1306_PANEL_128x32_WIDTH\fP   128"
.br
.RI "ssd1306 128x32 panel width "
.ti -1c
.RI "#define \fBSSD1306_PANEL_128x64_WIDTH\fP   128"
.br
.RI "ssd1306 128x64 panel width "
.ti -1c
.RI "#define \fBSSD1306_PANEL_128x128_WIDTH\fP   128"
.br
.RI "ssd1306 128x128 panel width "
.ti -1c
.RI "#define \fBSSD1306_PANEL_128x32_HEIGHT\fP   32"
.br
.RI "ssd1306 128x32 panel height "
.ti -1c
.RI "#define \fBSSD1306_PANEL_128x64_HEIGHT\fP   64"
.br
.RI "ssd1306 128x64 panel height "
.ti -1c
.RI "#define \fBSSD1306_PANEL_128x128_HEIGHT\fP   128"
.br
.RI "ssd1306 128x128 panel height "
.ti -1c
.RI "#define \fBI2C_SSD1306_128x32_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fR\fBssd1306_config_t\fP\fP to default configuration settings for a 128x32 display\&. "
.ti -1c
.RI "#define \fBI2C_SSD1306_128x64_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fR\fBssd1306_config_t\fP\fP to default configuration settings for a 128x64 display\&. "
.ti -1c
.RI "#define \fBI2C_SSD1306_128x128_CONFIG_DEFAULT\fP"
.br
.RI "Macro that initializes \fR\fBssd1306_config_t\fP\fP to default configuration settings for a 128x128 display\&. "
.ti -1c
.RI "#define \fBI2C_TBI2CXXX_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "tbi2cxxx I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_TBI2CXXX_DEV_ADDR\fP   UINT8_C(0x3a)"
.br
.RI "tbi2cxxx I2C address "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_AHT2X_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBTBI2CXXX_FW_VERSION_MAJOR\fP   1"
.br
.ti -1c
.RI "#define \fBTBI2CXXX_FW_VERSION_MINOR\fP   1"
.br
.ti -1c
.RI "#define \fBTBI2CXXX_FW_VERSION_PATCH\fP   6"
.br
.ti -1c
.RI "#define \fBSTR_QUOTES\fP(x)"
.br
.ti -1c
.RI "#define \fBSTR\fP(x)"
.br
.ti -1c
.RI "#define \fBTBI2CXXX_FW_VERSION_STR\fP"
.br
.ti -1c
.RI "#define \fBTBI2CXXX_FW_VERSION_PARAMS_INT32\fP(major,  minor,  patch)"
.br
.ti -1c
.RI "#define \fBTBI2CXXX_FW_VERSION_INT32\fP"
.br
.ti -1c
.RI "#define \fBI2C_TLV493D_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "tlv493d I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_TLV493D_DEV_ADDR_LO\fP   UINT8_C(0x1F)"
.br
.RI "tlv493d I2C address "
.ti -1c
.RI "#define \fBI2C_TLV493D_DEV_ADDR_HI\fP   UINT8_C(0x5E)"
.br
.RI "tlv493d I2C address "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_TLV493D_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBI2C_VEML6040_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "veml6040 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_VEML6040_DEV_ADDR\fP   UINT8_C(0x10)"
.br
.RI "veml6040 I2C address "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_VEML6040_CONFIG_DEFAULT\fP"
.br
.RI "VEML6040 device configuration initialization default macro\&. "
.ti -1c
.RI "#define \fBI2C_VEML7700_DEV_CLK_SPD\fP   UINT32_C(100000)"
.br
.RI "veml7700 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBI2C_VEML7700_DEV_ADDR\fP   UINT8_C(0x10)"
.br
.RI "veml7700 I2C address "
.ti -1c
.RI "#define \fBI2C_XFR_TIMEOUT_MS\fP   (500)"
.br
.RI "I2C transaction timeout in milliseconds\&. "
.ti -1c
.RI "#define \fBI2C_VEML7700_CONFIG_DEFAULT\fP"
.br
.RI "VEML7700 device configuration initialization default\&. "
.ti -1c
.RI "#define \fBOWB_DS18B20_CONFIG_DEFAULT\fP"
.br
.ti -1c
.RI "#define \fBI2C_MAX31865_SCL_SPEED_HZ\fP   UINT32_C(100000)"
.br
.RI "max31865 I2C default clock frequency (100KHz) "
.ti -1c
.RI "#define \fBSPI_MAX31865_DEV_ADDR\fP   UINT8_C(0x38)"
.br
.RI "max31865 I2C address "
.ti -1c
.RI "#define \fBDATATABLE_NAME_MAX_SIZE\fP   (15)"
.br
.RI "15-characters for user-defined table name "
.ti -1c
.RI "#define \fBDATATABLE_COLUMN_NAME_SIZE\fP   (15)"
.br
.RI "15-characters for user-defined column name "
.ti -1c
.RI "#define \fBDATATABLE_COLUMN_NAME_MAX_SIZE\fP   (25)"
.br
.RI "25-characters for column name "
.ti -1c
.RI "#define \fBDATATABLE_COLUMNS_MAX\fP   (255)"
.br
.ti -1c
.RI "#define \fBDATATABLE_ROWS_MAX\fP   (65535)"
.br
.ti -1c
.RI "#define \fBDATATABLE_COLUMN_ID_NAME\fP   'Record ID'"
.br
.ti -1c
.RI "#define \fBDATATABLE_COLUMN_TS_NAME\fP   'TS'"
.br
.ti -1c
.RI "#define \fBDATATABLE_COLUMN_TII_SMP_NAME\fP   '_tii_smp'"
.br
.ti -1c
.RI "#define \fBDATATABLE_COLUMN_TII_PRC_NAME\fP   '_tii_prc'"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBs12sd_config_s\fP \fBs12sd_config_t\fP"
.br
.RI "S12SD configuration structure definition\&. "
.ti -1c
.RI "typedef struct s12sd_context_t \fBs12sd_context_t\fP"
.br
.RI "S12SD context structure definition\&. "
.ti -1c
.RI "typedef struct \fBs12sd_context_t\fP * \fBs12sd_handle_t\fP"
.br
.RI "S12SD handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBahtxx_sensor_types_e\fP \fBahtxx_sensor_types_t\fP"
.br
.RI "AHTXX sensor types enumerator definition\&. "
.ti -1c
.RI "typedef struct \fBahtxx_config_s\fP \fBahtxx_config_t\fP"
.br
.RI "AHTXX configuration structure definition\&. "
.ti -1c
.RI "typedef struct ahtxx_context_t \fBahtxx_context_t\fP"
.br
.RI "AHTXX context structure definition\&. "
.ti -1c
.RI "typedef struct \fBahtxx_context_t\fP * \fBahtxx_handle_t\fP"
.br
.RI "AHTXX handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBak8975_operating_modes_e\fP \fBak8975_operating_modes_t\fP"
.br
.RI "AK8975 operating modes enumerator\&. "
.ti -1c
.RI "typedef struct \fBak8975_magnetic_axes_data_s\fP \fBak8975_magnetic_axes_data_t\fP"
.br
.RI "AK8975 processed compass axes data structure and axes have a range +/-1229 uT\&. "
.ti -1c
.RI "typedef struct \fBak8975_axes_data_s\fP \fBak8975_axes_data_t\fP"
.br
.RI "AK8975 axes data registers (HX, HZ, HZ) structure\&. "
.ti -1c
.RI "typedef struct \fBak8975_config_s\fP \fBak8975_config_t\fP"
.br
.RI "AK8975 configuration structure\&. "
.ti -1c
.RI "typedef struct ak8975_context_t \fBak8975_context_t\fP"
.br
.RI "AK8975 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBak8975_context_t\fP * \fBak8975_handle_t\fP"
.br
.RI "AK8975 handle structure definition\&. "
.ti -1c
.RI "typedef void * \fBas3935_monitor_handle_t\fP"
.br
.RI "AS3935 monitor handle definition\&. "
.ti -1c
.RI "typedef enum \fBas3935_analog_frontends_e\fP \fBas3935_analog_frontends_t\fP"
.br
.RI "AS3935 enumerator and structure declarations\&. "
.ti -1c
.RI "typedef enum \fBas3935_power_states_e\fP \fBas3935_power_states_t\fP"
.br
.RI "AS3935 power states REG0x00[0] enumerator\&. "
.ti -1c
.RI "typedef enum \fBas3935_clear_statistics_states_e\fP \fBas3935_clear_statistics_states_t\fP"
.br
.RI "AS3935 clear statistics states REG0x02[6] enumerator\&. "
.ti -1c
.RI "typedef enum \fBas3935_disturber_detection_states_e\fP \fBas3935_disturber_detection_states_t\fP"
.br
.RI "AS3935 disturber detection states REG0x03[5] enumerator\&. "
.ti -1c
.RI "typedef enum \fBas3935_co_irq_pin_states_e\fP \fBas3935_co_irq_pin_states_t\fP"
.br
.RI "AS3935 CO IRQ pin states REG0x08[5]|[6]|[7] enumerator\&. "
.ti -1c
.RI "typedef enum \fBas3935_watchdog_thresholds_e\fP \fBas3935_watchdog_thresholds_t\fP"
.br
.RI "AS3935 watchdog thresholds REG0x01[3:0] enumerator\&. "
.ti -1c
.RI "typedef enum \fBas3935_noise_levels_e\fP \fBas3935_noise_levels_t\fP"
.br
.RI "AS3935 noise floor generator and evaluation REG0x01[6:4] enumerator\&. "
.ti -1c
.RI "typedef enum \fBas3935_interrupt_states_e\fP \fBas3935_interrupt_states_t\fP"
.br
.RI "AS3935 interrupt states REG0x03[3:0] enumerator\&. "
.ti -1c
.RI "typedef enum \fBas3935_minimum_lightnings_e\fP \fBas3935_minimum_lightnings_t\fP"
.br
.RI "AS3935 minimum number of lightning detections REG0x02[5:4] enumerator\&. "
.ti -1c
.RI "typedef enum \fBas3935_frequency_division_ratios_e\fP \fBas3935_frequency_division_ratios_t\fP"
.br
.RI "AS3935 frequency division ratio for antenna tunning REG0x03[7:3] LCO_FDIV enumerator\&. "
.ti -1c
.RI "typedef enum \fBas3935_lightning_distances_e\fP \fBas3935_lightning_distances_t\fP"
.br
.RI "AS3935 lightning estimated distances REG0x07[5:0] enumerator\&. "
.ti -1c
.RI "typedef enum \fBas3935_rco_calibration_results_e\fP \fBas3935_rco_calibration_results_t\fP"
.br
.RI "AS3935 oscillator calibration status results enumerator\&. "
.ti -1c
.RI "typedef enum \fBas3935_oscillator_modes_e\fP \fBas3935_oscillator_modes_t\fP"
.br
.RI "AS3935 tuning mode oscillators enumerator\&. "
.ti -1c
.RI "typedef struct \fBas3935_config_s\fP \fBas3935_config_t\fP"
.br
.RI "I2C AS3935 device configuration structure\&. "
.ti -1c
.RI "typedef struct as3935_context_t \fBas3935_context_t\fP"
.br
.RI "AS3935 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBas3935_context_t\fP * \fBas3935_handle_t\fP"
.br
.RI "AS3935 handle structure definition\&. "
.ti -1c
.RI "typedef gpio_isr_t \fBas3935_isr_t\fP"
.br
.ti -1c
.RI "typedef struct \fBas3935_monitor_base_s\fP \fBas3935_monitor_base_t\fP"
.br
.RI "AS3935 device event object structure\&. "
.ti -1c
.RI "typedef struct \fBas3935_monitor_context_s\fP \fBas3935_monitor_context_t\fP"
.br
.RI "esp AS3935 device state machine structure\&. "
.ti -1c
.RI "typedef enum \fBas7341_als_modes_e\fP \fBas7341_als_modes_t\fP"
.br
.RI "AS7341 ambient light sensing mode enumerator\&. "
.ti -1c
.RI "typedef enum \fBas7341_led_drive_strengths_e\fP \fBas7341_led_drive_strengths_t\fP"
.br
.RI "AS7341 led driving strengths enumerator\&. "
.ti -1c
.RI "typedef enum \fBas7341_spectral_gains_e\fP \fBas7341_spectral_gains_t\fP"
.br
.RI "AS7341 allowable gain multipliers enumerator\&. "
.ti -1c
.RI "typedef enum \fBas7341_flicker_detection_gains_e\fP \fBas7341_flicker_detection_gains_t\fP"
.br
.RI "AS7341 allowable flicker detection gain multipliers enumerator\&. "
.ti -1c
.RI "typedef enum \fBas7341_flicker_detection_states_e\fP \fBas7341_flicker_detection_states_t\fP"
.br
.RI "AS7341 flicker detection states enumerator\&. "
.ti -1c
.RI "typedef enum \fBas7341_smux_commands_e\fP \fBas7341_smux_commands_t\fP"
.br
.RI "AS7341 available SMUX commands enumerator\&. "
.ti -1c
.RI "typedef struct \fBas7341_channels_basic_counts_data_s\fP \fBas7341_channels_basic_counts_data_t\fP"
.br
.RI "AS7341 channels basic counts data structure\&. "
.ti -1c
.RI "typedef struct \fBas7341_channels_spectral_data_s\fP \fBas7341_channels_spectral_data_t\fP"
.br
.RI "AS7341 channels spectral data structure\&. "
.ti -1c
.RI "typedef struct \fBas7341_config_s\fP \fBas7341_config_t\fP"
.br
.RI "AS7341 configuration structure\&. "
.ti -1c
.RI "typedef struct as7341_context_t \fBas7341_context_t\fP"
.br
.RI "AS7341 context structure definitions\&. "
.ti -1c
.RI "typedef struct \fBas7341_context_t\fP * \fBas7341_handle_t\fP"
.br
.RI "AS7341 handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBbh1750_measurement_modes_e\fP \fBbh1750_measurement_modes_t\fP"
.br
.RI "BH1750 measurement modes enumerator\&. "
.ti -1c
.RI "typedef struct \fBbh1750_config_s\fP \fBbh1750_config_t\fP"
.br
.RI "BH1750 device configuration structure\&. "
.ti -1c
.RI "typedef struct bh1750_context_t \fBbh1750_context_t\fP"
.br
.RI "BH1750 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBbh1750_context_t\fP * \fBbh1750_handle_t\fP"
.br
.RI "BH1750 handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBbme680_heater_setpoints_e\fP \fBbme680_heater_setpoints_t\fP"
.br
.RI "BME680 heater set-points enumerator\&. "
.ti -1c
.RI "typedef enum \fBbme680_gas_wait_multipliers_e\fP \fBbme680_gas_wait_multipliers_t\fP"
.br
.RI "BME680 gas wait multipliers enumerator\&. "
.ti -1c
.RI "typedef enum \fBbme680_iir_filters_e\fP \fBbme680_iir_filters_t\fP"
.br
.RI "BME680 IIR filters coefficient enumerator\&. "
.ti -1c
.RI "typedef enum \fBbme680_power_modes_e\fP \fBbme680_power_modes_t\fP"
.br
.RI "BME680 power modes enumerator\&. "
.ti -1c
.RI "typedef enum \fBbme680_pressure_oversampling_e\fP \fBbme680_pressure_oversampling_t\fP"
.br
.RI "BME680 pressure oversampling enumerator\&. "
.ti -1c
.RI "typedef enum \fBbme680_temperature_oversampling_e\fP \fBbme680_temperature_oversampling_t\fP"
.br
.RI "BME680 temperature oversampling enumerator\&. "
.ti -1c
.RI "typedef enum \fBbme680_humidity_oversampling_e\fP \fBbme680_humidity_oversampling_t\fP"
.br
.RI "BME680 humidity oversampling enumerator\&. "
.ti -1c
.RI "typedef struct \fBbme680_cal_factors_s\fP \fBbme680_cal_factors_t\fP"
.br
.RI "BME680 calibration factors structure definition\&. "
.ti -1c
.RI "typedef struct \fBbme680_data_s\fP \fBbme680_data_t\fP"
.br
.RI "BME680 data structure definition\&. "
.ti -1c
.RI "typedef struct \fBbme680_adc_data_s\fP \fBbme680_adc_data_t\fP"
.br
.RI "BME680 ADC data structure definition\&. "
.ti -1c
.RI "typedef struct \fBbme680_config_s\fP \fBbme680_config_t\fP"
.br
.RI "BME680 configuration structure definition\&. "
.ti -1c
.RI "typedef struct bme680_context_t \fBbme680_context_t\fP"
.br
.RI "BME680 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBbme680_context_t\fP * \fBbme680_handle_t\fP"
.br
.RI "BME680 handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBbmp280_iir_filters_e\fP \fBbmp280_iir_filters_t\fP"
.br
.RI "BMP280 IIR filters coefficient enumerator definition\&. "
.ti -1c
.RI "typedef enum \fBbmp280_standby_times_e\fP \fBbmp280_standby_times_t\fP"
.br
.RI "BMP280 stand-by times enumerator definition\&. "
.ti -1c
.RI "typedef enum \fBbmp280_power_modes_e\fP \fBbmp280_power_modes_t\fP"
.br
.RI "BMP280 power modes enumerator definition\&. "
.ti -1c
.RI "typedef enum \fBbmp280_pressure_oversampling_e\fP \fBbmp280_pressure_oversampling_t\fP"
.br
.RI "BMP280 pressure oversampling enumerator definition\&. "
.ti -1c
.RI "typedef enum \fBbmp280_temperature_oversampling_e\fP \fBbmp280_temperature_oversampling_t\fP"
.br
.RI "BMP280 temperature oversampling enumerator definition\&. "
.ti -1c
.RI "typedef struct \fBbmp280_cal_factors_s\fP \fBbmp280_cal_factors_t\fP"
.br
.RI "BMP280 temperature and pressure calibration factors structure definition\&. "
.ti -1c
.RI "typedef struct \fBbmp280_config_s\fP \fBbmp280_config_t\fP"
.br
.RI "BMP280 configuration structure definition\&. "
.ti -1c
.RI "typedef struct bmp280_context_t \fBbmp280_context_t\fP"
.br
.RI "BMP280 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBbmp280_context_t\fP * \fBbmp280_handle_t\fP"
.br
.RI "BMP280 handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBbmp390_iir_filters_e\fP \fBbmp390_iir_filters_t\fP"
.br
.RI "BMP390 IIR filters coefficient enumerator\&. "
.ti -1c
.RI "typedef enum \fBbmp390_output_data_rates_e\fP \fBbmp390_output_data_rates_t\fP"
.br
.RI "BMP390 output data rates enumerator\&. "
.ti -1c
.RI "typedef enum \fBbmp390_power_modes_e\fP \fBbmp390_power_modes_t\fP"
.br
.RI "BMP390 power modes enumerator\&. "
.ti -1c
.RI "typedef enum \fBbmp390_pressure_oversampling_e\fP \fBbmp390_pressure_oversampling_t\fP"
.br
.RI "BMP390 pressure oversampling enumerator\&. "
.ti -1c
.RI "typedef enum \fBbmp390_temperature_oversampling_e\fP \fBbmp390_temperature_oversampling_t\fP"
.br
.RI "BMP390 temperature oversampling enumerator\&. "
.ti -1c
.RI "typedef struct \fBbmp390_cal_factors_s\fP \fBbmp390_cal_factors_t\fP"
.br
.RI "BMP390 temperature and pressure calibration factors structure\&. "
.ti -1c
.RI "typedef struct \fBbmp390_conv_cal_factors_s\fP \fBbmp390_conv_cal_factors_t\fP"
.br
.RI "BMP390 temperature and pressure converted calibration factors structure\&. "
.ti -1c
.RI "typedef struct \fBbmp390_config_s\fP \fBbmp390_config_t\fP"
.br
.RI "BMP390 configuration structure\&. "
.ti -1c
.RI "typedef struct bmp390_context_t \fBbmp390_context_t\fP"
.br
.RI "BMP390 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBbmp390_context_t\fP * \fBbmp390_handle_t\fP"
.br
.RI "BMP390 handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBccs811_drive_modes_e\fP \fBccs811_drive_modes_t\fP"
.br
.ti -1c
.RI "typedef enum \fBccs811_firmware_modes_e\fP \fBccs811_firmware_modes_t\fP"
.br
.ti -1c
.RI "typedef struct \fBccs811_thresholds_register_s\fP \fBccs811_thresholds_register_t\fP"
.br
.RI "CCS811 thresholds register structure\&. "
.ti -1c
.RI "typedef struct \fBccs811_environmental_data_register_s\fP \fBccs811_environmental_data_register_t\fP"
.br
.RI "CCS811 environmental data register structure\&. "
.ti -1c
.RI "typedef struct \fBccs811_error_row_s\fP \fBccs811_error_row_t\fP"
.br
.RI "CCS811 error row definition structure\&. "
.ti -1c
.RI "typedef struct \fBccs811_measure_mode_row_s\fP \fBccs811_measure_mode_row_t\fP"
.br
.RI "CCS811 measure mode row definition structure\&. "
.ti -1c
.RI "typedef struct ccs811_context_t \fBccs811_context_t\fP"
.br
.RI "CCS811 context structure definitions\&. "
.ti -1c
.RI "typedef struct \fBccs811_context_t\fP * \fBccs811_handle_t\fP"
.br
.RI "CCS811 handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBens160_aqi_uba_indexes_e\fP \fBens160_aqi_uba_indexes_t\fP"
.br
.RI "ENS160 air quality index of the uba enumerator\&. "
.ti -1c
.RI "typedef enum \fBens160_interrupt_pin_polarities_e\fP \fBens160_interrupt_pin_polarities_t\fP"
.br
.RI "ENS160 interrupt pin polarities enumerator\&. "
.ti -1c
.RI "typedef enum \fBens160_interrupt_pin_drivers_e\fP \fBens160_interrupt_pin_drivers_t\fP"
.br
.RI "ENS160 interrupt pin drivers enumerator\&. "
.ti -1c
.RI "typedef enum \fBens160_operating_modes_e\fP \fBens160_operating_modes_t\fP"
.br
.RI "ENS160 operating modes enumerator\&. "
.ti -1c
.RI "typedef enum \fBens160_commands_e\fP \fBens160_commands_t\fP"
.br
.RI "ENS160 commands enumerator\&. "
.ti -1c
.RI "typedef enum \fBens160_validity_flags_e\fP \fBens160_validity_flags_t\fP"
.br
.RI "ENS160 validity flags enumerator\&. "
.ti -1c
.RI "typedef union \fBens160_app_version_u\fP \fBens160_app_version_t\fP"
.br
.RI "ENS160 application version register structure\&. "
.ti -1c
.RI "typedef struct \fBens160_air_quality_data_s\fP \fBens160_air_quality_data_t\fP"
.br
.RI "ENS160 air quality data structure\&. "
.ti -1c
.RI "typedef struct \fBens160_air_quality_raw_data_s\fP \fBens160_air_quality_raw_data_t\fP"
.br
.RI "ENS160 air quality raw data structure\&. "
.ti -1c
.RI "typedef struct \fBens160_aqi_uba_row_s\fP \fBens160_aqi_uba_row_t\fP"
.br
.RI "ENS160 air quality index of the UBA row definition structure\&. "
.ti -1c
.RI "typedef struct \fBens160_config_s\fP \fBens160_config_t\fP"
.br
.RI "ENS160 configuration structure\&. "
.ti -1c
.RI "typedef struct ens160_context_t \fBens160_context_t\fP"
.br
.RI "ENS160 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBens160_context_t\fP * \fBens160_handle_t\fP"
.br
.RI "ENS160 handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBhdc1080_acquisition_modes_e\fP \fBhdc1080_acquisition_modes_t\fP"
.br
.RI "HDC1080 acquisition modes enumerator definition\&. "
.ti -1c
.RI "typedef enum \fBhdc1080_battery_states_e\fP \fBhdc1080_battery_states_t\fP"
.br
.RI "HDC1080 battery states enumerator definition\&. "
.ti -1c
.RI "typedef enum \fBhdc1080_temperature_resolutions_e\fP \fBhdc1080_temperature_resolutions_t\fP"
.br
.RI "HDC1080 temperature measurement resolutions enumerator definition\&. "
.ti -1c
.RI "typedef enum \fBhdc1080_humidity_resolutions_e\fP \fBhdc1080_humidity_resolutions_t\fP"
.br
.RI "HDC1080 humidity measurement resolutions enumerator definition\&. "
.ti -1c
.RI "typedef struct \fBhdc1080_config_s\fP \fBhdc1080_config_t\fP"
.br
.RI "HDC1080 configuration structure definition\&. "
.ti -1c
.RI "typedef struct hdc1080_context_t \fBhdc1080_context_t\fP"
.br
.RI "HDC1080 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBhdc1080_context_t\fP * \fBhdc1080_handle_t\fP"
.br
.RI "HDC1080 handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBhmc5883l_calibration_options_e\fP \fBhmc5883l_calibration_options_t\fP"
.br
.ti -1c
.RI "typedef enum \fBhmc5883l_modes_e\fP \fBhmc5883l_modes_t\fP"
.br
.ti -1c
.RI "typedef enum \fBhmc5883l_sample_averages_e\fP \fBhmc5883l_sample_averages_t\fP"
.br
.ti -1c
.RI "typedef enum \fBhmc5883l_data_rates_e\fP \fBhmc5883l_data_rates_t\fP"
.br
.ti -1c
.RI "typedef enum \fBhmc5883l_biases_e\fP \fBhmc5883l_biases_t\fP"
.br
.ti -1c
.RI "typedef enum \fBhmc5883l_gains_e\fP \fBhmc5883l_gains_t\fP"
.br
.ti -1c
.RI "typedef struct \fBhmc5883l_axes_data_s\fP \fBhmc5883l_axes_data_t\fP"
.br
.ti -1c
.RI "typedef struct \fBhmc5883l_magnetic_axes_data_s\fP \fBhmc5883l_magnetic_axes_data_t\fP"
.br
.ti -1c
.RI "typedef struct \fBhmc5883l_offset_axes_data_s\fP \fBhmc5883l_offset_axes_data_t\fP"
.br
.ti -1c
.RI "typedef struct \fBhmc5883l_gain_error_axes_data_s\fP \fBhmc5883l_gain_error_axes_data_t\fP"
.br
.ti -1c
.RI "typedef struct \fBhmc5883l_config_s\fP \fBhmc5883l_config_t\fP"
.br
.RI "HMC5883L device configuration structure\&. "
.ti -1c
.RI "typedef struct hmc5883l_context_t \fBhmc5883l_context_t\fP"
.br
.RI "HMC5883L context structure definition\&. "
.ti -1c
.RI "typedef struct \fBhmc5883l_context_t\fP * \fBhmc5883l_handle_t\fP"
.br
.RI "HMC5883L handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBina226_averaging_modes_e\fP \fBina226_averaging_modes_t\fP"
.br
.RI "Averaging modes enumerator for ADC resolution/averaging\&. "
.ti -1c
.RI "typedef enum \fBina226_volt_conv_times_e\fP \fBina226_volt_conv_times_t\fP"
.br
.RI "Voltage conversion times enumerator for ADC resolution/averaging\&. "
.ti -1c
.RI "typedef enum \fBina226_operating_modes_e\fP \fBina226_operating_modes_t\fP"
.br
.RI "Current conversion times enumerator for ADC resolution/averaging\&. "
.ti -1c
.RI "typedef struct \fBina226_config_s\fP \fBina226_config_t\fP"
.br
.RI "INA226 device configuration\&. "
.ti -1c
.RI "typedef struct ina226_context_t \fBina226_context_t\fP"
.br
.RI "INA226 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBina226_context_t\fP * \fBina226_handle_t\fP"
.br
.RI "INA226 handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBltr390uv_operation_modes_e\fP \fBltr390uv_operation_modes_t\fP"
.br
.RI "LTR390UV operation modes enumerator\&. "
.ti -1c
.RI "typedef enum \fBltr390uv_sensor_resolutions_e\fP \fBltr390uv_sensor_resolutions_t\fP"
.br
.RI "LTR390UV sensor resolutions enumerator\&. "
.ti -1c
.RI "typedef enum \fBltr390uv_measurement_rates_e\fP \fBltr390uv_measurement_rates_t\fP"
.br
.RI "LTR390UV measurement rates enumerator\&. "
.ti -1c
.RI "typedef enum \fBltr390uv_measurement_gains_e\fP \fBltr390uv_measurement_gains_t\fP"
.br
.RI "LTR390UV measurement gains enumerator\&. "
.ti -1c
.RI "typedef enum \fBltr390uv_ls_interrupts_e\fP \fBltr390uv_ls_interrupts_t\fP"
.br
.RI "LTR390UV light source interrupts enumerator\&. "
.ti -1c
.RI "typedef struct \fBltr390uv_config_s\fP \fBltr390uv_config_t\fP"
.br
.RI "LTR390UV configuration structure\&. "
.ti -1c
.RI "typedef struct ltr390uv_context_t \fBltr390uv_context_t\fP"
.br
.RI "LTR390UV context structure definition\&. "
.ti -1c
.RI "typedef struct \fBltr390uv_context_t\fP * \fBltr390uv_handle_t\fP"
.br
.RI "LTR390UV handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBmax30105_adc_range_controls_e\fP \fBmax30105_adc_range_controls_t\fP"
.br
.RI "MAX30105 particle-sensing ADC range controls (18-bit resolution) enumerator (register 0x0a)\&. "
.ti -1c
.RI "typedef enum \fBmax30105_sample_rate_controls_e\fP \fBmax30105_sample_rate_controls_t\fP"
.br
.RI "MAX30105 particle-sensing sample rate control enumerator (register 0x0a)\&. "
.ti -1c
.RI "typedef enum \fBmax30105_led_pulse_width_controls_e\fP \fBmax30105_led_pulse_width_controls_t\fP"
.br
.RI "MAX30105 LED pulse width controls enumerator (register 0x0a)\&. "
.ti -1c
.RI "typedef enum \fBmax30105_control_modes_e\fP \fBmax30105_control_modes_t\fP"
.br
.RI "MAX30105 control modes enumerator\&. "
.ti -1c
.RI "typedef enum \fBmax30105_multi_led_control_modes_e\fP \fBmax30105_multi_led_control_modes_t\fP"
.br
.RI "MAX30105 multi-LED control modes enumerator (registers 0x11-0x12)\&. "
.ti -1c
.RI "typedef enum \fBmax30105_led_pulse_amplitudes_e\fP \fBmax30105_led_pulse_amplitudes_t\fP"
.br
.RI "MAX30105 LED pulse amplitudes enumerator (registers 0x0c-0x10)\&. "
.ti -1c
.RI "typedef struct \fBmax30105_config_s\fP \fBmax30105_config_t\fP"
.br
.RI "MAX30105 configuration structure\&. "
.ti -1c
.RI "typedef struct max30105_context_t \fBmax30105_context_t\fP"
.br
.RI "MAX30105 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBmax30105_context_t\fP * \fBmax30105_handle_t\fP"
.br
.RI "MAX30105 handle structure definition\&. "
.ti -1c
.RI "typedef enum mlx90614_sensor_iirs_e \fBmlx90614_sensor_iirs_t\fP"
.br
.ti -1c
.RI "typedef enum mlx90614_sensor_test_repeat_states_e \fBmlx90614_sensor_test_repeat_states_t\fP"
.br
.ti -1c
.RI "typedef enum mlx90614_temperature_sensors_e \fBmlx90614_temperature_sensors_t\fP"
.br
.ti -1c
.RI "typedef enum mlx90614_sensor_ir_types_e \fBmlx90614_sensor_ir_types_t\fP"
.br
.ti -1c
.RI "typedef enum mlx90614_k_signs_e \fBmlx90614_k_signs_t\fP"
.br
.ti -1c
.RI "typedef enum mlx90614_fir_values_e \fBmlx90614_fir_values_t\fP"
.br
.ti -1c
.RI "typedef enum ml90614_gains_e \fBml90614_gains_t\fP"
.br
.ti -1c
.RI "typedef enum mlx90614_nk2_signs_e \fBmlx90614_nk2_signs_t\fP"
.br
.ti -1c
.RI "typedef enum mlx90614_sensor_test_states_e \fBmlx90614_sensor_test_states_t\fP"
.br
.ti -1c
.RI "typedef enum mlx90614_pwm_modes_e \fBmlx90614_pwm_modes_t\fP"
.br
.ti -1c
.RI "typedef enum mlx90614_pwm_mode_states_e \fBmlx90614_pwm_mode_states_t\fP"
.br
.ti -1c
.RI "typedef enum mlx90614_sda_pin_modes_e \fBmlx90614_sda_pin_modes_t\fP"
.br
.ti -1c
.RI "typedef enum mlx90614_thermal_modes_e \fBmlx90614_thermal_modes_t\fP"
.br
.ti -1c
.RI "typedef struct \fBmlx90614_config_s\fP \fBmlx90614_config_t\fP"
.br
.RI "MLX90614 configuration structure\&. "
.ti -1c
.RI "typedef struct mlx90614_context_t \fBmlx90614_context_t\fP"
.br
.RI "MLX90614 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBmlx90614_context_t\fP * \fBmlx90614_handle_t\fP"
.br
.RI "MLX90614 handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBmmc56x3_measurement_times_e\fP \fBmmc56x3_measurement_times_t\fP"
.br
.RI "MMC56X3 measurement times enumerator\&. "
.ti -1c
.RI "typedef enum \fBmmc56x3_measurement_samples_e\fP \fBmmc56x3_measurement_samples_t\fP"
.br
.RI "MMC56X3 measurement samples enumerator\&. "
.ti -1c
.RI "typedef struct \fBmmc56x3_magnetic_axes_data_s\fP \fBmmc56x3_magnetic_axes_data_t\fP"
.br
.RI "MMC56X3 magnetic axes data structure\&. "
.ti -1c
.RI "typedef struct \fBmmc56x3_selftest_axes_data_s\fP \fBmmc56x3_selftest_axes_data_t\fP"
.br
.RI "MMC56X3 self-test axes data structure\&. "
.ti -1c
.RI "typedef struct \fBmmc56x3_config_s\fP \fBmmc56x3_config_t\fP"
.br
.RI "MMC56X3 configuration structure\&. "
.ti -1c
.RI "typedef struct mmc56x3_context_t \fBmmc56x3_context_t\fP"
.br
.RI "MMC56X3 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBmmc56x3_context_t\fP * \fBmmc56x3_handle_t\fP"
.br
.RI "MMC56X3 handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBmpu6050_ext_sync_settings_e\fP \fBmpu6050_ext_sync_settings_t\fP"
.br
.RI "MPU6050 external synchronization settings enumerator\&. "
.ti -1c
.RI "typedef enum \fBmpu6050_digital_low_pass_filters_e\fP \fBmpu6050_digital_low_pass_filters_t\fP"
.br
.RI "MPU6050 digital low-pass filters enumerator\&. "
.ti -1c
.RI "typedef enum \fBmpu6050_gyro_full_scale_ranges_e\fP \fBmpu6050_gyro_full_scale_ranges_t\fP"
.br
.RI "MPU6050 gyroscope full-scale ranges enumerator\&. "
.ti -1c
.RI "typedef enum \fBmpu6050_accel_full_scale_ranges_e\fP \fBmpu6050_accel_full_scale_ranges_t\fP"
.br
.RI "MPU6050 accelerometer full-scale ranges enumerator\&. "
.ti -1c
.RI "typedef enum \fBmpu6050_gyro_clock_sources_e\fP \fBmpu6050_gyro_clock_sources_t\fP"
.br
.RI "MPU6050 gyroscope clock sources enumerator\&. "
.ti -1c
.RI "typedef enum \fBmpu6050_low_power_wake_controls_e\fP \fBmpu6050_low_power_wake_controls_t\fP"
.br
.RI "MPU6050 low-power wake controls enumerator\&. "
.ti -1c
.RI "typedef enum \fBmpu6050_irq_pin_active_level_e\fP \fBmpu6050_irq_pin_active_level_t\fP"
.br
.ti -1c
.RI "typedef enum \fBmpu6050_irq_pin_mode_e\fP \fBmpu6050_irq_pin_mode_t\fP"
.br
.ti -1c
.RI "typedef enum \fBmpu6050_irq_latch_e\fP \fBmpu6050_irq_latch_t\fP"
.br
.ti -1c
.RI "typedef enum \fBmpu6050_irq_clear_e\fP \fBmpu6050_irq_clear_t\fP"
.br
.ti -1c
.RI "typedef struct \fBmpu6050_data_axes_s\fP \fBmpu6050_data_axes_t\fP"
.br
.RI "MPU6050 raw data axes structure\&. "
.ti -1c
.RI "typedef struct \fBmpu6050_gyro_data_axes_s\fP \fBmpu6050_gyro_data_axes_t\fP"
.br
.ti -1c
.RI "typedef struct \fBmpu6050_accel_data_axes_s\fP \fBmpu6050_accel_data_axes_t\fP"
.br
.ti -1c
.RI "typedef struct \fBmpu6050_attitude_s\fP \fBmpu6050_attitude_t\fP"
.br
.ti -1c
.RI "typedef struct \fBmpu6050_config_s\fP \fBmpu6050_config_t\fP"
.br
.RI "MPU6050 configuration structure definition\&. "
.ti -1c
.RI "typedef struct mpu6050_context_t \fBmpu6050_context_t\fP"
.br
.RI "MPU6050 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBmpu6050_context_t\fP * \fBmpu6050_handle_t\fP"
.br
.RI "MPU6050 handle structure definition\&. "
.ti -1c
.RI "typedef gpio_isr_t \fBmpu6050_isr_t\fP"
.br
.RI "MPU6050 interrupt service routine definition\&. "
.ti -1c
.RI "typedef enum \fBsgp4x_versions_e\fP \fBsgp4x_versions_t\fP"
.br
.RI "SGP4X versions enumerator\&. "
.ti -1c
.RI "typedef struct sgp4x_context_t \fBsgp4x_context_t\fP"
.br
.RI "SGP4X context structure definition\&. "
.ti -1c
.RI "typedef struct \fBsgp4x_context_t\fP * \fBsgp4x_handle_t\fP"
.br
.RI "SGP4X handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBsht4x_heater_modes_e\fP \fBsht4x_heater_modes_t\fP"
.br
.RI "SHT4X measurement heater modes enumerator definition\&. "
.ti -1c
.RI "typedef enum \fBsht4x_repeat_modes_e\fP \fBsht4x_repeat_modes_t\fP"
.br
.RI "SHT4X measurement repeatability modes enumerator definition\&. "
.ti -1c
.RI "typedef struct \fBsht4x_config_s\fP \fBsht4x_config_t\fP"
.br
.RI "SHT4X configuration structure definition\&. "
.ti -1c
.RI "typedef struct sht4x_context_t \fBsht4x_context_t\fP"
.br
.RI "SHT4X context structure definition\&. "
.ti -1c
.RI "typedef struct \fBsht4x_context_t\fP * \fBsht4x_handle_t\fP"
.br
.RI "SHT4X handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBssd1306_scroll_frames_e\fP \fBssd1306_scroll_frames_t\fP"
.br
.RI "SSD1306 scroll step in terms of frame frequency enumerator definition\&. "
.ti -1c
.RI "typedef enum \fBssd1306_scroll_types_e\fP \fBssd1306_scroll_types_t\fP"
.br
.RI "SSD1306 scroll types enumerator definition\&. "
.ti -1c
.RI "typedef enum \fBssd1306_panel_sizes_e\fP \fBssd1306_panel_sizes_t\fP"
.br
.RI "SSD1306 panel sizes enumerator definition\&. "
.ti -1c
.RI "typedef struct \fBssd1306_page_s\fP \fBssd1306_page_t\fP"
.br
.RI "SSD1306 page structure definition\&. "
.ti -1c
.RI "typedef struct \fBssd1306_panel_s\fP \fBssd1306_panel_t\fP"
.br
.RI "SSD1306 panel structure definition\&. "
.ti -1c
.RI "typedef struct \fBssd1306_bdf_font_s\fP \fBssd1306_bdf_font_t\fP"
.br
.RI "SSD1306 BDF font structure definition\&. "
.ti -1c
.RI "typedef struct \fBssd1306_config_s\fP \fBssd1306_config_t\fP"
.br
.RI "SSD1306 configuration structure definition\&. "
.ti -1c
.RI "typedef struct ssd1306_context_t \fBssd1306_context_t\fP"
.br
.RI "SSD1306 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBssd1306_context_t\fP * \fBssd1306_handle_t\fP"
.br
.RI "SSD1306 handle stucture definition\&. "
.ti -1c
.RI "typedef enum \fBtbi2cxxx_types_e\fP \fBtbi2cxxx_types_t\fP"
.br
.RI "TBI2CXXX types enumerators\&. "
.ti -1c
.RI "typedef struct \fBtbi2cxxx_config_s\fP \fBtbi2cxxx_config_t\fP"
.br
.RI "TBI2CXXX configuration structure\&. "
.ti -1c
.RI "typedef struct tbi2cxxx_context_t \fBtbi2cxxx_context_t\fP"
.br
.RI "TBI2CXXX context structure definition\&. "
.ti -1c
.RI "typedef struct \fBtbi2cxxx_context_t\fP * \fBtbi2cxxx_handle_t\fP"
.br
.RI "TBI2CXXX handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBtlv493d_power_modes_e\fP \fBtlv493d_power_modes_t\fP"
.br
.RI "TLV493D power modes enumerator\&. "
.ti -1c
.RI "typedef enum \fBtlv493d_channel_conversions_e\fP \fBtlv493d_channel_conversions_t\fP"
.br
.RI "TLV493D channel conversations enumerator\&. "
.ti -1c
.RI "typedef enum \fBtlv493d_i2c_addresses_e\fP \fBtlv493d_i2c_addresses_t\fP"
.br
.RI "TLV493D addresses for slaves enumerator\&. "
.ti -1c
.RI "typedef enum \fBtlv493d_low_power_periods_e\fP \fBtlv493d_low_power_periods_t\fP"
.br
.RI "TLV493D low power periods enumerator\&. "
.ti -1c
.RI "typedef struct \fBtlv493d_raw_data_s\fP \fBtlv493d_data_signal_t\fP"
.br
.ti -1c
.RI "typedef struct \fBtlv493d_data_s\fP \fBtlv493d_data_t\fP"
.br
.ti -1c
.RI "typedef struct \fBtlv493d_config_s\fP \fBtlv493d_config_t\fP"
.br
.RI "TLV493D configuration structure\&. "
.ti -1c
.RI "typedef struct tlv493d_context_t \fBtlv493d_context_t\fP"
.br
.RI "TLV493D context structure definition\&. "
.ti -1c
.RI "typedef struct \fBtlv493d_context_t\fP * \fBtlv493d_handle_t\fP"
.br
.RI "TLV493D handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBveml6040_integration_times_e\fP \fBveml6040_integration_times_t\fP"
.br
.RI "VEML6040 integration times enumerator\&. "
.ti -1c
.RI "typedef enum \fBveml6040_triggers_e\fP \fBveml6040_triggers_t\fP"
.br
.RI "VEML6040 triggers enumerator\&. "
.ti -1c
.RI "typedef enum \fBveml6040_modes_e\fP \fBveml6040_modes_t\fP"
.br
.RI "VEML6040 modes enumerator\&. "
.ti -1c
.RI "typedef struct \fBveml6040_config_s\fP \fBveml6040_config_t\fP"
.br
.RI "VEML6040 configuration structure\&. "
.ti -1c
.RI "typedef struct veml6040_context_t \fBveml6040_context_t\fP"
.br
.RI "VEML6040 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBveml6040_context_t\fP * \fBveml6040_handle_t\fP"
.br
.RI "VEML6040 handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBveml7700_gains_e\fP \fBveml7700_gains_t\fP"
.br
.RI "VEML7700 gains enumerator\&. "
.ti -1c
.RI "typedef enum \fBveml7700_integration_times_e\fP \fBveml7700_integration_times_t\fP"
.br
.RI "VEML7700 integration times enumerator\&. "
.ti -1c
.RI "typedef enum \fBveml7700_persistence_protections_e\fP \fBveml7700_persistence_protections_t\fP"
.br
.RI "VEML7700 persistence protections enumerator\&. "
.ti -1c
.RI "typedef enum \fBveml7700_power_saving_modes_e\fP \fBveml7700_power_saving_modes_t\fP"
.br
.RI "VEML7700 power saving modes enumerator\&. "
.ti -1c
.RI "typedef struct \fBveml7700_config_s\fP \fBveml7700_config_t\fP"
.br
.RI "VEML7700 device configuration structure\&. "
.ti -1c
.RI "typedef struct veml7700_context_t \fBveml7700_context_t\fP"
.br
.RI "VEML7700 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBveml7700_context_t\fP * \fBveml7700_handle_t\fP"
.br
.RI "VEML7700 handle structure definition\&. "
.ti -1c
.RI "typedef enum \fBds18b20_resolutions_e\fP \fBds18b20_resolutions_t\fP"
.br
.RI "DS18B20 supported resolutions enumerator\&. "
.ti -1c
.RI "typedef struct \fBds18b20_config_s\fP \fBds18b20_config_t\fP"
.br
.RI "DS18B20 device configuration structure\&. "
.ti -1c
.RI "typedef struct ds18b20_context_t \fBds18b20_context_t\fP"
.br
.RI "DS18B20 context structure definition\&. "
.ti -1c
.RI "typedef struct \fBds18b20_context_t\fP * \fBds18b20_handle_t\fP"
.br
.RI "DS18B20 handle structure definition\&. "
.ti -1c
.RI "typedef struct spi_max31865_t \fBspi_max31865_t\fP"
.br
.RI "MAX31865 SPI device structure definitions\&. "
.ti -1c
.RI "typedef struct \fBspi_max31865_t\fP * \fBspi_max31865_handle_t\fP"
.br
.RI "MAX31865 SPI device handle structure\&. "
.ti -1c
.RI "typedef enum \fBdatatable_event_types_tag\fP \fBdatatable_event_types_t\fP"
.br
.RI "Data-table event types enumerator\&. "
.ti -1c
.RI "typedef enum \fBdatatable_data_storage_types_tag\fP \fBdatatable_data_storage_types_t\fP"
.br
.RI "Data-table data storage-types enumerator\&. "
.ti -1c
.RI "typedef enum \fBdatatable_column_process_types_tag\fP \fBdatatable_column_process_types_t\fP"
.br
.RI "Data-table column statistical process-types enumerator\&. "
.ti -1c
.RI "typedef enum \fBdatatable_column_data_types_tag\fP \fBdatatable_column_data_types_t\fP"
.br
.RI "Data-table column data-types enumerator\&. "
.ti -1c
.RI "typedef struct \fBdatatable_event_tag\fP \fBdatatable_event_t\fP"
.br
.RI "Data-table event structure\&. "
.ti -1c
.RI "typedef void(* \fBdatatable_event\fP) (void *handle, \fBdatatable_event_t\fP)"
.br
.RI "Data-logger event\&. "
.ti -1c
.RI "typedef struct \fBdatatable_id_column_data_type_tag\fP \fBdatatable_id_column_data_type_t\fP"
.br
.RI "Data-table record identifier column data-type structure\&. "
.ti -1c
.RI "typedef struct \fBdatatable_ts_column_data_type_tag\fP \fBdatatable_ts_column_data_type_t\fP"
.br
.RI "Data-table record timestamp (utc) column data-type structure\&. "
.ti -1c
.RI "typedef struct \fBdatatable_vector_column_data_type_tag\fP \fBdatatable_vector_column_data_type_t\fP"
.br
.RI "Data-table vector data-type column structure\&. "
.ti -1c
.RI "typedef struct \fBdatatable_bool_column_data_type_tag\fP \fBdatatable_bool_column_data_type_t\fP"
.br
.RI "Data-table bool data-type column structure\&. "
.ti -1c
.RI "typedef struct \fBdatatable_float_column_data_type_tag\fP \fBdatatable_float_column_data_type_t\fP"
.br
.RI "Data-table float data-type column structure\&. "
.ti -1c
.RI "typedef struct \fBdatatable_fp16_column_data_type_tag\fP \fBdatatable_fp16_column_data_type_t\fP"
.br
.RI "Data-table float 16-bit data-type column structure\&. "
.ti -1c
.RI "typedef struct \fBdatatable_int16_column_data_type_tag\fP \fBdatatable_int16_column_data_type_t\fP"
.br
.RI "Data-table int16 data-type column structure\&. "
.ti -1c
.RI "typedef struct \fBdatatable_column_name_tag\fP \fBdatatable_column_name_t\fP"
.br
.RI "Data-table column name structure\&. "
.ti -1c
.RI "typedef struct \fBdatatable_column_tag\fP \fBdatatable_column_t\fP"
.br
.RI "Data-table column structure\&. The data-table record identifier and timestamp columns are created by default when the data-table is created\&. The record identifier and record timestamp data-types are excluded from data processing\&. "
.ti -1c
.RI "typedef struct \fBdatatable_process_tag\fP \fBdatatable_process_t\fP"
.br
.RI "Data-table process structure\&. "
.ti -1c
.RI "typedef union \fBdatatable_buffer_tag\fP \fBdatatable_buffer_t\fP"
.br
.RI "Data-table buffer union structure\&. "
.ti -1c
.RI "typedef union \fBdatatable_row_data_column_tag\fP \fBdatatable_row_data_column_t\fP"
.br
.RI "Data-table row data column structure\&. This structure is a data model that represents data storage of the record based on the data-table's column column data-type\&. "
.ti -1c
.RI "typedef struct \fBdatatable_row_tag\fP \fBdatatable_row_t\fP"
.br
.RI "Data-table row structure\&. This structure is a data model that represents data storage of record by data-table row and configured data-table columns\&. "
.ti -1c
.RI "typedef struct \fBdatatable_config_tag\fP \fBdatatable_config_t\fP"
.br
.RI "Data-table configuration structure definition\&. "
.ti -1c
.RI "typedef struct datatable_t \fBdatatable_t\fP"
.br
.RI "Data-table structure\&. "
.ti -1c
.RI "typedef struct \fBdatatable_t\fP * \fBdatatable_handle_t\fP"
.br
.RI "Data-table handle structure\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBahtxx_sensor_types_e\fP { \fBAHTXX_AHT10\fP, \fBAHTXX_AHT20\fP, \fBAHTXX_AHT21\fP, \fBAHTXX_AHT25\fP, \fBAHTXX_AHT30\fP }"
.br
.RI "AHTXX sensor types enumerator definition\&. "
.ti -1c
.RI "enum \fBak8975_operating_modes_e\fP { \fBAK8975_OPMODE_POWER_DOWN\fP = (0b0000), \fBAK8975_OPMODE_SINGLE_MEAS\fP = (0b0001), \fBAK8975_OPMODE_SELF_TEST\fP = (0b1000), \fBAK8975_OPMODE_FUSE_ROM\fP = (0b1111) }"
.br
.RI "AK8975 operating modes enumerator\&. "
.ti -1c
.RI "enum \fBas3935_analog_frontends_e\fP { \fBAS3935_AFE_INDOOR\fP = (0b10010), \fBAS3935_AFE_OUTDOOR\fP = (0b01110) }"
.br
.RI "AS3935 enumerator and structure declarations\&. "
.ti -1c
.RI "enum \fBas3935_power_states_e\fP { \fBAS3935_POWER_OFF\fP = 1, \fBAS3935_POWER_ON\fP = 0 }"
.br
.RI "AS3935 power states REG0x00[0] enumerator\&. "
.ti -1c
.RI "enum \fBas3935_clear_statistics_states_e\fP { \fBAS3935_CLEAR_STATS_DISABLED\fP = 1, \fBAS3935_CLEAR_STATS_ENABLED\fP = 0 }"
.br
.RI "AS3935 clear statistics states REG0x02[6] enumerator\&. "
.ti -1c
.RI "enum \fBas3935_disturber_detection_states_e\fP { \fBAS3935_DISTURBER_DETECTION_ENABLED\fP = 0, \fBAS3935_DISTURBER_DETECTION_DISABLED\fP = 1 }"
.br
.RI "AS3935 disturber detection states REG0x03[5] enumerator\&. "
.ti -1c
.RI "enum \fBas3935_co_irq_pin_states_e\fP { \fBAS3935_CO_IRQ_PIN_ENABLED\fP = 1, \fBAS3935_CO_IRQ_PIN_DISABLED\fP = 0 }"
.br
.RI "AS3935 CO IRQ pin states REG0x08[5]|[6]|[7] enumerator\&. "
.ti -1c
.RI "enum \fBas3935_watchdog_thresholds_e\fP { \fBAS3935_WD_THRESHOLD_0\fP = (0b0000), \fBAS3935_WD_THRESHOLD_1\fP = (0b0001), \fBAS3935_WD_THRESHOLD_2\fP = (0b0010), \fBAS3935_WD_THRESHOLD_3\fP = (0b0011), \fBAS3935_WD_THRESHOLD_4\fP = (0b0100), \fBAS3935_WD_THRESHOLD_5\fP = (0b0101), \fBAS3935_WD_THRESHOLD_6\fP = (0b0110), \fBAS3935_WD_THRESHOLD_7\fP = (0b0111), \fBAS3935_WD_THRESHOLD_8\fP = (0b1000), \fBAS3935_WD_THRESHOLD_9\fP = (0b1001), \fBAS3935_WD_THRESHOLD_10\fP = (0b1010) }"
.br
.RI "AS3935 watchdog thresholds REG0x01[3:0] enumerator\&. "
.ti -1c
.RI "enum \fBas3935_noise_levels_e\fP { \fBAS3935_NOISE_LEVEL_390_28\fP = (0b000), \fBAS3935_NOISE_LEVEL_630_45\fP = (0b001), \fBAS3935_NOISE_LEVEL_860_62\fP = (0b010), \fBAS3935_NOISE_LEVEL_1100_78\fP = (0b011), \fBAS3935_NOISE_LEVEL_1140_95\fP = (0b100), \fBAS3935_NOISE_LEVEL_1570_112\fP = (0b101), \fBAS3935_NOISE_LEVEL_1800_130\fP = (0b110), \fBAS3935_NOISE_LEVEL_2000_146\fP = (0b111) }"
.br
.RI "AS3935 noise floor generator and evaluation REG0x01[6:4] enumerator\&. "
.ti -1c
.RI "enum \fBas3935_interrupt_states_e\fP { \fBAS3935_INT_NOISE\fP = (0b0001), \fBAS3935_INT_DISTURBER\fP = (0b0100), \fBAS3935_INT_LIGHTNING\fP = (0b1000), \fBAS3935_INT_NONE\fP = (0b0000) }"
.br
.RI "AS3935 interrupt states REG0x03[3:0] enumerator\&. "
.ti -1c
.RI "enum \fBas3935_minimum_lightnings_e\fP { \fBAS3935_MIN_LIGHTNING_1\fP = (0b00), \fBAS3935_MIN_LIGHTNING_5\fP = (0b01), \fBAS3935_MIN_LIGHTNING_9\fP = (0b10), \fBAS3935_MIN_LIGHTNING_16\fP = (0b11) }"
.br
.RI "AS3935 minimum number of lightning detections REG0x02[5:4] enumerator\&. "
.ti -1c
.RI "enum \fBas3935_frequency_division_ratios_e\fP { \fBAS3935_FREQ_DIV_RATIO_16\fP = (0b00), \fBAS3935_FREQ_DIV_RATIO_32\fP = (0b01), \fBAS3935_FREQ_DIV_RATIO_64\fP = (0b10), \fBAS3935_FREQ_DIV_RATIO_128\fP = (0b11) }"
.br
.RI "AS3935 frequency division ratio for antenna tunning REG0x03[7:3] LCO_FDIV enumerator\&. "
.ti -1c
.RI "enum \fBas3935_lightning_distances_e\fP { \fBAS3935_L_DISTANCE_OVERHEAD\fP = (0b000001), \fBAS3935_L_DISTANCE_5KM\fP = (0b000101), \fBAS3935_L_DISTANCE_6KM\fP = (0b000110), \fBAS3935_L_DISTANCE_8KM\fP = (0b001000), \fBAS3935_L_DISTANCE_10KM\fP = (0b001010), \fBAS3935_L_DISTANCE_12KM\fP = (0b001100), \fBAS3935_L_DISTANCE_14KM\fP = (0b001110), \fBAS3935_L_DISTANCE_17KM\fP = (0b010001), \fBAS3935_L_DISTANCE_20KM\fP = (0b010100), \fBAS3935_L_DISTANCE_24KM\fP = (0b011000), \fBAS3935_L_DISTANCE_27KM\fP = (0b011011), \fBAS3935_L_DISTANCE_31KM\fP = (0b011111), \fBAS3935_L_DISTANCE_34KM\fP = (0b100010), \fBAS3935_L_DISTANCE_37KM\fP = (0b100101), \fBAS3935_L_DISTANCE_40KM\fP = (0b101000), \fBAS3935_L_DISTANCE_OO_RANGE\fP = (0b111111) }"
.br
.RI "AS3935 lightning estimated distances REG0x07[5:0] enumerator\&. "
.ti -1c
.RI "enum \fBas3935_rco_calibration_results_e\fP { \fBAS3935_RCO_CALIBRATION_SUCCESSFUL\fP, \fBAS3935_RCO_CALIBRATION_UNSUCCESSFUL\fP, \fBAS3935_RCO_CALIBRATION_INCOMPLETE\fP }"
.br
.RI "AS3935 oscillator calibration status results enumerator\&. "
.ti -1c
.RI "enum \fBas3935_oscillator_modes_e\fP { \fBAS3935_OSCILLATOR_ANTENNA_LC\fP, \fBAS3935_OSCILLATOR_TIMER_RC\fP, \fBAS3935_OSCILLATOR_SYSTEM_RC\fP }"
.br
.RI "AS3935 tuning mode oscillators enumerator\&. "
.ti -1c
.RI "enum \fBas7341_als_modes_e\fP { \fBAS7341_ALS_SPM_MODE\fP = (0), \fBAS7341_ALS_SYNS_MODE\fP = (1), \fBAS7341_ALS_RESERVED_MODE\fP = (2), \fBAS7341_ALS_SYND_MODE\fP = (3) }"
.br
.RI "AS7341 ambient light sensing mode enumerator\&. "
.ti -1c
.RI "enum \fBas7341_led_drive_strengths_e\fP { \fBAS7341_LED_DRIVE_STRENGTH_4MA\fP = (0b0000000), \fBAS7341_LED_DRIVE_STRENGTH_6MA\fP = (0b0000001), \fBAS7341_LED_DRIVE_STRENGTH_8MA\fP = (0b0000010), \fBAS7341_LED_DRIVE_STRENGTH_10MA\fP = (0b0000011), \fBAS7341_LED_DRIVE_STRENGTH_12MA\fP = (0b0000100), \fBAS7341_LED_DRIVE_STRENGTH_256MA\fP = (0b1111110), \fBAS7341_LED_DRIVE_STRENGTH_258MA\fP = (0b1111111) }"
.br
.RI "AS7341 led driving strengths enumerator\&. "
.ti -1c
.RI "enum \fBas7341_spectral_gains_e\fP { \fBAS7341_SPECTRAL_GAIN_0_5X\fP = 0, \fBAS7341_SPECTRAL_GAIN_1X\fP, \fBAS7341_SPECTRAL_GAIN_2X\fP, \fBAS7341_SPECTRAL_GAIN_4X\fP, \fBAS7341_SPECTRAL_GAIN_8X\fP, \fBAS7341_SPECTRAL_GAIN_16X\fP, \fBAS7341_SPECTRAL_GAIN_32X\fP, \fBAS7341_SPECTRAL_GAIN_64X\fP, \fBAS7341_SPECTRAL_GAIN_128X\fP, \fBAS7341_SPECTRAL_GAIN_256X\fP, \fBAS7341_SPECTRAL_GAIN_512X\fP }"
.br
.RI "AS7341 allowable gain multipliers enumerator\&. "
.ti -1c
.RI "enum \fBas7341_flicker_detection_gains_e\fP { \fBAS7341_FLICKER_DETECTION_GAIN_0_5X\fP = 0, \fBAS7341_FLICKER_DETECTION_GAIN_1X\fP, \fBAS7341_FLICKER_DETECTION_GAIN_2X\fP, \fBAS7341_FLICKER_DETECTION_GAIN_4X\fP, \fBAS7341_FLICKER_DETECTION_GAIN_8X\fP, \fBAS7341_FLICKER_DETECTION_GAIN_16X\fP, \fBAS7341_FLICKER_DETECTION_GAIN_32X\fP, \fBAS7341_FLICKER_DETECTION_GAIN_64X\fP, \fBAS7341_FLICKER_DETECTION_GAIN_128X\fP, \fBAS7341_FLICKER_DETECTION_GAIN_256X\fP, \fBAS7341_FLICKER_DETECTION_GAIN_512X\fP }"
.br
.RI "AS7341 allowable flicker detection gain multipliers enumerator\&. "
.ti -1c
.RI "enum \fBas7341_flicker_detection_states_e\fP { \fBAS7341_FLICKER_DETECTION_INVALID\fP = 0, \fBAS7341_FLICKER_DETECTION_UNKNOWN\fP, \fBAS7341_FLICKER_DETECTION_SATURATED\fP, \fBAS7341_FLICKER_DETECTION_100HZ\fP, \fBAS7341_FLICKER_DETECTION_120HZ\fP }"
.br
.RI "AS7341 flicker detection states enumerator\&. "
.ti -1c
.RI "enum \fBas7341_smux_commands_e\fP { \fBAS7341_SMUX_CMD_ROM_RESET\fP = 0, \fBAS7341_SMUX_CMD_READ\fP, \fBAS7341_SMUX_CMD_WRITE\fP }"
.br
.RI "AS7341 available SMUX commands enumerator\&. "
.ti -1c
.RI "enum \fBbh1750_measurement_modes_e\fP { \fBBH1750_MODE_OM_HI_RESOLUTION\fP = (0b00100000), \fBBH1750_MODE_OM_HI2_RESOLUTION\fP = (0b00100001), \fBBH1750_MODE_OM_LO_RESOLUTION\fP = (0b00100011), \fBBH1750_MODE_CM_HI_RESOLUTION\fP = (0b00010000), \fBBH1750_MODE_CM_HI2_RESOLUTION\fP = (0b00010001), \fBBH1750_MODE_CM_LO_RESOLUTION\fP = (0b00010011) }"
.br
.RI "BH1750 measurement modes enumerator\&. "
.ti -1c
.RI "enum \fBbme680_heater_setpoints_e\fP { \fBBME680_HEATER_SETPOINT_0\fP = (0b0000), \fBBME680_HEATER_SETPOINT_1\fP = (0b0001), \fBBME680_HEATER_SETPOINT_2\fP = (0b0010), \fBBME680_HEATER_SETPOINT_3\fP = (0b0011), \fBBME680_HEATER_SETPOINT_4\fP = (0b0100), \fBBME680_HEATER_SETPOINT_5\fP = (0b0101), \fBBME680_HEATER_SETPOINT_6\fP = (0b0110), \fBBME680_HEATER_SETPOINT_7\fP = (0b0111), \fBBME680_HEATER_SETPOINT_8\fP = (0b1000), \fBBME680_HEATER_SETPOINT_9\fP = (0b1001) }"
.br
.RI "BME680 heater set-points enumerator\&. "
.ti -1c
.RI "enum \fBbme680_gas_wait_multipliers_e\fP { \fBBME680_GAS_WAIT_MULT_1\fP = (0b00), \fBBME680_GAS_WAIT_MULT_4\fP = (0b01), \fBBME680_GAS_WAIT_MULT_16\fP = (0b10), \fBBME680_GAS_WAIT_MULT_64\fP = (0b11) }"
.br
.RI "BME680 gas wait multipliers enumerator\&. "
.ti -1c
.RI "enum \fBbme680_iir_filters_e\fP { \fBBME680_IIR_FILTER_OFF\fP = (0b000), \fBBME680_IIR_FILTER_1\fP = (0b001), \fBBME680_IIR_FILTER_3\fP = (0b010), \fBBME680_IIR_FILTER_7\fP = (0b011), \fBBME680_IIR_FILTER_15\fP = (0b100), \fBBME680_IIR_FILTER_31\fP = (0b101), \fBBME680_IIR_FILTER_63\fP = (0b110), \fBBME680_IIR_FILTER_127\fP = (0b111) }"
.br
.RI "BME680 IIR filters coefficient enumerator\&. "
.ti -1c
.RI "enum \fBbme680_power_modes_e\fP { \fBBME680_POWER_MODE_SLEEP\fP = (0b00), \fBBME680_POWER_MODE_FORCED\fP = (0b01), \fBBME680_POWER_MODE_PARALLEL\fP = (0b10), \fBBME680_POWER_MODE_SEQUENTIAL\fP = (0b11) }"
.br
.RI "BME680 power modes enumerator\&. "
.ti -1c
.RI "enum \fBbme680_pressure_oversampling_e\fP { \fBBME680_PRESSURE_OVERSAMPLING_SKIPPED\fP = (0b000), \fBBME680_PRESSURE_OVERSAMPLING_1X\fP = (0b001), \fBBME680_PRESSURE_OVERSAMPLING_2X\fP = (0b010), \fBBME680_PRESSURE_OVERSAMPLING_4X\fP = (0b011), \fBBME680_PRESSURE_OVERSAMPLING_8X\fP = (0b100), \fBBME680_PRESSURE_OVERSAMPLING_16X\fP = (0b101) }"
.br
.RI "BME680 pressure oversampling enumerator\&. "
.ti -1c
.RI "enum \fBbme680_temperature_oversampling_e\fP { \fBBME680_TEMPERATURE_OVERSAMPLING_SKIPPED\fP = (0b000), \fBBME680_TEMPERATURE_OVERSAMPLING_1X\fP = (0b001), \fBBME680_TEMPERATURE_OVERSAMPLING_2X\fP = (0b010), \fBBME680_TEMPERATURE_OVERSAMPLING_4X\fP = (0b011), \fBBME680_TEMPERATURE_OVERSAMPLING_8X\fP = (0b100), \fBBME680_TEMPERATURE_OVERSAMPLING_16X\fP = (0b101) }"
.br
.RI "BME680 temperature oversampling enumerator\&. "
.ti -1c
.RI "enum \fBbme680_humidity_oversampling_e\fP { \fBBME680_HUMIDITY_OVERSAMPLING_SKIPPED\fP = (0b000), \fBBME680_HUMIDITY_OVERSAMPLING_1X\fP = (0b001), \fBBME680_HUMIDITY_OVERSAMPLING_2X\fP = (0b010), \fBBME680_HUMIDITY_OVERSAMPLING_4X\fP = (0b011), \fBBME680_HUMIDITY_OVERSAMPLING_8X\fP = (0b100), \fBBME680_HUMIDITY_OVERSAMPLING_16X\fP = (0b101) }"
.br
.RI "BME680 humidity oversampling enumerator\&. "
.ti -1c
.RI "enum \fBbmp280_iir_filters_e\fP { \fBBMP280_IIR_FILTER_OFF\fP = (0b000), \fBBMP280_IIR_FILTER_2\fP = (0b001), \fBBMP280_IIR_FILTER_4\fP = (0b010), \fBBMP280_IIR_FILTER_8\fP = (0b011), \fBBMP280_IIR_FILTER_16\fP = (0b100) }"
.br
.RI "BMP280 IIR filters coefficient enumerator definition\&. "
.ti -1c
.RI "enum \fBbmp280_standby_times_e\fP { \fBBMP280_STANDBY_TIME_0_5MS\fP = (0b000), \fBBMP280_STANDBY_TIME_62_5MS\fP = (0b001), \fBBMP280_STANDBY_TIME_125MS\fP = (0b010), \fBBMP280_STANDBY_TIME_250MS\fP = (0b011), \fBBMP280_STANDBY_TIME_500MS\fP = (0b100), \fBBMP280_STANDBY_TIME_1000MS\fP = (0b101), \fBBMP280_STANDBY_TIME_2000MS\fP = (0b110), \fBBMP280_STANDBY_TIME_4000MS\fP = (0b111) }"
.br
.RI "BMP280 stand-by times enumerator definition\&. "
.ti -1c
.RI "enum \fBbmp280_power_modes_e\fP { \fBBMP280_POWER_MODE_SLEEP\fP = (0b00), \fBBMP280_POWER_MODE_FORCED\fP = (0b01), \fBBMP280_POWER_MODE_FORCED1\fP = (0b10), \fBBMP280_POWER_MODE_NORMAL\fP = (0b11) }"
.br
.RI "BMP280 power modes enumerator definition\&. "
.ti -1c
.RI "enum \fBbmp280_pressure_oversampling_e\fP { \fBBMP280_PRESSURE_OVERSAMPLING_SKIPPED\fP = (0b000), \fBBMP280_PRESSURE_OVERSAMPLING_1X\fP = (0b001), \fBBMP280_PRESSURE_OVERSAMPLING_2X\fP = (0b010), \fBBMP280_PRESSURE_OVERSAMPLING_4X\fP = (0b011), \fBBMP280_PRESSURE_OVERSAMPLING_8X\fP = (0b100), \fBBMP280_PRESSURE_OVERSAMPLING_16X\fP = (0b101) }"
.br
.RI "BMP280 pressure oversampling enumerator definition\&. "
.ti -1c
.RI "enum \fBbmp280_temperature_oversampling_e\fP { \fBBMP280_TEMPERATURE_OVERSAMPLING_SKIPPED\fP = (0b000), \fBBMP280_TEMPERATURE_OVERSAMPLING_1X\fP = (0b001), \fBBMP280_TEMPERATURE_OVERSAMPLING_2X\fP = (0b010), \fBBMP280_TEMPERATURE_OVERSAMPLING_4X\fP = (0b011), \fBBMP280_TEMPERATURE_OVERSAMPLING_8X\fP = (0b100), \fBBMP280_TEMPERATURE_OVERSAMPLING_16X\fP = (0b101), \fBBMP280_TEMPERATURE_OVERSAMPLING_16X1\fP = (0b110), \fBBMP280_TEMPERATURE_OVERSAMPLING_16X2\fP = (0b111) }"
.br
.RI "BMP280 temperature oversampling enumerator definition\&. "
.ti -1c
.RI "enum \fBbmp390_iir_filters_e\fP { \fBBMP390_IIR_FILTER_OFF\fP = (0b000), \fBBMP390_IIR_FILTER_1\fP = (0b001), \fBBMP390_IIR_FILTER_3\fP = (0b010), \fBBMP390_IIR_FILTER_7\fP = (0b011), \fBBMP390_IIR_FILTER_15\fP = (0b100), \fBBMP390_IIR_FILTER_31\fP = (0b101), \fBBMP390_IIR_FILTER_63\fP = (0b110), \fBBMP390_IIR_FILTER_127\fP = (0b111) }"
.br
.RI "BMP390 IIR filters coefficient enumerator\&. "
.ti -1c
.RI "enum \fBbmp390_output_data_rates_e\fP { \fBBMP390_ODR_5MS\fP = (0x00), \fBBMP390_ODR_10MS\fP = (0x01), \fBBMP390_ODR_20MS\fP = (0x02), \fBBMP390_ODR_40MS\fP = (0x03), \fBBMP390_ODR_80MS\fP = (0x04), \fBBMP390_ODR_160MS\fP = (0x05), \fBBMP390_ODR_320MS\fP = (0x06), \fBBMP390_ODR_640MS\fP = (0x07) }"
.br
.RI "BMP390 output data rates enumerator\&. "
.ti -1c
.RI "enum \fBbmp390_power_modes_e\fP { \fBBMP390_POWER_MODE_SLEEP\fP = (0b00), \fBBMP390_POWER_MODE_FORCED\fP = (0b01), \fBBMP390_POWER_MODE_FORCED1\fP = (0b10), \fBBMP390_POWER_MODE_NORMAL\fP = (0b11) }"
.br
.RI "BMP390 power modes enumerator\&. "
.ti -1c
.RI "enum \fBbmp390_pressure_oversampling_e\fP { \fBBMP390_PRESSURE_OVERSAMPLING_SKIPPED\fP = (0b000), \fBBMP390_PRESSURE_OVERSAMPLING_2X\fP = (0b001), \fBBMP390_PRESSURE_OVERSAMPLING_4X\fP = (0b010), \fBBMP390_PRESSURE_OVERSAMPLING_8X\fP = (0b011), \fBBMP390_PRESSURE_OVERSAMPLING_16X\fP = (0b100), \fBBMP390_PRESSURE_OVERSAMPLING_32X\fP = (0b101) }"
.br
.RI "BMP390 pressure oversampling enumerator\&. "
.ti -1c
.RI "enum \fBbmp390_temperature_oversampling_e\fP { \fBBMP390_TEMPERATURE_OVERSAMPLING_SKIPPED\fP = (0b000), \fBBMP390_TEMPERATURE_OVERSAMPLING_2X\fP = (0b001), \fBBMP390_TEMPERATURE_OVERSAMPLING_4X\fP = (0b010), \fBBMP390_TEMPERATURE_OVERSAMPLING_8X\fP = (0b011), \fBBMP390_TEMPERATURE_OVERSAMPLING_16X\fP = (0b100), \fBBMP390_TEMPERATURE_OVERSAMPLING_32X\fP = (0b101) }"
.br
.RI "BMP390 temperature oversampling enumerator\&. "
.ti -1c
.RI "enum \fBccs811_drive_modes_e\fP { \fBCCS811_DRIVE_MODE_IDLE\fP = (0b000), \fBCCS811_DRIVE_MODE_CONSTANT_POWER_IAQ\fP = (0b001), \fBCCS811_DRIVE_MODE_PULSE_HEATING_IAQ\fP = (0b010), \fBCCS811_DRIVE_MODE_LP_PULSE_HEATING_IAQ\fP = (0b011), \fBCCS811_DRIVE_MODE_CONSTANT_POWER\fP = (0b100) }"
.br
.ti -1c
.RI "enum \fBccs811_firmware_modes_e\fP { \fBCCS811_FW_MODE_BOOT\fP = 0, \fBCCS811_FW_MODE_APP\fP = 1 }"
.br
.ti -1c
.RI "enum \fBens160_aqi_uba_indexes_e\fP { \fBENS160_AQI_UBA_INDEX_UNKNOWN\fP = 0, \fBENS160_AQI_UBA_INDEX_1\fP = 1, \fBENS160_AQI_UBA_INDEX_2\fP = 2, \fBENS160_AQI_UBA_INDEX_3\fP = 3, \fBENS160_AQI_UBA_INDEX_4\fP = 4, \fBENS160_AQI_UBA_INDEX_5\fP = 5 }"
.br
.RI "ENS160 air quality index of the uba enumerator\&. "
.ti -1c
.RI "enum \fBens160_interrupt_pin_polarities_e\fP { \fBENS160_INT_PIN_POLARITY_ACTIVE_LO\fP = 0, \fBENS160_INT_PIN_POLARITY_ACTIVE_HI\fP = 1 }"
.br
.RI "ENS160 interrupt pin polarities enumerator\&. "
.ti -1c
.RI "enum \fBens160_interrupt_pin_drivers_e\fP { \fBENS160_INT_PIN_DRIVE_OPEN_DRAIN\fP = 0, \fBENS160_INT_PIN_DRIVE_PUSH_PULL\fP = 1 }"
.br
.RI "ENS160 interrupt pin drivers enumerator\&. "
.ti -1c
.RI "enum \fBens160_operating_modes_e\fP { \fBENS160_OPMODE_DEEP_SLEEP\fP = 0x00, \fBENS160_OPMODE_IDLE\fP = 0x01, \fBENS160_OPMODE_STANDARD\fP = 0x02, \fBENS160_OPMODE_RESET\fP = 0xf0 }"
.br
.RI "ENS160 operating modes enumerator\&. "
.ti -1c
.RI "enum \fBens160_commands_e\fP { \fBENS160_CMD_NORMAL\fP = 0x00, \fBENS160_CMD_GET_FW_APPVER\fP = 0x0e, \fBENS160_CMD_CLEAR_GPR\fP = 0xcc }"
.br
.RI "ENS160 commands enumerator\&. "
.ti -1c
.RI "enum \fBens160_validity_flags_e\fP { \fBENS160_VALFLAG_NORMAL\fP = 0x00, \fBENS160_VALFLAG_WARMUP\fP = 0x01, \fBENS160_VALFLAG_INITIAL_STARTUP\fP = 0x02, \fBENS160_VALFLAG_INVALID_OUTPUT\fP = 0x03 }"
.br
.RI "ENS160 validity flags enumerator\&. "
.ti -1c
.RI "enum \fBhdc1080_acquisition_modes_e\fP { \fBHDC1080_ACQUISITION_SINGLE\fP = 0, \fBHDC1080_ACQUISITION_SEQUENCED\fP = 1 }"
.br
.RI "HDC1080 acquisition modes enumerator definition\&. "
.ti -1c
.RI "enum \fBhdc1080_battery_states_e\fP { \fBHDC1080_BATT_VOLT_OVER_2_8V\fP = 0, \fBHDC1080_BATT_VOLT_UNDER_2_8V\fP = 1 }"
.br
.RI "HDC1080 battery states enumerator definition\&. "
.ti -1c
.RI "enum \fBhdc1080_temperature_resolutions_e\fP { \fBHDC1080_TEMPERATURE_RESOLUTION_14BIT\fP = 0, \fBHDC1080_TEMPERATURE_RESOLUTION_11BIT\fP = 1 }"
.br
.RI "HDC1080 temperature measurement resolutions enumerator definition\&. "
.ti -1c
.RI "enum \fBhdc1080_humidity_resolutions_e\fP { \fBHDC1080_HUMIDITY_RESOLUTION_14BIT\fP = (0b00), \fBHDC1080_HUMIDITY_RESOLUTION_11BIT\fP = (0b01), \fBHDC1080_HUMIDITY_RESOLUTION_8BIT\fP = (0b10) }"
.br
.RI "HDC1080 humidity measurement resolutions enumerator definition\&. "
.ti -1c
.RI "enum \fBhmc5883l_calibration_options_e\fP { \fBHMC5883L_CAL_GAIN_DIFF\fP = 1, \fBHMC5883L_CAL_AXES_MEAN\fP = 2, \fBHMC5883L_CAL_BOTH\fP = 3 }"
.br
.ti -1c
.RI "enum \fBhmc5883l_modes_e\fP { \fBHMC5883L_MODE_CONTINUOUS\fP = (0b00), \fBHMC5883L_MODE_SINGLE\fP = (0b01), \fBHMC5883L_MODE_IDLE\fP = (0b10), \fBHMC5883L_MODE_IDLE2\fP = (0b11) }"
.br
.ti -1c
.RI "enum \fBhmc5883l_sample_averages_e\fP { \fBHMC5883L_SAMPLE_1\fP = (0b00), \fBHMC5883L_SAMPLE_2\fP = (0b01), \fBHMC5883L_SAMPLE_4\fP = (0b10), \fBHMC5883L_SAMPLE_8\fP = (0b11) }"
.br
.ti -1c
.RI "enum \fBhmc5883l_data_rates_e\fP { \fBHMC5883L_DATA_RATE_00_75\fP = (0b000), \fBHMC5883L_DATA_RATE_01_50\fP = (0b001), \fBHMC5883L_DATA_RATE_03_00\fP = (0b010), \fBHMC5883L_DATA_RATE_07_50\fP = (0b011), \fBHMC5883L_DATA_RATE_15_00\fP = (0b100), \fBHMC5883L_DATA_RATE_30_00\fP = (0b101), \fBHMC5883L_DATA_RATE_75_00\fP = (0b110), \fBHMC5883L_DATA_RATE_RESERVED\fP = (0b111) }"
.br
.ti -1c
.RI "enum \fBhmc5883l_biases_e\fP { \fBHMC5883L_BIAS_NORMAL\fP = (0b00), \fBHMC5883L_BIAS_POSITIVE\fP = (0b01), \fBHMC5883L_BIAS_NEGATIVE\fP = (0b10), \fBHMC5883L_BIAS_RESERVED\fP = (0b11) }"
.br
.ti -1c
.RI "enum \fBhmc5883l_gains_e\fP { \fBHMC5883L_GAIN_1370\fP = (0b000), \fBHMC5883L_GAIN_1090\fP = (0b001), \fBHMC5883L_GAIN_820\fP = (0b010), \fBHMC5883L_GAIN_660\fP = (0b011), \fBHMC5883L_GAIN_440\fP = (0b100), \fBHMC5883L_GAIN_390\fP = (0b101), \fBHMC5883L_GAIN_330\fP = (0b110), \fBHMC5883L_GAIN_230\fP = (0b111) }"
.br
.ti -1c
.RI "enum \fBina226_averaging_modes_e\fP { \fBINA226_AVG_MODE_1\fP = (0b000), \fBINA226_AVG_MODE_4\fP = (0b001), \fBINA226_AVG_MODE_16\fP = (0b010), \fBINA226_AVG_MODE_64\fP = (0b011), \fBINA226_AVG_MODE_128\fP = (0b100), \fBINA226_AVG_MODE_256\fP = (0b101), \fBINA226_AVG_MODE_512\fP = (0b110), \fBINA226_AVG_MODE_1024\fP = (0b111) }"
.br
.RI "Averaging modes enumerator for ADC resolution/averaging\&. "
.ti -1c
.RI "enum \fBina226_volt_conv_times_e\fP { \fBINA226_VOLT_CONV_TIME_140US\fP = (0b000), \fBINA226_VOLT_CONV_TIME_204US\fP = (0b001), \fBINA226_VOLT_CONV_TIME_332US\fP = (0b010), \fBINA226_VOLT_CONV_TIME_588US\fP = (0b011), \fBINA226_VOLT_CONV_TIME_1_1MS\fP = (0b100), \fBINA226_VOLT_CONV_TIME_2_116MS\fP = (0b101), \fBINA226_VOLT_CONV_TIME_4_156MS\fP = (0b110), \fBINA226_VOLT_CONV_TIME_8_244MS\fP = (0b111) }"
.br
.RI "Voltage conversion times enumerator for ADC resolution/averaging\&. "
.ti -1c
.RI "enum \fBina226_operating_modes_e\fP { \fBINA226_OP_MODE_SHUTDOWN\fP = (0b000), \fBINA226_OP_MODE_TRIG_SHUNT_VOLT\fP = (0b001), \fBINA226_OP_MODE_TRIG_BUS_VOLT\fP = (0b010), \fBINA226_OP_MODE_TRIG_SHUNT_BUS\fP = (0b011), \fBINA226_OP_MODE_SHUTDOWN2\fP = (0b100), \fBINA226_OP_MODE_CONT_SHUNT_VOLT\fP = (0b101), \fBINA226_OP_MODE_CONT_BUS_VOLT\fP = (0b110), \fBINA226_OP_MODE_CONT_SHUNT_BUS\fP = (0b111) }"
.br
.RI "Current conversion times enumerator for ADC resolution/averaging\&. "
.ti -1c
.RI "enum \fBltr390uv_operation_modes_e\fP { \fBLTR390UV_OM_ALS\fP = 0, \fBLTR390UV_OM_UVS\fP = 1 }"
.br
.RI "LTR390UV operation modes enumerator\&. "
.ti -1c
.RI "enum \fBltr390uv_sensor_resolutions_e\fP { \fBLTR390UV_SR_20BIT\fP = (0b000), \fBLTR390UV_SR_19BIT\fP = (0b001), \fBLTR390UV_SR_18BIT\fP = (0b010), \fBLTR390UV_SR_17BIT\fP = (0b011), \fBLTR390UV_SR_16BIT\fP = (0b100), \fBLTR390UV_SR_13BIT\fP = (0b101) }"
.br
.RI "LTR390UV sensor resolutions enumerator\&. "
.ti -1c
.RI "enum \fBltr390uv_measurement_rates_e\fP { \fBLTR390UV_MR_25MS\fP = (0b000), \fBLTR390UV_MR_50MS\fP = (0b001), \fBLTR390UV_MR_100MS\fP = (0b010), \fBLTR390UV_MR_200MS\fP = (0b011), \fBLTR390UV_MR_500MS\fP = (0b100), \fBLTR390UV_MR_1000MS\fP = (0b101), \fBLTR390UV_MR_2000MS\fP = (0b110), \fBLTR390UV_MR_2000_MS\fP = (0b111) }"
.br
.RI "LTR390UV measurement rates enumerator\&. "
.ti -1c
.RI "enum \fBltr390uv_measurement_gains_e\fP { \fBLTR390UV_MG_X1\fP = (0b000), \fBLTR390UV_MG_X3\fP = (0b001), \fBLTR390UV_MG_X6\fP = (0b010), \fBLTR390UV_MG_X9\fP = (0b011), \fBLTR390UV_MG_X18\fP = (0b100) }"
.br
.RI "LTR390UV measurement gains enumerator\&. "
.ti -1c
.RI "enum \fBltr390uv_ls_interrupts_e\fP { \fBLTR390UV_LSI_ALS\fP = (0b01), \fBLTR390UV_LSI_UVS\fP = (0b11) }"
.br
.RI "LTR390UV light source interrupts enumerator\&. "
.ti -1c
.RI "enum \fBmax30105_adc_range_controls_e\fP { \fBMAX30105_ARC_7_81LSB\fP = (0x00), \fBMAX30105_ARC_15_63LSB\fP = (0x01), \fBMAX30105_ARC_31_25LSB\fP = (0x02), \fBMAX30105_ARC_62_5LSB\fP = (0x03) }"
.br
.RI "MAX30105 particle-sensing ADC range controls (18-bit resolution) enumerator (register 0x0a)\&. "
.ti -1c
.RI "enum \fBmax30105_sample_rate_controls_e\fP { \fBMAX30105_SRC_50SPS\fP = (0b000), \fBMAX30105_SRC_100SPS\fP = (0b001), \fBMAX30105_SRC_200SPS\fP = (0b010), \fBMAX30105_SRC_400SPS\fP = (0b011), \fBMAX30105_SRC_800SPS\fP = (0b100), \fBMAX30105_SRC_1000SPS\fP = (0b101), \fBMAX30105_SRC_1600SPS\fP = (0b110), \fBMAX30105_SRC_3200SPS\fP = (0b111) }"
.br
.RI "MAX30105 particle-sensing sample rate control enumerator (register 0x0a)\&. "
.ti -1c
.RI "enum \fBmax30105_led_pulse_width_controls_e\fP { \fBMAX30105_LPWC_69US_15BITS\fP = (0b00), \fBMAX30105_LPWC_118US_16BITS\fP = (0b01), \fBMAX30105_LPWC_215US_17BITS\fP = (0b10), \fBMAX30105_LPWC_411US_18BITS\fP = (0b11) }"
.br
.RI "MAX30105 LED pulse width controls enumerator (register 0x0a)\&. "
.ti -1c
.RI "enum \fBmax30105_control_modes_e\fP { \fBMAX30105_CM_PARTICLE_SENSING_1LED\fP = (0b010), \fBMAX30105_CM_PARTICLE_SENSING_2LED\fP = (0b011), \fBMAX30105_CM_MULTIPLE_LED\fP = (0b111) }"
.br
.RI "MAX30105 control modes enumerator\&. "
.ti -1c
.RI "enum \fBmax30105_multi_led_control_modes_e\fP { \fBMAX30105_MLCM_DISABLED\fP = (0b000), \fBMAX30105_MLCM_RED_LED\fP = (0b001), \fBMAX30105_MLCM_IR_LED\fP = (0b010), \fBMAX30105_MLCM_GREEN_LED\fP = (0b011), \fBMAX30105_MLCM_NONE\fP = (0b100), \fBMAX30105_MLCM_RED_PILOT\fP = (0b101), \fBMAX30105_MLCM_IR_PILOT\fP = (0b110), \fBMAX30105_MLCM_GREEN_PILOT\fP = (0b111) }"
.br
.RI "MAX30105 multi-LED control modes enumerator (registers 0x11-0x12)\&. "
.ti -1c
.RI "enum \fBmax30105_led_pulse_amplitudes_e\fP { \fBMAX30105_LPA_0_0MA\fP = (0x00), \fBMAX30105_LPA_0_2MA\fP = (0x01), \fBMAX30105_LPA_0_4MA\fP = (0x02), \fBMAX30105_LPA_3_1MA\fP = (0x0f), \fBMAX30105_LPA_6_4MA\fP = (0x1f), \fBMAX30105_LPA_12_5MA\fP = (0x3f), \fBMAX30105_LPA_25_4MA\fP = (0x7f), \fBMAX30105_LPA_50_0MA\fP = (0xff) }"
.br
.RI "MAX30105 LED pulse amplitudes enumerator (registers 0x0c-0x10)\&. "
.ti -1c
.RI "enum \fBmlx90614_sensor_iirs_e\fP { \fBMLX90614_SENSOR_IIR_100\fP = (0b100), \fBMLX90614_SENSOR_IIR_80\fP = (0b101), \fBMLX90614_SENSOR_IIR_67\fP = (0b110), \fBMLX90614_SENSOR_IIR_57\fP = (0b111), \fBMLX90614_SENSOR_IIR_50\fP = (0b000), \fBMLX90614_SENSOR_IIR_25\fP = (0b001), \fBMLX90614_SENSOR_IIR_17\fP = (0b010), \fBMLX90614_SENSOR_IIR_13\fP = (0b011) }"
.br
.ti -1c
.RI "enum \fBmlx90614_sensor_test_repeat_states_e\fP { \fBMLX90614_SENSOR_TEST_REPEAT_OFF\fP = 0, \fBMLX90614_SENSOR_TEST_REPEAT_ON\fP = 1 }"
.br
.ti -1c
.RI "enum \fBmlx90614_temperature_sensors_e\fP { \fBMLX90614_TEMPERATURE_SENSOR_TA_TOBJ1\fP = (0b00), \fBMLX90614_TEMPERATURE_SENSOR_TA_TOBJ2\fP = (0b01), \fBMLX90614_TEMPERATURE_SENSOR_TOBJ2\fP = (0b10), \fBMLX90614_TEMPERATURE_SENSOR_TOBJ1_TOBJ2\fP = (0b11) }"
.br
.ti -1c
.RI "enum \fBmlx90614_sensor_ir_types_e\fP { \fBMLX90614_SENSOR_IR_TYPE_SINGLE\fP = 0, \fBMLX90614_SENSOR_IR_TYPE_DUAL\fP = 1 }"
.br
.ti -1c
.RI "enum \fBmlx90614_k_signs_e\fP { \fBMLX90614_K_SIGN_POSITIVE\fP = 0, \fBMLX90614_K_SIGN_NEGATIVE\fP = 1 }"
.br
.ti -1c
.RI "enum \fBmlx90614_fir_values_e\fP { \fBMLX90614_FIR_128\fP = (0b100), \fBMLX90614_FIR_256\fP = (0b101), \fBMLX90614_FIR_512\fP = (0b110), \fBMLX90614_FIR_1024\fP = (0b111) }"
.br
.ti -1c
.RI "enum \fBml90614_gains_e\fP { \fBMLX90614_GAIN_1\fP = (0b000), \fBMLX90614_GAIN_3\fP = (0b001), \fBMLX90614_GAIN_6\fP = (0b010), \fBMLX90614_GAIN_12_5\fP = (0b011), \fBMLX90614_GAIN_25\fP = (0b100), \fBMLX90614_GAIN_50\fP = (0b101), \fBMLX90614_GAIN_100A\fP = (0b110), \fBMLX90614_GAIN_100B\fP = (0b111) }"
.br
.ti -1c
.RI "enum \fBmlx90614_nk2_signs_e\fP { \fBMLX90614_KT2_SIGN_POSITIVE\fP = 0, \fBMLX90614_KT2_SIGN_NEGATIVE\fP = 1 }"
.br
.ti -1c
.RI "enum \fBmlx90614_sensor_test_states_e\fP { \fBMLX90614_SENSOR_TEST_ENABLED\fP = 0, \fBMLX90614_SENSOR_TEST_DISABLED\fP = 1 }"
.br
.ti -1c
.RI "enum \fBmlx90614_pwm_modes_e\fP { \fBMLX90614_PWM_MODE_EXTENDED\fP = 0, \fBMLX90614_PWM_MODE_SINGLE\fP = 1 }"
.br
.ti -1c
.RI "enum \fBmlx90614_pwm_mode_states_e\fP { \fBMLX90614_PWM_MODE_STATE_DISABLED\fP = 0, \fBMLX90614_PWM_MODE_STATE_ENABLED\fP = 1 }"
.br
.ti -1c
.RI "enum \fBmlx90614_sda_pin_modes_e\fP { \fBMLX90614_SDA_PIN_MODE_OPEN_DRAIN\fP = 0, \fBMLX90614_SDA_PIN_MODE_PUSH_PULL\fP = 1 }"
.br
.ti -1c
.RI "enum \fBmlx90614_thermal_modes_e\fP { \fBMLX90614_THERMAL_MODE_PWM\fP = 0, \fBMLX90614_THERMAL_MODE_THERMAL_RELAY\fP = 1 }"
.br
.ti -1c
.RI "enum \fBmmc56x3_measurement_times_e\fP { \fBMMC56X3_MEAS_TIME_6_6MS\fP = (0b00), \fBMMC56X3_MEAS_TIME_3_5MS\fP = (0b01), \fBMMC56X3_MEAS_TIME_2MS\fP = (0b10), \fBMMC56X3_MEAS_TIME_1_2MS\fP = (0b11) }"
.br
.RI "MMC56X3 measurement times enumerator\&. "
.ti -1c
.RI "enum \fBmmc56x3_measurement_samples_e\fP { \fBMMC56X3_MEAS_SAMPLE_1\fP = (0b000), \fBMMC56X3_MEAS_SAMPLE_25\fP = (0b001), \fBMMC56X3_MEAS_SAMPLE_75\fP = (0b010), \fBMMC56X3_MEAS_SAMPLE_100\fP = (0b011), \fBMMC56X3_MEAS_SAMPLE_250\fP = (0b100), \fBMMC56X3_MEAS_SAMPLE_500\fP = (0b101), \fBMMC56X3_MEAS_SAMPLE_1000\fP = (0b110), \fBMMC56X3_MEAS_SAMPLE_2000\fP = (0b111) }"
.br
.RI "MMC56X3 measurement samples enumerator\&. "
.ti -1c
.RI "enum \fBmpu6050_ext_sync_settings_e\fP { \fBMPU6050_EXT_SYNC_SETTING_INPUT_DISABLED\fP = (0b000), \fBMPU6050_EXT_SYNC_SETTING_TEMP_OUT_L\fP = (0b001), \fBMPU6050_EXT_SYNC_SETTING_GYRO_XOUT_L\fP = (0b010), \fBMPU6050_EXT_SYNC_SETTING_GYRO_YOUT_L\fP = (0b011), \fBMPU6050_EXT_SYNC_SETTING_GYRO_ZOUT_L\fP = (0b100), \fBMPU6050_EXT_SYNC_SETTING_ACCEL_XOUT_L\fP = (0b101), \fBMPU6050_EXT_SYNC_SETTING_ACCEL_YOUT_L\fP = (0b110), \fBMPU6050_EXT_SYNC_SETTING_ACCEL_ZOUT_L\fP = (0b111) }"
.br
.RI "MPU6050 external synchronization settings enumerator\&. "
.ti -1c
.RI "enum \fBmpu6050_digital_low_pass_filters_e\fP { \fBMPU6050_DIGITAL_LP_FILTER_ACCEL_260KHZ_GYRO_256KHZ\fP = (0b000), \fBMPU6050_DIGITAL_LP_FILTER_ACCEL_184KHZ_GYRO_188KHZ\fP = (0b001), \fBMPU6050_DIGITAL_LP_FILTER_ACCEL_94KHZ_GYRO_98KHZ\fP = (0b010), \fBMPU6050_DIGITAL_LP_FILTER_ACCEL_44KHZ_GYRO_42KHZ\fP = (0b011), \fBMPU6050_DIGITAL_LP_FILTER_ACCEL_21KHZ_GYRO_20KHZ\fP = (0b100), \fBMPU6050_DIGITAL_LP_FILTER_ACCEL_10KHZ_GYRO_10KHZ\fP = (0b101), \fBMPU6050_DIGITAL_LP_FILTER_ACCEL_5KHZ_GYRO_5KHZ\fP = (0b110), \fBMPU6050_DIGITAL_LP_FILTER_RESERVED\fP = (0b111) }"
.br
.RI "MPU6050 digital low-pass filters enumerator\&. "
.ti -1c
.RI "enum \fBmpu6050_gyro_full_scale_ranges_e\fP { \fBMPU6050_GYRO_FS_RANGE_250DPS\fP = (0b00), \fBMPU6050_GYRO_FS_RANGE_500DPS\fP = (0b01), \fBMPU6050_GYRO_FS_RANGE_1000DPS\fP = (0b10), \fBMPU6050_GYRO_FS_RANGE_2000DPS\fP = (0b11) }"
.br
.RI "MPU6050 gyroscope full-scale ranges enumerator\&. "
.ti -1c
.RI "enum \fBmpu6050_accel_full_scale_ranges_e\fP { \fBMPU6050_ACCEL_FS_RANGE_2G\fP = (0b00), \fBMPU6050_ACCEL_FS_RANGE_4G\fP = (0b01), \fBMPU6050_ACCEL_FS_RANGE_8G\fP = (0b10), \fBMPU6050_ACCEL_FS_RANGE_16G\fP = (0b11) }"
.br
.RI "MPU6050 accelerometer full-scale ranges enumerator\&. "
.ti -1c
.RI "enum \fBmpu6050_gyro_clock_sources_e\fP { \fBMPU6050_GYRO_CS_INT_8MHZ\fP = (0b000), \fBMPU6050_GYRO_CS_PLL_X_AXIS_REF\fP = (0b001), \fBMPU6050_GYRO_CS_PLL_Y_AXIS_REF\fP = (0b010), \fBMPU6050_GYRO_CS_PLL_Z_AXIS_REF\fP = (0b011), \fBMPU6050_GYRO_CS_PLL_EXT_32_768KHZ_REF\fP = (0b100), \fBMPU6050_GYRO_CS_PLL_EXT_19_2MHZ_REF\fP = (0b101), \fBMPU6050_GYRO_CS_RESERVED\fP = (0b110), \fBMPU6050_GYRO_CS_CLOCK_STOP_IN_RESET\fP = (0b111) }"
.br
.RI "MPU6050 gyroscope clock sources enumerator\&. "
.ti -1c
.RI "enum \fBmpu6050_low_power_wake_controls_e\fP { \fBMPU6050_LP_WAKE_CONTROL_1_25HZ\fP = (0b00), \fBMPU6050_LP_WAKE_CONTROL_5HZ\fP = (0b01), \fBMPU6050_LP_WAKE_CONTROL_20HZ\fP = (0b10), \fBMPU6050_LP_WAKE_CONTROL_40HZ\fP = (0b11) }"
.br
.RI "MPU6050 low-power wake controls enumerator\&. "
.ti -1c
.RI "enum \fBmpu6050_irq_pin_active_level_e\fP { \fBMPU6050_IRQ_PIN_ACTIVE_HIGH\fP = 0, \fBMPU6050_IRQ_PIN_ACTIVE_LOW\fP = 1 }"
.br
.ti -1c
.RI "enum \fBmpu6050_irq_pin_mode_e\fP { \fBMPU6050_IRQ_PIN_PUSH_PULL\fP = 0, \fBMPU6050_IRQ_PIN_OPEN_DRAIN\fP = 1 }"
.br
.ti -1c
.RI "enum \fBmpu6050_irq_latch_e\fP { \fBMPU6050_IRQ_LATCH_50US\fP = 0, \fBMPU6050_IRQ_LATCH_UNTIL_CLEARED\fP = 1 }"
.br
.ti -1c
.RI "enum \fBmpu6050_irq_clear_e\fP { \fBMPU6050_IRQ_CLEAR_ON_ANY_READ\fP = 0, \fBMPU6050_IRQ_CLEAR_ON_STATUS_READ\fP = 1 }"
.br
.ti -1c
.RI "enum \fBsgp4x_versions_e\fP { \fBSGP4X_VERSION_SGP40\fP, \fBSGP4X_VERSION_SGP41\fP }"
.br
.RI "SGP4X versions enumerator\&. "
.ti -1c
.RI "enum \fBsht4x_heater_modes_e\fP { \fBSHT4X_HEATER_OFF\fP = 0, \fBSHT4X_HEATER_HIGH_LONG\fP, \fBSHT4X_HEATER_HIGH_SHORT\fP, \fBSHT4X_HEATER_MEDIUM_LONG\fP, \fBSHT4X_HEATER_MEDIUM_SHORT\fP, \fBSHT4X_HEATER_LOW_LONG\fP, \fBSHT4X_HEATER_LOW_SHORT\fP }"
.br
.RI "SHT4X measurement heater modes enumerator definition\&. "
.ti -1c
.RI "enum \fBsht4x_repeat_modes_e\fP { \fBSHT4X_REPEAT_HIGH\fP = 0, \fBSHT4X_REPEAT_MEDIUM\fP, \fBSHT4X_REPEAT_LOW\fP }"
.br
.RI "SHT4X measurement repeatability modes enumerator definition\&. "
.ti -1c
.RI "enum \fBssd1306_scroll_frames_e\fP { \fBSSD1306_SCROLL_5_FRAMES\fP = 0b000, \fBSSD1306_SCROLL_64_FRAMES\fP = 0b001, \fBSSD1306_SCROLL_128_FRAMES\fP = 0b010, \fBSSD1306_SCROLL_256_FRAMES\fP = 0b011, \fBSSD1306_SCROLL_3_FRAMES\fP = 0b100, \fBSSD1306_SCROLL_4_FRAMES\fP = 0b101, \fBSSD1306_SCROLL_25_FRAMES\fP = 0b110, \fBSSD1306_SCROLL_2_FRAMES\fP = 0b111 }"
.br
.RI "SSD1306 scroll step in terms of frame frequency enumerator definition\&. "
.ti -1c
.RI "enum \fBssd1306_scroll_types_e\fP { \fBSSD1306_SCROLL_RIGHT\fP = 1, \fBSSD1306_SCROLL_LEFT\fP = 2, \fBSSD1306_SCROLL_DOWN\fP = 3, \fBSSD1306_SCROLL_UP\fP = 4, \fBSSD1306_SCROLL_STOP\fP = 5 }"
.br
.RI "SSD1306 scroll types enumerator definition\&. "
.ti -1c
.RI "enum \fBssd1306_panel_sizes_e\fP { \fBSSD1306_PANEL_128x32\fP = 0, \fBSSD1306_PANEL_128x64\fP = 1, \fBSSD1306_PANEL_128x128\fP = 2 }"
.br
.RI "SSD1306 panel sizes enumerator definition\&. "
.ti -1c
.RI "enum \fBtbi2cxxx_types_e\fP { \fBTBI2CH04\fP, \fBTBI2CH08\fP, \fBTBI2CH70\fP, \fBTBI2CS70\fP }"
.br
.RI "TBI2CXXX types enumerators\&. "
.ti -1c
.RI "enum \fBtlv493d_power_modes_e\fP { \fBTLV493D_POWER_DOWN_MODE\fP, \fBTLV493D_FAST_MODE\fP, \fBTLV493D_LOW_POWER_MODE\fP, \fBTLV493D_ULTRA_LOW_POWER_MODE\fP, \fBTLV493D_MASTER_CONTROLLED_MODE\fP }"
.br
.RI "TLV493D power modes enumerator\&. "
.ti -1c
.RI "enum \fBtlv493d_channel_conversions_e\fP { \fBTLV493D_CHANNEL_CONV_COMPLETED\fP = (0b00), \fBTLV493D_CHANNEL_Y_CONV_ONGOING\fP = (0b01), \fBTLV493D_CHANNEL_Z_CONV_ONGOING\fP = (0b10), \fBTLV493D_CHANNEL_TEMP_CONV_ONGOING\fP = (0b11) }"
.br
.RI "TLV493D channel conversations enumerator\&. "
.ti -1c
.RI "enum \fBtlv493d_i2c_addresses_e\fP { \fBTLV493D_I2C_ADDRESS_00\fP = (0b00), \fBTLV493D_I2C_ADDRESS_01\fP = (0b01), \fBTLV493D_I2C_ADDRESS_10\fP = (0b10), \fBTLV493D_I2C_ADDRESS_11\fP = (0b11) }"
.br
.RI "TLV493D addresses for slaves enumerator\&. "
.ti -1c
.RI "enum \fBtlv493d_low_power_periods_e\fP { \fBTLV493D_LOW_POWER_PERIOD_100MS\fP = (0b0), \fBTLV493D_LOW_POWER_PERIOD_12MS\fP = (0b1) }"
.br
.RI "TLV493D low power periods enumerator\&. "
.ti -1c
.RI "enum \fBveml6040_channels_t\fP { \fBVEML6040_CHANNEL_RED\fP = 0, \fBVEML6040_CHANNEL_GREEN\fP = 1, \fBVEML6040_CHANNEL_BLUE\fP = 2, \fBVEML6040_CHANNEL_WHITE\fP = 3 }"
.br
.RI "VEML6040 channels enumerator\&. "
.ti -1c
.RI "enum \fBveml6040_integration_times_e\fP { \fBVEML6040_INTEGRATION_TIME_40MS\fP = (0b000), \fBVEML6040_INTEGRATION_TIME_80MS\fP = (0b001), \fBVEML6040_INTEGRATION_TIME_160MS\fP = (0b010), \fBVEML6040_INTEGRATION_TIME_320MS\fP = (0b011), \fBVEML6040_INTEGRATION_TIME_640MS\fP = (0b100), \fBVEML6040_INTEGRATION_TIME_1280MS\fP = (0b101) }"
.br
.RI "VEML6040 integration times enumerator\&. "
.ti -1c
.RI "enum \fBveml6040_triggers_e\fP { \fBVEML6040_TRIGGER_NONE\fP = 0, \fBVEML6040_TRIGGER_ONE_TIME\fP = 1 }"
.br
.RI "VEML6040 triggers enumerator\&. "
.ti -1c
.RI "enum \fBveml6040_modes_e\fP { \fBVEML6040_MODE_AUTO\fP = 0, \fBVEML6040_MODE_MANUAL\fP = 1 }"
.br
.RI "VEML6040 modes enumerator\&. "
.ti -1c
.RI "enum \fBveml7700_gains_e\fP { \fBVEML7700_GAIN_1\fP = (0b00), \fBVEML7700_GAIN_2\fP = (0b01), \fBVEML7700_GAIN_DIV_8\fP = (0b10), \fBVEML7700_GAIN_DIV_4\fP = (0b11) }"
.br
.RI "VEML7700 gains enumerator\&. "
.ti -1c
.RI "enum \fBveml7700_integration_times_e\fP { \fBVEML7700_INTEGRATION_TIME_25MS\fP = (0b1100), \fBVEML7700_INTEGRATION_TIME_50MS\fP = (0b1000), \fBVEML7700_INTEGRATION_TIME_100MS\fP = (0b0000), \fBVEML7700_INTEGRATION_TIME_200MS\fP = (0b0001), \fBVEML7700_INTEGRATION_TIME_400MS\fP = (0b0010), \fBVEML7700_INTEGRATION_TIME_800MS\fP = (0b0011) }"
.br
.RI "VEML7700 integration times enumerator\&. "
.ti -1c
.RI "enum \fBveml7700_persistence_protections_e\fP { \fBVEML7700_PERSISTENCE_PROTECTION_1\fP = (0b00), \fBVEML7700_PERSISTENCE_PROTECTION_2\fP = (0b01), \fBVEML7700_PERSISTENCE_PROTECTION_4\fP = (0b10), \fBVEML7700_PERSISTENCE_PROTECTION_8\fP = (0b11) }"
.br
.RI "VEML7700 persistence protections enumerator\&. "
.ti -1c
.RI "enum \fBveml7700_power_saving_modes_e\fP { \fBVEML7700_POWER_SAVING_MODE_1\fP = (0b00), \fBVEML7700_POWER_SAVING_MODE_2\fP = (0b01), \fBVEML7700_POWER_SAVING_MODE_3\fP = (0b10), \fBVEML7700_POWER_SAVING_MODE_4\fP = (0b11) }"
.br
.RI "VEML7700 power saving modes enumerator\&. "
.ti -1c
.RI "enum \fBds18b20_resolutions_e\fP { \fBDS18B20_RESOLUTION_9BIT\fP = 0b00, \fBDS18B20_RESOLUTION_10BIT\fP = 0b01, \fBDS18B20_RESOLUTION_11BIT\fP = 0b10, \fBDS18B20_RESOLUTION_12BIT\fP = 0b11 }"
.br
.RI "DS18B20 supported resolutions enumerator\&. "
.ti -1c
.RI "enum \fBspi_max31865_fault_detection_cycles_t\fP { \fBSPI_MAX31865_FAULT_DETECT_FINISHED\fP = (0b00), \fBSPI_MAX31865_FAULT_DETECT_STILL_RUNNING\fP = (0b01), \fBSPI_MAX31865_FAULT_DETECT_CYCLE1_RUNNING\fP = (0b10), \fBSPI_MAX31865_FAULT_DETECT_CYCLE2_RUNNING\fP = (0b11) }"
.br
.ti -1c
.RI "enum \fBspi_max31865_modes_t\fP { \fBSPI_MAX31865_MODE_SINGLE\fP = 0, \fBSPI_MAX31865_MODE_AUTO\fP }"
.br
.ti -1c
.RI "enum \fBspi_max31865_filters_t\fP { \fBSPI_MAX31865_FILTER_60HZ\fP = 0, \fBSPI_MAX31865_FILTER_50HZ\fP }"
.br
.ti -1c
.RI "enum \fBspi_max31865_connection_types_t\fP { \fBSPI_MAX31865_2WIRE_OR_4WIRE\fP = 0, \fBSPI_MAX31865_3WIRE\fP = 1 }"
.br
.ti -1c
.RI "enum \fBspi_max31865_standards_t\fP { \fBSPI_MAX31865_ITS90\fP = 0, \fBSPI_MAX31865_DIN43760\fP, \fBSPI_MAX31865_US_INDUSTRIAL\fP }"
.br
.ti -1c
.RI "enum \fBdatatable_event_types_tag\fP { \fBDATATABLE_EVENT_INIT\fP, \fBDATATABLE_EVENT_RESET_ROWS\fP, \fBDATATABLE_EVENT_RESET_SAMPLES\fP, \fBDATATABLE_EVENT_FIFO_ROWS\fP, \fBDATATABLE_EVENT_FIFO_SAMPLES\fP, \fBDATATABLE_EVENT_SAMPLE_PUSHED\fP, \fBDATATABLE_EVENT_PROCESS\fP, \fBDATATABLE_EVENT_PROCESS_ELAPSED\fP }"
.br
.RI "Data-table event types enumerator\&. "
.ti -1c
.RI "enum \fBdatatable_data_storage_types_tag\fP { \fBDATATABLE_DATA_STORAGE_MEMORY_RING\fP, \fBDATATABLE_DATA_STORAGE_MEMORY_RESET\fP, \fBDATATABLE_DATA_STORAGE_MEMORY_STOP\fP }"
.br
.RI "Data-table data storage-types enumerator\&. "
.ti -1c
.RI "enum \fBdatatable_column_process_types_tag\fP { \fBDATATABLE_COLUMN_PROCESS_SMP\fP, \fBDATATABLE_COLUMN_PROCESS_AVG\fP, \fBDATATABLE_COLUMN_PROCESS_MIN\fP, \fBDATATABLE_COLUMN_PROCESS_MAX\fP, \fBDATATABLE_COLUMN_PROCESS_MIN_TS\fP, \fBDATATABLE_COLUMN_PROCESS_MAX_TS\fP }"
.br
.RI "Data-table column statistical process-types enumerator\&. "
.ti -1c
.RI "enum \fBdatatable_column_data_types_tag\fP { \fBDATATABLE_COLUMN_DATA_ID\fP, \fBDATATABLE_COLUMN_DATA_TS\fP, \fBDATATABLE_COLUMN_DATA_VECTOR\fP, \fBDATATABLE_COLUMN_DATA_BOOL\fP, \fBDATATABLE_COLUMN_DATA_FLOAT\fP, \fBDATATABLE_COLUMN_DATA_INT16\fP }"
.br
.RI "Data-table column data-types enumerator\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "esp_err_t \fBs12sd_init\fP (const \fBs12sd_config_t\fP *s12sd_config, \fBs12sd_handle_t\fP *s12sd_handle)"
.br
.RI "Initializes an adc S12SD device\&. "
.ti -1c
.RI "esp_err_t \fBs12sd_measure\fP (\fBs12sd_handle_t\fP handle, uint8_t *uv_index)"
.br
.RI "Measure S12SD device\&. "
.ti -1c
.RI "esp_err_t \fBs12sd_delete\fP (\fBs12sd_handle_t\fP handle)"
.br
.RI "Deinitialize S12SD device\&. "
.ti -1c
.RI "const char * \fBs12sd_get_fw_version\fP (void)"
.br
.RI "Converts S12SD firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBs12sd_get_fw_version_number\fP (void)"
.br
.RI "Converts S12SD firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "union \fB__attribute__\fP ((packed)) ahtxx_status_register_u"
.br
.RI "AHTXX status register structure definition\&. "
.ti -1c
.RI "esp_err_t \fBahtxx_get_status_register\fP (\fBahtxx_handle_t\fP handle, ahtxx_status_register_t *const reg)"
.br
.RI "Reads status register from AHTXX\&. "
.ti -1c
.RI "esp_err_t \fBahtxx_init\fP (const i2c_master_bus_handle_t master_handle, const \fBahtxx_config_t\fP *ahtxx_config, \fBahtxx_handle_t\fP *const ahtxx_handle)"
.br
.RI "Initializes an AHTXX device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBahtxx_get_measurement\fP (\fBahtxx_handle_t\fP handle, float *const temperature, float *const humidity)"
.br
.RI "Reads temperature and relative humidity from AHTXX\&. "
.ti -1c
.RI "esp_err_t \fBahtxx_get_measurements\fP (\fBahtxx_handle_t\fP handle, float *const temperature, float *const humidity, float *const dewpoint)"
.br
.RI "Similar to \fRi2c_aht2x_read_measurement\fP but it includes dewpoint in the results\&. "
.ti -1c
.RI "esp_err_t \fBahtxx_get_busy_status\fP (\fBahtxx_handle_t\fP handle, bool *const busy)"
.br
.RI "Reads busy status flag from AHTXX\&. "
.ti -1c
.RI "esp_err_t \fBahtxx_get_calibration_status\fP (\fBahtxx_handle_t\fP handle, bool *const calibrated)"
.br
.RI "Reads calibration status flag from AHTXX\&. "
.ti -1c
.RI "esp_err_t \fBahtxx_get_status\fP (\fBahtxx_handle_t\fP handle, bool *const busy, bool *const calibrated)"
.br
.RI "Reads busy and calibrated status flags from AHTXX\&. "
.ti -1c
.RI "esp_err_t \fBahtxx_reset\fP (\fBahtxx_handle_t\fP handle)"
.br
.RI "Issues soft-reset and initializes AHTXX\&. See datasheet for details\&. "
.ti -1c
.RI "esp_err_t \fBahtxx_remove\fP (\fBahtxx_handle_t\fP handle)"
.br
.RI "Removes an AHTXX device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBahtxx_delete\fP (\fBahtxx_handle_t\fP handle)"
.br
.RI "Removes an AHTXX device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBahtxx_get_fw_version\fP (void)"
.br
.RI "Converts AHTXX firmware version numbers (major, minor, patch, build) into a string\&. "
.ti -1c
.RI "int32_t \fBahtxx_get_fw_version_number\fP (void)"
.br
.RI "Converts AHTXX firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBak8975_get_control_register\fP (\fBak8975_handle_t\fP handle, ak8975_control_register_t *const reg)"
.br
.RI "Reads control register from AK8975\&. "
.ti -1c
.RI "esp_err_t \fBak8975_set_control_register\fP (\fBak8975_handle_t\fP handle, const ak8975_control_register_t reg)"
.br
.RI "Writes control register to AK8975\&. "
.ti -1c
.RI "esp_err_t \fBak8975_get_selftest_control_register\fP (\fBak8975_handle_t\fP handle, ak8975_selftest_control_register_t *const reg)"
.br
.RI "Reads self-test control register from AK8975\&. "
.ti -1c
.RI "esp_err_t \fBak8975_get_status1_register\fP (\fBak8975_handle_t\fP handle, ak8975_status1_register_t *const reg)"
.br
.RI "Reads status 1 register from AK8975\&. "
.ti -1c
.RI "esp_err_t \fBak8975_get_status2_register\fP (\fBak8975_handle_t\fP handle, ak8975_status2_register_t *const reg)"
.br
.RI "Reads status 2 register from AK8975\&. "
.ti -1c
.RI "esp_err_t \fBak8975_get_asa_registers\fP (\fBak8975_handle_t\fP handle, uint8_t *const asa_x_reg, uint8_t *const asa_y_reg, uint8_t *const asa_z_reg)"
.br
.RI "Reads ASA (X, Y, Z) registers from AK8975\&. "
.ti -1c
.RI "float \fBak8975_convert_to_heading\fP (const \fBak8975_magnetic_axes_data_t\fP axes_data)"
.br
.RI "Converts heading (0-359 degrees) from magnetic axes\&. "
.ti -1c
.RI "esp_err_t \fBak8975_init\fP (i2c_master_bus_handle_t master_handle, const \fBak8975_config_t\fP *ak8975_config, \fBak8975_handle_t\fP *ak8975_handle)"
.br
.RI "Initializes an AK8975 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBak8975_get_magnetic_axes\fP (\fBak8975_handle_t\fP handle, \fBak8975_magnetic_axes_data_t\fP *const axes_data)"
.br
.RI "Read magnetic measurement from AK8975\&. "
.ti -1c
.RI "esp_err_t \fBak8975_selftest\fP (\fBak8975_handle_t\fP handle, \fBak8975_magnetic_axes_data_t\fP *const axes_data)"
.br
.RI "Self-test judgement of AK8975 to check if sensor is working normally\&. "
.ti -1c
.RI "esp_err_t \fBak8975_get_data_status\fP (\fBak8975_handle_t\fP handle, bool *const ready)"
.br
.ti -1c
.RI "esp_err_t \fBak8975_get_error_status\fP (\fBak8975_handle_t\fP handle, bool *const error)"
.br
.ti -1c
.RI "esp_err_t \fBak8975_get_overflow_status\fP (\fBak8975_handle_t\fP handle, bool *const overflow)"
.br
.ti -1c
.RI "esp_err_t \fBak8975_power_down\fP (\fBak8975_handle_t\fP handle)"
.br
.ti -1c
.RI "esp_err_t \fBak8975_remove\fP (\fBak8975_handle_t\fP handle)"
.br
.RI "Removes an AK8975 device from master I2C bus\&. "
.ti -1c
.RI "esp_err_t \fBak8975_delete\fP (\fBak8975_handle_t\fP handle)"
.br
.RI "Removes an AK8975 device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBak8975_get_fw_version\fP (void)"
.br
.RI "Converts AK8975 firmware version numbers (major, minor, patch, build) into a string\&. "
.ti -1c
.RI "int32_t \fBak8975_get_fw_version_number\fP (void)"
.br
.RI "Converts AK8975 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "\fBESP_EVENT_DECLARE_BASE\fP (ESP_AS3935_EVENT)"
.br
.RI "declare of AS3935 monitor event base\&. "
.ti -1c
.RI "esp_err_t \fBas3935_monitor_init\fP (i2c_master_bus_handle_t master_handle, const \fBas3935_config_t\fP *as3935_config, \fBas3935_monitor_handle_t\fP *monitor_handle)"
.br
.RI "initialize AS3935 monitor instance\&. "
.ti -1c
.RI "esp_err_t \fBas3935_monitor_deinit\fP (\fBas3935_monitor_handle_t\fP monitor_handle)"
.br
.RI "de-initialize AS3935 monitor instance\&. "
.ti -1c
.RI "esp_err_t \fBas3935_monitor_add_handler\fP (\fBas3935_monitor_handle_t\fP monitor_handle, esp_event_handler_t event_handler, void *handler_args)"
.br
.RI "adds user defined event handler for AS3935 monitor\&. "
.ti -1c
.RI "esp_err_t \fBas3935_monitor_remove_handler\fP (\fBas3935_monitor_handle_t\fP monitor_handle, esp_event_handler_t event_handler)"
.br
.RI "removes user defined event handler for AS3935 monitor\&. "
.ti -1c
.RI "esp_err_t \fBas3935_get_0x00_register\fP (\fBas3935_handle_t\fP handle, as3935_0x00_register_t *const reg)"
.br
.RI "gets 0x00 register from AS3935\&. "
.ti -1c
.RI "esp_err_t \fBas3935_set_0x00_register\fP (\fBas3935_handle_t\fP handle, const as3935_0x00_register_t reg)"
.br
.RI "sets 0x00 register on AS3935\&. "
.ti -1c
.RI "esp_err_t \fBas3935_get_0x01_register\fP (\fBas3935_handle_t\fP handle, as3935_0x01_register_t *const reg)"
.br
.RI "gets 0x01 register from AS3935\&. "
.ti -1c
.RI "esp_err_t \fBas3935_set_0x01_register\fP (\fBas3935_handle_t\fP handle, const as3935_0x01_register_t reg)"
.br
.RI "sets 0x01 register on AS3935\&. "
.ti -1c
.RI "esp_err_t \fBas3935_get_0x02_register\fP (\fBas3935_handle_t\fP handle, as3935_0x02_register_t *const reg)"
.br
.RI "gets 0x02 register from AS3935\&. "
.ti -1c
.RI "esp_err_t \fBas3935_set_0x02_register\fP (\fBas3935_handle_t\fP handle, const as3935_0x02_register_t reg)"
.br
.RI "sets 0x02 register on AS3935\&. "
.ti -1c
.RI "esp_err_t \fBas3935_get_0x03_register\fP (\fBas3935_handle_t\fP handle, as3935_0x03_register_t *const reg)"
.br
.RI "gets 0x03 register from AS3935\&. "
.ti -1c
.RI "esp_err_t \fBas3935_set_0x03_register\fP (\fBas3935_handle_t\fP handle, const as3935_0x03_register_t reg)"
.br
.RI "sets 0x03 register on AS3935\&. "
.ti -1c
.RI "esp_err_t \fBas3935_get_0x08_register\fP (\fBas3935_handle_t\fP handle, as3935_0x08_register_t *const reg)"
.br
.RI "gets 0x08 register from AS3935\&. "
.ti -1c
.RI "esp_err_t \fBas3935_set_0x08_register\fP (\fBas3935_handle_t\fP handle, const as3935_0x08_register_t reg)"
.br
.RI "sets 0x08 register on AS3935\&. "
.ti -1c
.RI "esp_err_t \fBas3935_init\fP (i2c_master_bus_handle_t master_handle, const \fBas3935_config_t\fP *as3935_config, \fBas3935_handle_t\fP *as3935_handle)"
.br
.RI "initializes an AS3935 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBas3935_register_isr\fP (\fBas3935_handle_t\fP handle, const as3935_isr_t isr)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_reset_to_defaults\fP (\fBas3935_handle_t\fP handle)"
.br
.RI "resets AS3935 to defaults\&. "
.ti -1c
.RI "esp_err_t \fBas3935_calibrate_rco\fP (\fBas3935_handle_t\fP handle)"
.br
.RI "calibrates AS3935 RC oscillator\&. "
.ti -1c
.RI "esp_err_t \fBas3935_clear_lightning_statistics\fP (\fBas3935_handle_t\fP handle)"
.br
.RI "clears AS3935 lightning statistics\&. "
.ti -1c
.RI "esp_err_t \fBas3935_enable_power\fP (\fBas3935_handle_t\fP handle)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_get_analog_frontend\fP (\fBas3935_handle_t\fP handle, \fBas3935_analog_frontends_t\fP *const analog_frontend)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_get_watchdog_threshold\fP (\fBas3935_handle_t\fP handle, \fBas3935_watchdog_thresholds_t\fP *const watchdog_threshold)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_get_noise_floor_threshold\fP (\fBas3935_handle_t\fP handle, \fBas3935_noise_levels_t\fP *const noise_level)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_get_spike_rejection\fP (\fBas3935_handle_t\fP handle, uint8_t *const spike_rejection)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_get_minimum_lightnings\fP (\fBas3935_handle_t\fP handle, \fBas3935_minimum_lightnings_t\fP *const min_lightnings)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_enable_disturber_detection\fP (\fBas3935_handle_t\fP handle)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_get_frequency_division_ratio\fP (\fBas3935_handle_t\fP handle, \fBas3935_frequency_division_ratios_t\fP *const ratio)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_get_display_oscillator_on_irq\fP (\fBas3935_handle_t\fP handle, \fBas3935_oscillator_modes_t\fP oscillator_mode, bool *const enabled)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_get_internal_capacitors\fP (\fBas3935_handle_t\fP handle, uint8_t *const value)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_disable_power\fP (\fBas3935_handle_t\fP handle)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_set_analog_frontend\fP (\fBas3935_handle_t\fP handle, const \fBas3935_analog_frontends_t\fP analog_frontend)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_set_watchdog_threshold\fP (\fBas3935_handle_t\fP handle, const \fBas3935_watchdog_thresholds_t\fP watchdog_threshold)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_set_noise_floor_threshold\fP (\fBas3935_handle_t\fP handle, const \fBas3935_noise_levels_t\fP noise_level)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_set_spike_rejection\fP (\fBas3935_handle_t\fP handle, const uint8_t spike_rejection)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_set_minimum_lightnings\fP (\fBas3935_handle_t\fP handle, const \fBas3935_minimum_lightnings_t\fP min_lightnings)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_disable_disturber_detection\fP (\fBas3935_handle_t\fP handle)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_set_frequency_division_ratio\fP (\fBas3935_handle_t\fP handle, const \fBas3935_frequency_division_ratios_t\fP ratio)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_set_display_oscillator_on_irq\fP (\fBas3935_handle_t\fP handle, const \fBas3935_oscillator_modes_t\fP oscillator_mode, const bool enabled)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_set_internal_capacitors\fP (\fBas3935_handle_t\fP handle, const uint8_t value)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_get_interrupt_state\fP (\fBas3935_handle_t\fP handle, \fBas3935_interrupt_states_t\fP *const state)"
.br
.RI "gets interrupt state of AS3935\&. "
.ti -1c
.RI "esp_err_t \fBas3935_get_lightning_energy\fP (\fBas3935_handle_t\fP handle, uint32_t *const energy)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_get_lightning_distance\fP (\fBas3935_handle_t\fP handle, \fBas3935_lightning_distances_t\fP *const distance)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_get_lightning_distance_km\fP (\fBas3935_handle_t\fP handle, uint8_t *const distance)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_get_lightning_event\fP (\fBas3935_handle_t\fP handle, \fBas3935_lightning_distances_t\fP *const distance, uint32_t *const energy)"
.br
.ti -1c
.RI "esp_err_t \fBas3935_remove\fP (\fBas3935_handle_t\fP handle)"
.br
.RI "Removes an AS3935 device from I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBas3935_delete\fP (\fBas3935_handle_t\fP handle)"
.br
.RI "Removes an AS3935 device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBas3935_get_fw_version\fP (void)"
.br
.RI "Converts AS3935 firmware version numbers (major, minor, patch, build) into a string\&. "
.ti -1c
.RI "int32_t \fBas3935_get_fw_version_number\fP (void)"
.br
.RI "Converts AS3935 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_led_register\fP (\fBas7341_handle_t\fP handle, as7341_led_register_t *const reg)"
.br
.RI "Reads LED register (0x74) from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_led_register\fP (\fBas7341_handle_t\fP handle, const as7341_led_register_t reg)"
.br
.RI "Writes LED register (0x74) to AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_astatus_register\fP (\fBas7341_handle_t\fP handle, as7341_astatus_register_t *const reg)"
.br
.RI "Reads ASTATUS register (0x94) from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_status2_register\fP (\fBas7341_handle_t\fP handle, as7341_status2_register_t *const reg)"
.br
.RI "Reads status 2 register (0xA3) from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_disable_enable_register\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Disables spectral readings, flicker detection, power, etc\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_enable_register\fP (\fBas7341_handle_t\fP handle, as7341_enable_register_t *const reg)"
.br
.RI "Reads enable register (0x80) from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_enable_register\fP (\fBas7341_handle_t\fP handle, const as7341_enable_register_t reg)"
.br
.RI "Writes enable register (0x80) to AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_auxiliary_id_register\fP (\fBas7341_handle_t\fP handle, as7341_auxiliary_id_register_t *const reg)"
.br
.RI "Reads auxiliary id register (0x90) from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_revision_id_register\fP (\fBas7341_handle_t\fP handle, as7341_revision_id_register_t *const reg)"
.br
.RI "Reads revision id register (0x91) from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_part_id_register\fP (\fBas7341_handle_t\fP handle, as7341_part_id_register_t *const reg)"
.br
.RI "Reads part id register (0x92) from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_config_register\fP (\fBas7341_handle_t\fP handle, as7341_config_register_t *const reg)"
.br
.RI "Reads configuration register (0x70) from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_config_register\fP (\fBas7341_handle_t\fP handle, const as7341_config_register_t reg)"
.br
.RI "Writes configuration register (0x70) from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_config0_register\fP (\fBas7341_handle_t\fP handle, as7341_config0_register_t *const reg)"
.br
.RI "Reads configuration 0 register (0xA9) from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_config0_register\fP (\fBas7341_handle_t\fP handle, const as7341_config0_register_t reg)"
.br
.RI "Writes configuration 0 register (0xA9) from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_config1_register\fP (\fBas7341_handle_t\fP handle, as7341_config1_register_t *const reg)"
.br
.RI "Reads configuration 1 (0xAA) register from AS7341\&. This register configures the 6 integrated ADC (CH0 to CH5)\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_config1_register\fP (\fBas7341_handle_t\fP handle, const as7341_config1_register_t reg)"
.br
.RI "Writes configuration 1 (0xAA) register to AS7341\&. This register configures the 6 integrated ADC (CH0 to CH5)\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_config6_register\fP (\fBas7341_handle_t\fP handle, as7341_config6_register_t *const reg)"
.br
.RI "Reads configuration 6 register (0xAF) from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_config6_register\fP (\fBas7341_handle_t\fP handle, const as7341_config6_register_t reg)"
.br
.RI "Writes configuration 6 register (0xAF) to AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_atime_register\fP (\fBas7341_handle_t\fP handle, uint8_t *const reg)"
.br
.RI "Reads ATIME (0x81) register from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_atime_register\fP (\fBas7341_handle_t\fP handle, const uint8_t reg)"
.br
.RI "Writes ATIME (0x81) register to AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_astep_register\fP (\fBas7341_handle_t\fP handle, uint16_t *const reg)"
.br
.RI "Reads ASTEP (0xCA, 0xCB) register from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_astep_register\fP (\fBas7341_handle_t\fP handle, const uint16_t reg)"
.br
.RI "Writes ASTEP (0xCA, 0xCB) register to AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_flicker_detection_status_register\fP (\fBas7341_handle_t\fP handle, as7341_flicker_detection_status_register_t *const reg)"
.br
.RI "Reads flicker detection status (0xDB) register from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_flicker_detection_status_register\fP (\fBas7341_handle_t\fP handle, const as7341_flicker_detection_status_register_t reg)"
.br
.RI "Writes flicker detection status (0xDB) register to AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_clear_flicker_detection_status_register\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Clears flicker detection status (0xDB) register on AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_enable_hi_register_bank\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Enables access to the AS7341 high register bank (0x80 to 0xFF)\&. "
.ti -1c
.RI "esp_err_t \fBas7341_enable_lo_register_bank\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Enables access to the AS7341 low register bank (0x60 to 0x74)\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_smux_command\fP (\fBas7341_handle_t\fP handle, const \fBas7341_smux_commands_t\fP command)"
.br
.RI "Writes SMUX command to AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_init\fP (i2c_master_bus_handle_t master_handle, const \fBas7341_config_t\fP *as7341_config, \fBas7341_handle_t\fP *as7341_handle)"
.br
.RI "Initializes an AS7341 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_spectral_measurements\fP (\fBas7341_handle_t\fP handle, \fBas7341_channels_spectral_data_t\fP *const spectral_data)"
.br
.RI "Reads spectral sensors measurements, F1 to F8, Clear and NIR, from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_basic_counts\fP (\fBas7341_handle_t\fP handle, const \fBas7341_channels_spectral_data_t\fP spectral_data, \fBas7341_channels_basic_counts_data_t\fP *const basic_counts_data)"
.br
.RI "Converts AS7341 spectral sensors measurements to basic counts\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_flicker_detection_status\fP (\fBas7341_handle_t\fP handle, \fBas7341_flicker_detection_states_t\fP *const state)"
.br
.RI "Reads flicker detection status from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_data_status\fP (\fBas7341_handle_t\fP handle, bool *const ready)"
.br
.RI "Reads data status from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_atime\fP (\fBas7341_handle_t\fP handle, uint8_t *const atime)"
.br
.RI "Reads the number of integration steps for the ADC integration time from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_atime\fP (\fBas7341_handle_t\fP handle, const uint8_t atime)"
.br
.RI "Writes the number of integration steps for the ADC integration time to AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_astep\fP (\fBas7341_handle_t\fP handle, uint16_t *const astep)"
.br
.RI "Reads the number of integration time steps for the ADC integration time from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_astep\fP (\fBas7341_handle_t\fP handle, const uint16_t astep)"
.br
.RI "Writes the number of integration time steps for the ADC integration time to AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_spectral_gain\fP (\fBas7341_handle_t\fP handle, \fBas7341_spectral_gains_t\fP *const gain)"
.br
.RI "Reads spectral gain setting from AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_spectral_gain\fP (\fBas7341_handle_t\fP handle, const \fBas7341_spectral_gains_t\fP gain)"
.br
.RI "Writes spectral gain setting to AS7341\&. "
.ti -1c
.RI "esp_err_t \fBas7341_get_ambient_light_sensing_mode\fP (\fBas7341_handle_t\fP handle, \fBas7341_als_modes_t\fP *const mode)"
.br
.RI "Reads ambient light sensing mode from AS7341\&. SPM mode (spectral measurement), normal mode, is configured by default\&. "
.ti -1c
.RI "esp_err_t \fBas7341_set_ambient_light_sensing_mode\fP (\fBas7341_handle_t\fP handle, const \fBas7341_als_modes_t\fP mode)"
.br
.RI "Writes ambient light sensing mode to AS7341\&. SPM mode (spectral measurement), normal mode, is configured by default\&. "
.ti -1c
.RI "esp_err_t \fBas7341_enable_flicker_detection\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Enables AS7341 flicker detection\&. "
.ti -1c
.RI "esp_err_t \fBas7341_disable_flicker_detection\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Disables AS7341 flicker detection\&. "
.ti -1c
.RI "esp_err_t \fBas7341_enable_smux\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Enables AS7341 supper multiplier (SMUX) special interrupt\&. "
.ti -1c
.RI "esp_err_t \fBas7341_enable_wait_time\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Enables AS7341 wait time between two consecutive spectral measurements\&. "
.ti -1c
.RI "esp_err_t \fBas7341_disable_wait_time\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Disables AS7341 wait time between two consecutive spectral measurements\&. "
.ti -1c
.RI "esp_err_t \fBas7341_enable_spectral_measurement\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Enables AS7341 spectral measurement\&. "
.ti -1c
.RI "esp_err_t \fBas7341_disable_spectral_measurement\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Disables AS7341 spectral measurement\&. "
.ti -1c
.RI "esp_err_t \fBas7341_enable_power\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Enables AS7341 power\&. "
.ti -1c
.RI "esp_err_t \fBas7341_disable_power\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Disables AS7341 power\&. "
.ti -1c
.RI "esp_err_t \fBas7341_enable_led\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Enables AS7341 onboard LED\&. "
.ti -1c
.RI "esp_err_t \fBas7341_disable_led\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Disables AS7341 onboard LED\&. "
.ti -1c
.RI "esp_err_t \fBas7341_remove\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Removes an AS7341 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBas7341_delete\fP (\fBas7341_handle_t\fP handle)"
.br
.RI "Removes an AS7341 device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBas7341_get_fw_version\fP (void)"
.br
.RI "Converts AS7341 firmware version numbers (major, minor, patch, build) into a string\&. "
.ti -1c
.RI "int32_t \fBas7341_get_fw_version_number\fP (void)"
.br
.RI "Converts AS7341 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBbh1750_init\fP (i2c_master_bus_handle_t master_handle, const \fBbh1750_config_t\fP *bh1750_config, \fBbh1750_handle_t\fP *bh1750_handle)"
.br
.RI "initializes an BH1750 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBbh1750_get_ambient_light\fP (\fBbh1750_handle_t\fP handle, float *const ambient_light)"
.br
.RI "measure BH1750 illuminance\&. BH1750 goes into power-down mode after measurement when one-time measurements are configured\&. "
.ti -1c
.RI "esp_err_t \fBbh1750_set_measurement_mode\fP (\fBbh1750_handle_t\fP handle, const \fBbh1750_measurement_modes_t\fP mode)"
.br
.RI "Writes measurement mode to bh1750\&. "
.ti -1c
.RI "esp_err_t \fBbh1750_set_measurement_time\fP (\fBbh1750_handle_t\fP handle, const uint8_t timespan)"
.br
.RI "sets bh1750 sensor measurement time\&. see datasheet for details\&. "
.ti -1c
.RI "esp_err_t \fBbh1750_enable_power\fP (\fBbh1750_handle_t\fP handle)"
.br
.RI "power-up BH1750 sensor\&. "
.ti -1c
.RI "esp_err_t \fBbh1750_disable_power\fP (\fBbh1750_handle_t\fP handle)"
.br
.RI "power-down BH1750 sensor\&. "
.ti -1c
.RI "esp_err_t \fBbh1750_reset\fP (\fBbh1750_handle_t\fP handle)"
.br
.RI "soft-reset BH1750 sensor\&. Reset command is not acceptable in power-down mode\&. "
.ti -1c
.RI "esp_err_t \fBbh1750_remove\fP (\fBbh1750_handle_t\fP handle)"
.br
.RI "removes an BH1750 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBbh1750_delete\fP (\fBbh1750_handle_t\fP handle)"
.br
.RI "removes an BH1750 device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBbh1750_get_fw_version\fP (void)"
.br
.RI "Converts BH1750 firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBbh1750_get_fw_version_number\fP (void)"
.br
.RI "Converts BH1750 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_chip_id_register\fP (\fBbme680_handle_t\fP handle, uint8_t *const reg)"
.br
.RI "Reads chip identification register from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_variant_id_register\fP (\fBbme680_handle_t\fP handle, uint8_t *const reg)"
.br
.RI "Reads variant identification register from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_status0_register\fP (\fBbme680_handle_t\fP handle, bme680_status0_register_t *const reg)"
.br
.RI "Reads status register from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_gas_lsb_register\fP (\fBbme680_handle_t\fP handle, bme680_gas_lsb_register_t *const reg)"
.br
.RI "Reads gas resistance LSB register from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_set_gas_lsb_register\fP (\fBbme680_handle_t\fP handle, const bme680_gas_lsb_register_t reg)"
.br
.RI "Writes gas resistance LSB register to BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_control_measurement_register\fP (\fBbme680_handle_t\fP handle, bme680_control_measurement_register_t *const reg)"
.br
.RI "Reads control measurement register from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_set_control_measurement_register\fP (\fBbme680_handle_t\fP handle, const bme680_control_measurement_register_t reg)"
.br
.RI "Writes control measurement register to BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_control_humidity_register\fP (\fBbme680_handle_t\fP handle, bme680_control_humidity_register_t *const reg)"
.br
.RI "Reads control humidity register from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_set_control_humidity_register\fP (\fBbme680_handle_t\fP handle, const bme680_control_humidity_register_t reg)"
.br
.RI "Writes control humidity register to BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_control_gas0_register\fP (\fBbme680_handle_t\fP handle, bme680_control_gas0_register_t *const reg)"
.br
.RI "Reads control gas 0 register from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_set_control_gas0_register\fP (\fBbme680_handle_t\fP handle, const bme680_control_gas0_register_t reg)"
.br
.RI "Writes control gas 0 register to BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_control_gas1_register\fP (\fBbme680_handle_t\fP handle, bme680_control_gas1_register_t *const reg)"
.br
.RI "Reads control gas 1 register from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_set_control_gas1_register\fP (\fBbme680_handle_t\fP handle, const bme680_control_gas1_register_t reg)"
.br
.RI "Writes control gas 1 register to BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_configuration_register\fP (\fBbme680_handle_t\fP handle, bme680_config_register_t *const reg)"
.br
.RI "Reads configuration register from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_set_configuration_register\fP (\fBbme680_handle_t\fP handle, const bme680_config_register_t reg)"
.br
.RI "Writes configuration register to BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_init\fP (i2c_master_bus_handle_t master_handle, const \fBbme680_config_t\fP *bme680_config, \fBbme680_handle_t\fP *bme680_handle)"
.br
.RI "Initializes an BME680 device onto the master bus\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_adc_signals\fP (\fBbme680_handle_t\fP handle, \fBbme680_adc_data_t\fP *const data)"
.br
.RI "Reads humidity, temperature, and pressure ADC signals from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_data\fP (\fBbme680_handle_t\fP handle, \fBbme680_data_t\fP *const data)"
.br
.RI "Reads humidity, temperature, and pressure measurements from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_data_status\fP (\fBbme680_handle_t\fP handle, bool *const ready)"
.br
.RI "Reads data status of the BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_gas_measurement_index\fP (\fBbme680_handle_t\fP handle, uint8_t *const index)"
.br
.RI "Reads gas measurement index from the BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_power_mode\fP (\fBbme680_handle_t\fP handle, \fBbme680_power_modes_t\fP *const power_mode)"
.br
.RI "Reads power mode setting from the BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_set_power_mode\fP (\fBbme680_handle_t\fP handle, const \fBbme680_power_modes_t\fP power_mode)"
.br
.RI "Writes power mode setting to BME680\&. See datasheet, section 3\&.6, table 10\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_pressure_oversampling\fP (\fBbme680_handle_t\fP handle, \fBbme680_pressure_oversampling_t\fP *const oversampling)"
.br
.RI "Reads pressure oversampling setting from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_set_pressure_oversampling\fP (\fBbme680_handle_t\fP handle, const \fBbme680_pressure_oversampling_t\fP oversampling)"
.br
.RI "Writes pressure oversampling setting to BME680\&. See datasheet, section 3\&.3\&.1, table 4\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_temperature_oversampling\fP (\fBbme680_handle_t\fP handle, \fBbme680_temperature_oversampling_t\fP *const oversampling)"
.br
.RI "Reads temperature oversampling setting from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_set_temperature_oversampling\fP (\fBbme680_handle_t\fP handle, const \fBbme680_temperature_oversampling_t\fP oversampling)"
.br
.RI "Writes temperature oversampling setting to BME680\&. See datasheet, section 3\&.3\&.1, table 4\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_humidity_oversampling\fP (\fBbme680_handle_t\fP handle, \fBbme680_humidity_oversampling_t\fP *const oversampling)"
.br
.RI "Reads humidity oversampling setting from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_set_humidity_oversampling\fP (\fBbme680_handle_t\fP handle, const \fBbme680_humidity_oversampling_t\fP oversampling)"
.br
.RI "Writes humidity oversampling setting to BME680\&. See datasheet, section 3\&.3\&.1, table 4\&. "
.ti -1c
.RI "esp_err_t \fBbme680_get_iir_filter\fP (\fBbme680_handle_t\fP handle, \fBbme680_iir_filters_t\fP *const iir_filter)"
.br
.RI "Reads IIR filter setting from BME680\&. "
.ti -1c
.RI "esp_err_t \fBbme680_set_iir_filter\fP (\fBbme680_handle_t\fP handle, const \fBbme680_iir_filters_t\fP iir_filter)"
.br
.RI "Writes IIR filter setting to BME680\&. See datasheet, section 3\&.4, table 7\&. "
.ti -1c
.RI "esp_err_t \fBbme680_reset\fP (\fBbme680_handle_t\fP handle)"
.br
.RI "Issues soft-reset sensor and initializes registers for BME680\&. "
.ti -1c
.RI "char * \fBbme680_air_quality_to_string\fP (float iaq_score)"
.br
.RI "Air quality as a string based on the IAQ score\&. "
.ti -1c
.RI "esp_err_t \fBbme680_remove\fP (\fBbme680_handle_t\fP handle)"
.br
.RI "Removes an BME680 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBbme680_delete\fP (\fBbme680_handle_t\fP handle)"
.br
.RI "Removes an BME680 device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBbme680_get_fw_version\fP (void)"
.br
.RI "Converts BME680 firmware version numbers (major, minor, patch, build) into a string\&. "
.ti -1c
.RI "int32_t \fBbme680_get_fw_version_number\fP (void)"
.br
.RI "Converts BME680 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_get_chip_id_register\fP (\fBbmp280_handle_t\fP handle, uint8_t *const reg)"
.br
.RI "Reads chip identification register from BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_get_status_register\fP (\fBbmp280_handle_t\fP handle, bmp280_status_register_t *const reg)"
.br
.RI "Reads status register from BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_get_control_measurement_register\fP (\fBbmp280_handle_t\fP handle, bmp280_control_measurement_register_t *const reg)"
.br
.RI "Reads control measurement register from BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_set_control_measurement_register\fP (\fBbmp280_handle_t\fP handle, const bmp280_control_measurement_register_t reg)"
.br
.RI "Writes control measurement register to BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_get_configuration_register\fP (\fBbmp280_handle_t\fP handle, bmp280_configuration_register_t *const reg)"
.br
.RI "Reads configuration register from BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_set_configuration_register\fP (\fBbmp280_handle_t\fP handle, const bmp280_configuration_register_t reg)"
.br
.RI "Writes configuration register to BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_init\fP (i2c_master_bus_handle_t master_handle, const \fBbmp280_config_t\fP *bmp280_config, \fBbmp280_handle_t\fP *bmp280_handle)"
.br
.RI "Initializes an BMP280 device onto the master bus\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_get_measurements\fP (\fBbmp280_handle_t\fP handle, float *const temperature, float *const pressure)"
.br
.RI "Reads temperature and pressure measurements from BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_get_temperature\fP (\fBbmp280_handle_t\fP handle, float *const temperature)"
.br
.RI "Reads temperature measurement from BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_get_pressure\fP (\fBbmp280_handle_t\fP handle, float *const pressure)"
.br
.RI "Reads pressure measurement from BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_get_data_status\fP (\fBbmp280_handle_t\fP handle, bool *const ready)"
.br
.RI "Reads data status from BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_get_power_mode\fP (\fBbmp280_handle_t\fP handle, \fBbmp280_power_modes_t\fP *const power_mode)"
.br
.RI "Reads power mode setting from BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_set_power_mode\fP (\fBbmp280_handle_t\fP handle, const \fBbmp280_power_modes_t\fP power_mode)"
.br
.RI "Writes power mode setting to the BMP280\&. See datasheet, section 3\&.6, table 10\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_get_pressure_oversampling\fP (\fBbmp280_handle_t\fP handle, \fBbmp280_pressure_oversampling_t\fP *const oversampling)"
.br
.RI "Reads pressure oversampling setting from BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_set_pressure_oversampling\fP (\fBbmp280_handle_t\fP handle, const \fBbmp280_pressure_oversampling_t\fP oversampling)"
.br
.RI "Writes pressure oversampling setting to BMP280\&. See datasheet, section 3\&.3\&.1, table 4\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_get_temperature_oversampling\fP (\fBbmp280_handle_t\fP handle, \fBbmp280_temperature_oversampling_t\fP *const oversampling)"
.br
.RI "Reads temperature oversampling setting from BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_set_temperature_oversampling\fP (\fBbmp280_handle_t\fP handle, const \fBbmp280_temperature_oversampling_t\fP oversampling)"
.br
.RI "Writes temperature oversampling setting to BMP280\&. See datasheet, section 3\&.3\&.1, table 4\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_get_standby_time\fP (\fBbmp280_handle_t\fP handle, \fBbmp280_standby_times_t\fP *const standby_time)"
.br
.RI "Reads stand-by time setting from BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_set_standby_time\fP (\fBbmp280_handle_t\fP handle, const \fBbmp280_standby_times_t\fP standby_time)"
.br
.RI "Writes stand-by time setting to BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_get_iir_filter\fP (\fBbmp280_handle_t\fP handle, \fBbmp280_iir_filters_t\fP *const iir_filter)"
.br
.RI "Reads IIR filter setting to BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_set_iir_filter\fP (\fBbmp280_handle_t\fP handle, const \fBbmp280_iir_filters_t\fP iir_filter)"
.br
.RI "Writes IIR filter setting to BMP280\&. See datasheet, section 3\&.4, table 7\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_reset\fP (\fBbmp280_handle_t\fP handle)"
.br
.RI "Issues soft-reset sensor and initializes BMP280\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_remove\fP (\fBbmp280_handle_t\fP handle)"
.br
.RI "Removes an BMP280 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBbmp280_delete\fP (\fBbmp280_handle_t\fP handle)"
.br
.RI "Removes an BMP280 device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBbmp280_get_fw_version\fP (void)"
.br
.RI "Converts BMP280 firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBbmp280_get_fw_version_number\fP (void)"
.br
.RI "Converts BMP280 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_chip_id_register\fP (\fBbmp390_handle_t\fP handle, uint8_t *const reg)"
.br
.RI "Reads chip identification register from BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_status_register\fP (\fBbmp390_handle_t\fP handle, bmp390_status_register_t *const reg)"
.br
.RI "Reads status register from BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_interrupt_status_register\fP (\fBbmp390_handle_t\fP handle, bmp390_interrupt_status_register_t *const reg)"
.br
.RI "Reads interrupt control register from BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_interrupt_control_register\fP (\fBbmp390_handle_t\fP handle, bmp390_interrupt_control_register_t *const reg)"
.br
.RI "Reads interrupt control register from BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_set_interrupt_control_register\fP (\fBbmp390_handle_t\fP handle, const bmp390_interrupt_control_register_t reg)"
.br
.RI "Writes interrupt control register to BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_power_control_register\fP (\fBbmp390_handle_t\fP handle, bmp390_power_control_register_t *const reg)"
.br
.RI "Reads power control register from BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_set_power_control_register\fP (\fBbmp390_handle_t\fP handle, const bmp390_power_control_register_t reg)"
.br
.RI "Writes power control register to BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_output_data_rate_register\fP (\fBbmp390_handle_t\fP handle, bmp390_output_data_rate_register_t *const reg)"
.br
.RI "Reads output data rate register from BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_set_output_data_rate_register\fP (\fBbmp390_handle_t\fP handle, const bmp390_output_data_rate_register_t reg)"
.br
.RI "Writes output data rate register to BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_oversampling_register\fP (\fBbmp390_handle_t\fP handle, bmp390_oversampling_register_t *const reg)"
.br
.RI "Reads oversampling register from BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_set_oversampling_register\fP (\fBbmp390_handle_t\fP handle, const bmp390_oversampling_register_t reg)"
.br
.RI "Writes oversampling register to BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_configuration_register\fP (\fBbmp390_handle_t\fP handle, bmp390_configuration_register_t *const reg)"
.br
.RI "Reads configuration register from BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_set_configuration_register\fP (\fBbmp390_handle_t\fP handle, const bmp390_configuration_register_t reg)"
.br
.RI "Writes configuration register to BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_init\fP (i2c_master_bus_handle_t master_handle, const \fBbmp390_config_t\fP *bmp390_config, \fBbmp390_handle_t\fP *bmp280_handle)"
.br
.RI "Initializes an BMP390 device onto the master bus\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_measurements\fP (\fBbmp390_handle_t\fP handle, float *const temperature, float *const pressure)"
.br
.RI "Reads high-level measurements (temperature & pressure) from BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_status\fP (\fBbmp390_handle_t\fP handle, bool *const temperature_ready, bool *const pressure_ready, bool *const command_ready)"
.br
.RI "Reads status of the BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_data_status\fP (\fBbmp390_handle_t\fP handle, bool *const temperature_ready, bool *const pressure_ready)"
.br
.RI "Reads data status of the BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_power_mode\fP (\fBbmp390_handle_t\fP handle, \fBbmp390_power_modes_t\fP *const power_mode)"
.br
.RI "Reads power mode setting from the BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_set_power_mode\fP (\fBbmp390_handle_t\fP handle, const \fBbmp390_power_modes_t\fP power_mode)"
.br
.RI "Writes power mode setting to the BMP390\&. See datasheet, section 3\&.6, table 10\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_pressure_oversampling\fP (\fBbmp390_handle_t\fP handle, \fBbmp390_pressure_oversampling_t\fP *const oversampling)"
.br
.RI "Reads pressure oversampling setting from BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_set_pressure_oversampling\fP (\fBbmp390_handle_t\fP handle, const \fBbmp390_pressure_oversampling_t\fP oversampling)"
.br
.RI "Writes pressure oversampling setting to BMP390\&. See datasheet, section 3\&.3\&.1, table 4\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_temperature_oversampling\fP (\fBbmp390_handle_t\fP handle, \fBbmp390_temperature_oversampling_t\fP *const oversampling)"
.br
.RI "Reads temperature oversampling setting from BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_set_temperature_oversampling\fP (\fBbmp390_handle_t\fP handle, const \fBbmp390_temperature_oversampling_t\fP oversampling)"
.br
.RI "Writes temperature oversampling setting to BMP390\&. See datasheet, section 3\&.3\&.1, table 4\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_output_data_rate\fP (\fBbmp390_handle_t\fP handle, \fBbmp390_output_data_rates_t\fP *const output_data_rate)"
.br
.RI "Reads output data rate setting from BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_set_output_data_rate\fP (\fBbmp390_handle_t\fP handle, const \fBbmp390_output_data_rates_t\fP output_data_rate)"
.br
.RI "writes output data rate setting to bmp390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_get_iir_filter\fP (\fBbmp390_handle_t\fP handle, \fBbmp390_iir_filters_t\fP *const iir_filter)"
.br
.RI "Reads IIR filter setting to BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_set_iir_filter\fP (\fBbmp390_handle_t\fP handle, const \fBbmp390_iir_filters_t\fP iir_filter)"
.br
.RI "Writes IIR filter setting from BMP390\&. See datasheet, section 3\&.4, table 7\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_reset\fP (\fBbmp390_handle_t\fP handle)"
.br
.RI "Issues soft-reset sensor and initializes registers for BMP390\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_remove\fP (\fBbmp390_handle_t\fP handle)"
.br
.RI "removes an BMP390 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBbmp390_delete\fP (\fBbmp390_handle_t\fP handle)"
.br
.RI "Removes an BMP390 device from master I2C bus and delete the handle\&. "
.ti -1c
.RI "const char * \fBbmp390_get_fw_version\fP (void)"
.br
.RI "Converts BMP390 firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBbmp390_get_fw_version_number\fP (void)"
.br
.RI "Converts BMP390 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBccs811_get_status_register\fP (\fBccs811_handle_t\fP handle, ccs811_status_register_t *const reg)"
.br
.RI "Reads status register from CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_get_measure_mode_register\fP (\fBccs811_handle_t\fP handle, ccs811_measure_mode_register_t *const reg)"
.br
.RI "Reads measure mode register from CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_set_measure_mode_register\fP (\fBccs811_handle_t\fP handle, const ccs811_measure_mode_register_t reg)"
.br
.RI "Writes measure mode register to CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_get_error_register\fP (\fBccs811_handle_t\fP handle, ccs811_error_code_register_t *const reg)"
.br
.RI "Reads error register from CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_set_environmental_data_register\fP (\fBccs811_handle_t\fP handle, const float temperature, const float humidity)"
.br
.RI "Writes environmental compensation factors data to CCS811 register\&. "
.ti -1c
.RI "esp_err_t \fBccs811_set_thresholds_register\fP (\fBccs811_handle_t\fP handle, const uint16_t low_to_med, const uint16_t med_to_high, const uint8_t hysteresis)"
.br
.RI "Writes eCO2 thresholds to CCS811 register\&. "
.ti -1c
.RI "esp_err_t \fBccs811_get_baseline_register\fP (\fBccs811_handle_t\fP handle, uint16_t *const reg)"
.br
.RI "Reads encoded version of the current baseline register from CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_set_baseline_register\fP (\fBccs811_handle_t\fP handle, const uint16_t reg)"
.br
.RI "Writes encoded version to the CCS811 baseline register\&. "
.ti -1c
.RI "esp_err_t \fBccs811_get_hardware_identifier_register\fP (\fBccs811_handle_t\fP handle, uint8_t *const reg)"
.br
.RI "Reads hardware identifier register from CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_get_hardware_version_register\fP (\fBccs811_handle_t\fP handle, uint8_t *const reg)"
.br
.RI "Reads hardware version register from CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_start_application\fP (\fBccs811_handle_t\fP handle)"
.br
.RI "Starts the CCS811 application\&. "
.ti -1c
.RI "esp_err_t \fBccs811_init\fP (i2c_master_bus_handle_t master_handle, const \fBccs811_config_t\fP *ccs811_config, \fBccs811_handle_t\fP *ccs811_handle)"
.br
.RI "Initializes a CCS811 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBccs811_get_measurement\fP (\fBccs811_handle_t\fP handle, uint16_t *eco2, uint16_t *etvoc)"
.br
.RI "Reads air quality measurement from CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_set_environmental_data\fP (\fBccs811_handle_t\fP handle, const float temperature, const float humidity)"
.br
.RI "Writes environmental compensation factors data to CCS811 register\&. "
.ti -1c
.RI "esp_err_t \fBccs811_set_thresholds\fP (\fBccs811_handle_t\fP handle, const uint16_t low_to_med, const uint16_t med_to_high, const uint8_t hysteresis)"
.br
.RI "Writes eCO2 thresholds to CCS811 register\&. "
.ti -1c
.RI "esp_err_t \fBccs811_get_drive_mode\fP (\fBccs811_handle_t\fP handle, \fBccs811_drive_modes_t\fP *const mode)"
.br
.RI "Reads drive mode from CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_set_drive_mode\fP (\fBccs811_handle_t\fP handle, const \fBccs811_drive_modes_t\fP mode)"
.br
.RI "Writes drive mode to CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_get_firmware_mode\fP (\fBccs811_handle_t\fP handle, \fBccs811_firmware_modes_t\fP *const mode)"
.br
.RI "Reads firmware mode from CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_get_ntc_resistance\fP (\fBccs811_handle_t\fP handle, const uint32_t r_ref, uint32_t *const resistance)"
.br
.RI "Reads NTC resistance connected to CCS811 per AMS application note AN000372\&. "
.ti -1c
.RI "esp_err_t \fBccs811_get_data_status\fP (\fBccs811_handle_t\fP handle, bool *const ready)"
.br
.RI "Reads data ready status from CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_get_error_status\fP (\fBccs811_handle_t\fP handle, bool *const error)"
.br
.RI "Reads error status from CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_reset\fP (\fBccs811_handle_t\fP handle)"
.br
.RI "Issues soft-reset to CCS811\&. "
.ti -1c
.RI "esp_err_t \fBccs811_io_wake\fP (\fBccs811_handle_t\fP handle)"
.br
.RI "Wakes the CCS811 through the configured wake GPIO pin number\&. "
.ti -1c
.RI "esp_err_t \fBccs811_io_sleep\fP (\fBccs811_handle_t\fP handle)"
.br
.RI "Puts the CCS811 a sleep through the configured wake GPIO pin number\&. "
.ti -1c
.RI "esp_err_t \fBccs811_io_reset\fP (\fBccs811_handle_t\fP handle)"
.br
.RI "Resets the CCS811 through the configured reset GPIO pin number\&. "
.ti -1c
.RI "esp_err_t \fBccs811_remove\fP (\fBccs811_handle_t\fP handle)"
.br
.RI "Removes a CCS811 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBccs811_delete\fP (\fBccs811_handle_t\fP handle)"
.br
.RI "Removes an CCS811 device from master I2C bus and delete the handle\&. "
.ti -1c
.RI "const char * \fBccs811_err_to_message\fP (const ccs811_error_code_register_t error_reg)"
.br
.RI "Decodes CCS811 device error to a textual message representation\&. "
.ti -1c
.RI "const char * \fBccs811_err_to_code\fP (const ccs811_error_code_register_t error_reg)"
.br
.RI "Decodes CCS811 device error to a textual code representation\&. "
.ti -1c
.RI "const char * \fBccs811_measure_mode_description\fP (const \fBccs811_drive_modes_t\fP mode)"
.br
.RI "Decodes enumerated drive mode to a textual descriptive representation\&. "
.ti -1c
.RI "const char * \fBccs811_get_fw_version\fP (void)"
.br
.RI "Converts CCS811 firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBccs811_get_fw_version_number\fP (void)"
.br
.RI "Converts CCS811 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBens160_get_interrupt_config_register\fP (\fBens160_handle_t\fP handle, ens160_interrupt_config_register_t *const reg)"
.br
.RI "Reads interrupt configuration register from ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_set_interrupt_config_register\fP (\fBens160_handle_t\fP handle, const ens160_interrupt_config_register_t reg)"
.br
.RI "Writes interrupt configuration register to ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_get_status_register\fP (\fBens160_handle_t\fP handle, ens160_status_register_t *const reg)"
.br
.RI "Reads status register from ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_clear_command_register\fP (\fBens160_handle_t\fP handle)"
.br
.RI "Resets command to operate normal and clears general purpose registers on ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_get_compensation_registers\fP (\fBens160_handle_t\fP handle, float *const temperature, float *const humidity)"
.br
.RI "Reads temperature and humidity compensation registers from ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_set_compensation_registers\fP (\fBens160_handle_t\fP handle, const float temperature, const float humidity)"
.br
.RI "Writes temperature and humidity compensation registers to ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_get_part_id_register\fP (\fBens160_handle_t\fP handle, uint16_t *const reg)"
.br
.RI "Reads part identifier register from ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_init\fP (i2c_master_bus_handle_t master_handle, const \fBens160_config_t\fP *ens160_config, \fBens160_handle_t\fP *ens160_handle)"
.br
.RI "Initializes an ENS160 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBens160_get_measurement\fP (\fBens160_handle_t\fP handle, \fBens160_air_quality_data_t\fP *const data)"
.br
.RI "Reads calculated air quality measurements from ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_get_raw_measurement\fP (\fBens160_handle_t\fP handle, \fBens160_air_quality_raw_data_t\fP *const data)"
.br
.RI "Reads raw air quality measurements from ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_get_data_status\fP (\fBens160_handle_t\fP handle, bool *const ready)"
.br
.RI "Reads data ready status from ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_get_gpr_data_status\fP (\fBens160_handle_t\fP handle, bool *const ready)"
.br
.RI "Reads general purpose registers data ready status from ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_get_validity_status\fP (\fBens160_handle_t\fP handle, \fBens160_validity_flags_t\fP *const state)"
.br
.RI "Read validity flag status, device status and signal rating, from ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_get_error_status\fP (\fBens160_handle_t\fP handle, bool *const error)"
.br
.RI "Read error status from ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_get_mode_status\fP (\fBens160_handle_t\fP handle, bool *const mode)"
.br
.RI "Read operating mode status from ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_get_status\fP (\fBens160_handle_t\fP handle, bool *const data_ready, bool *const gpr_data_ready, \fBens160_validity_flags_t\fP *const state, bool *const error, bool *const mode)"
.br
.RI "Reads data ready, general purpose registers data ready, validity flag, and error status from ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_get_compensation_factors\fP (\fBens160_handle_t\fP handle, float *const temperature, float *const humidity)"
.br
.RI "Reads temperature and humidity compensation factors from ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_set_compensation_factors\fP (\fBens160_handle_t\fP handle, const float temperature, const float humidity)"
.br
.RI "Writes temperature and humidity compensation factors to ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_enable_standard_mode\fP (\fBens160_handle_t\fP handle)"
.br
.RI "Enables standard operating mode to ENS160 to operate as a gas sensor and respond to commands\&. "
.ti -1c
.RI "esp_err_t \fBens160_enable_idle_mode\fP (\fBens160_handle_t\fP handle)"
.br
.RI "Enables idle operating mode to ENS160 to respond to commands\&. "
.ti -1c
.RI "esp_err_t \fBens160_enable_deep_sleep_mode\fP (\fBens160_handle_t\fP handle)"
.br
.RI "Enables deep sleep operating mode to ENS160\&. "
.ti -1c
.RI "esp_err_t \fBens160_reset\fP (\fBens160_handle_t\fP handle)"
.br
.RI "Issues soft-reset and initializes ENS160 to idle mode\&. "
.ti -1c
.RI "esp_err_t \fBens160_remove\fP (\fBens160_handle_t\fP handle)"
.br
.RI "Removes an ENS160 device from master I2C bus\&. "
.ti -1c
.RI "esp_err_t \fBens160_delete\fP (\fBens160_handle_t\fP handle)"
.br
.RI "Removes an ENS160 device from master bus and frees handle\&. "
.ti -1c
.RI "\fBens160_aqi_uba_row_t\fP \fBens160_aqi_index_to_definition\fP (const \fBens160_aqi_uba_indexes_t\fP index)"
.br
.RI "Decodes ENS160 air quality index to a uba definition row\&. "
.ti -1c
.RI "const char * \fBens160_get_fw_version\fP (void)"
.br
.RI "Converts ENS160 firmware version numbers (major, minor, patch, build) into a string\&. "
.ti -1c
.RI "int32_t \fBens160_get_fw_version_number\fP (void)"
.br
.RI "Converts ENS160 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_get_serial_number_register\fP (\fBhdc1080_handle_t\fP handle, uint64_t *const reg)"
.br
.RI "Reads unique serial number register from HDC1080\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_get_manufacturer_id_register\fP (\fBhdc1080_handle_t\fP handle, uint16_t *const reg)"
.br
.RI "Reads manufacturer identifier register from HDC1080\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_get_device_id_register\fP (\fBhdc1080_handle_t\fP handle, uint16_t *const reg)"
.br
.RI "Reads device identifier register from HDC1080\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_get_configuration_register\fP (\fBhdc1080_handle_t\fP handle, hdc1080_configuration_register_t *const reg)"
.br
.RI "Reads configuration register from HDC1080\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_set_configuration_register\fP (\fBhdc1080_handle_t\fP handle, const hdc1080_configuration_register_t reg)"
.br
.RI "Writes configuration register to HDC1080\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_init\fP (i2c_master_bus_handle_t master_handle, const \fBhdc1080_config_t\fP *hdc1080_config, \fBhdc1080_handle_t\fP *hdc1080_handle)"
.br
.RI "Initializes an HDC1080 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_get_measurement\fP (\fBhdc1080_handle_t\fP handle, float *const temperature, float *const humidity)"
.br
.RI "Reads temperature and relative humidity from HDC1080\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_get_measurements\fP (\fBhdc1080_handle_t\fP handle, float *const temperature, float *const humidity, float *const dewpoint)"
.br
.RI "Reads temperature, relative humidity, and dew-point from HDC1080\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_enable_heater\fP (\fBhdc1080_handle_t\fP handle)"
.br
.RI "Enables HDC1080 heater\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_disable_heater\fP (\fBhdc1080_handle_t\fP handle)"
.br
.RI "Disables HDC1080 heater\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_get_temperature_resolution\fP (\fBhdc1080_handle_t\fP handle, \fBhdc1080_temperature_resolutions_t\fP *const resolution)"
.br
.RI "Reads temperature measurement resolution from HDC1080\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_set_temperature_resolution\fP (\fBhdc1080_handle_t\fP handle, const \fBhdc1080_temperature_resolutions_t\fP resolution)"
.br
.RI "Writes temperature measurement resolution to HDC1080\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_get_humidity_resolution\fP (\fBhdc1080_handle_t\fP handle, \fBhdc1080_humidity_resolutions_t\fP *const resolution)"
.br
.RI "Reads relative humidity measurement resolution from HDC1080\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_set_humidity_resolution\fP (\fBhdc1080_handle_t\fP handle, const \fBhdc1080_humidity_resolutions_t\fP resolution)"
.br
.RI "Writes relative humidity measurement resolution to HDC1080\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_reset\fP (\fBhdc1080_handle_t\fP handle)"
.br
.RI "Issues soft-reset to HDC1080\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_remove\fP (\fBhdc1080_handle_t\fP handle)"
.br
.RI "Removes an HDC1080 device from master I2C bus\&. "
.ti -1c
.RI "esp_err_t \fBhdc1080_delete\fP (\fBhdc1080_handle_t\fP handle)"
.br
.RI "Removes an HDC1080 device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBhdc1080_get_fw_version\fP (void)"
.br
.RI "Converts HDC1080 firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBhdc1080_get_fw_version_number\fP (void)"
.br
.RI "Converts HDC1080 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_configuration1_register\fP (\fBhmc5883l_handle_t\fP handle, hmc5883l_configuration1_register_t *const reg)"
.br
.RI "Reads configuration 1 register from HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_set_configuration1_register\fP (\fBhmc5883l_handle_t\fP handle, const hmc5883l_configuration1_register_t reg)"
.br
.RI "Writes configuration 1 register to HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_configuration2_register\fP (\fBhmc5883l_handle_t\fP handle, hmc5883l_configuration2_register_t *const reg)"
.br
.RI "Reads configuration 2 register from HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_set_configuration2_register\fP (\fBhmc5883l_handle_t\fP handle, const hmc5883l_configuration2_register_t reg)"
.br
.RI "Writes configuration 2 register to HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_mode_register\fP (\fBhmc5883l_handle_t\fP handle, hmc5883l_mode_register_t *const reg)"
.br
.RI "Reads mode register from HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_set_mode_register\fP (\fBhmc5883l_handle_t\fP handle, const hmc5883l_mode_register_t reg)"
.br
.RI "Writes mode register to HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_status_register\fP (\fBhmc5883l_handle_t\fP handle, hmc5883l_status_register_t *const reg)"
.br
.RI "Reads status register from HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_init\fP (i2c_master_bus_handle_t master_handle, const \fBhmc5883l_config_t\fP *hmc5883l_config, \fBhmc5883l_handle_t\fP *hmc5883l_handle)"
.br
.RI "Initializes an HMC5883L device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_fixed_magnetic_axes\fP (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_axes_data_t\fP *const axes_data)"
.br
.RI "Reads uncompensated axes measurements from HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_magnetic_axes\fP (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_magnetic_axes_data_t\fP *const axes_data)"
.br
.RI "Reads compensated magnetic axes measurements from HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_calibrated_offsets\fP (\fBhmc5883l_handle_t\fP handle, const \fBhmc5883l_calibration_options_t\fP option)"
.br
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_data_status\fP (\fBhmc5883l_handle_t\fP handle, bool *const ready, bool *const locked)"
.br
.RI "Reads data status from HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_mode\fP (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_modes_t\fP *const mode)"
.br
.RI "Reads operating mode setting from HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_set_mode\fP (\fBhmc5883l_handle_t\fP handle, const \fBhmc5883l_modes_t\fP mode)"
.br
.RI "Writes operating mode setting to HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_samples_averaged\fP (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_sample_averages_t\fP *const sample)"
.br
.RI "Reads samples averaged setting from HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_set_samples_averaged\fP (\fBhmc5883l_handle_t\fP handle, const \fBhmc5883l_sample_averages_t\fP sample)"
.br
.RI "Writes samples averaged setting to HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_data_rate\fP (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_data_rates_t\fP *const rate)"
.br
.RI "Reads data rate setting from HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_set_data_rate\fP (\fBhmc5883l_handle_t\fP handle, const \fBhmc5883l_data_rates_t\fP rate)"
.br
.RI "Writes data rate setting to HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_bias\fP (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_biases_t\fP *const bias)"
.br
.RI "Reads measurement mode bias setting from HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_set_bias\fP (\fBhmc5883l_handle_t\fP handle, const \fBhmc5883l_biases_t\fP bias)"
.br
.RI "Writes measurement mode bias setting to HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_gain\fP (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_gains_t\fP *const gain)"
.br
.RI "Reads gain setting from HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_set_gain\fP (\fBhmc5883l_handle_t\fP handle, const \fBhmc5883l_gains_t\fP gain)"
.br
.RI "Writes gain setting to HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_get_gain_sensitivity\fP (\fBhmc5883l_handle_t\fP handle, float *const sensitivity)"
.br
.RI "Reads gain sensitivity setting from HMC5883L\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_remove\fP (\fBhmc5883l_handle_t\fP handle)"
.br
.RI "Removes an HMC5883L device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBhmc5883l_delete\fP (\fBhmc5883l_handle_t\fP handle)"
.br
.RI "Removes an HMC5883L device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBhmc5883l_get_fw_version\fP (void)"
.br
.RI "Converts HMC5883L firmware version numbers (major, minor, patch, build) into a string\&. "
.ti -1c
.RI "int32_t \fBhmc5883l_get_fw_version_number\fP (void)"
.br
.RI "Converts HMC5883L firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBina226_get_configuration_register\fP (\fBina226_handle_t\fP handle, ina226_config_register_t *const reg)"
.br
.RI "Reads the configuration register from the INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_set_configuration_register\fP (\fBina226_handle_t\fP handle, const ina226_config_register_t reg)"
.br
.RI "Writes the configuration register to the INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_get_calibration_register\fP (\fBina226_handle_t\fP handle, uint16_t *const reg)"
.br
.RI "Reads the calibration register from the INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_set_calibration_register\fP (\fBina226_handle_t\fP handle, const uint16_t reg)"
.br
.RI "Writes the calibration register to the INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_get_mask_enable_register\fP (\fBina226_handle_t\fP handle, ina226_mask_enable_register_t *const reg)"
.br
.RI "Reads the mask/enable register from the INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_init\fP (i2c_master_bus_handle_t master_handle, const \fBina226_config_t\fP *ina226_config, \fBina226_handle_t\fP *ina226_handle)"
.br
.RI "initializes an INA226 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBina226_calibrate\fP (\fBina226_handle_t\fP handle, const float max_current, const float shunt_resistance)"
.br
.RI "Calibrates the INA266\&. "
.ti -1c
.RI "esp_err_t \fBina226_get_bus_voltage\fP (\fBina226_handle_t\fP handle, float *const voltage)"
.br
.RI "Reads bus voltage (V) from INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_get_triggered_bus_voltage\fP (\fBina226_handle_t\fP handle, float *const voltage)"
.br
.RI "Triggers and reads bus voltage (V) from INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_get_shunt_voltage\fP (\fBina226_handle_t\fP handle, float *const voltage)"
.br
.RI "Reads shunt voltage (V) from INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_get_triggered_shunt_voltage\fP (\fBina226_handle_t\fP handle, float *const voltage)"
.br
.RI "Triggers and reads shunt voltage (V) from INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_get_current\fP (\fBina226_handle_t\fP handle, float *const current)"
.br
.RI "Reads current (A) from INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_get_triggered_current\fP (\fBina226_handle_t\fP handle, float *const current)"
.br
.RI "Triggers and reads current (A) from INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_get_power\fP (\fBina226_handle_t\fP handle, float *const power)"
.br
.RI "Reads power (W) from INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_get_operating_mode\fP (\fBina226_handle_t\fP handle, \fBina226_operating_modes_t\fP *const mode)"
.br
.RI "Reads operating mode from the INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_set_operating_mode\fP (\fBina226_handle_t\fP handle, const \fBina226_operating_modes_t\fP mode)"
.br
.RI "Writes operating mode to the INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_get_averaging_mode\fP (\fBina226_handle_t\fP handle, \fBina226_averaging_modes_t\fP *const mode)"
.br
.ti -1c
.RI "esp_err_t \fBina226_set_averaging_mode\fP (\fBina226_handle_t\fP handle, const \fBina226_averaging_modes_t\fP mode)"
.br
.ti -1c
.RI "esp_err_t \fBina226_get_bus_volt_conv_time\fP (\fBina226_handle_t\fP handle, \fBina226_volt_conv_times_t\fP *const conv_time)"
.br
.ti -1c
.RI "esp_err_t \fBina226_set_bus_volt_conv_time\fP (\fBina226_handle_t\fP handle, \fBina226_volt_conv_times_t\fP *const conv_time)"
.br
.ti -1c
.RI "esp_err_t \fBina226_get_shunt_volt_conv_time\fP (\fBina226_handle_t\fP handle, \fBina226_volt_conv_times_t\fP *const conv_time)"
.br
.ti -1c
.RI "esp_err_t \fBina226_set_shunt_volt_conv_time\fP (\fBina226_handle_t\fP handle, \fBina226_volt_conv_times_t\fP *const conv_time)"
.br
.ti -1c
.RI "esp_err_t \fBina226_reset\fP (\fBina226_handle_t\fP handle)"
.br
.RI "Resets the INA226\&. "
.ti -1c
.RI "esp_err_t \fBina226_remove\fP (\fBina226_handle_t\fP handle)"
.br
.RI "Removes an INA226 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBina226_delete\fP (\fBina226_handle_t\fP handle)"
.br
.RI "Removes an INA226 device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBina226_get_fw_version\fP (void)"
.br
.RI "Converts INA226 firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBina226_get_fw_version_number\fP (void)"
.br
.RI "Converts INA226 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_control_register\fP (\fBltr390uv_handle_t\fP handle, ltr390uv_control_register_t *const reg)"
.br
.RI "Reads control register from LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_set_control_register\fP (\fBltr390uv_handle_t\fP handle, const ltr390uv_control_register_t reg)"
.br
.RI "Writes control register to LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_measure_register\fP (\fBltr390uv_handle_t\fP handle, ltr390uv_measure_register_t *const reg)"
.br
.RI "Reads ALS UVS measure register from LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_set_measure_register\fP (\fBltr390uv_handle_t\fP handle, const ltr390uv_measure_register_t reg)"
.br
.RI "Writes ALS UVS measure register to LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_gain_register\fP (\fBltr390uv_handle_t\fP handle, ltr390uv_gain_register_t *const reg)"
.br
.RI "Reads ALS UVS gain register from LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_set_gain_register\fP (\fBltr390uv_handle_t\fP handle, const ltr390uv_gain_register_t reg)"
.br
.RI "Writes ALS UVS gain register to LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_interrupt_config_register\fP (\fBltr390uv_handle_t\fP handle, ltr390uv_interrupt_config_register_t *const reg)"
.br
.RI "Reads interrupt configuration register from LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_set_interrupt_config_register\fP (\fBltr390uv_handle_t\fP handle, const ltr390uv_interrupt_config_register_t reg)"
.br
.RI "Writes interrupt configuration register to LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_status_register\fP (\fBltr390uv_handle_t\fP handle, ltr390uv_status_register_t *const reg)"
.br
.RI "Reads status register from LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_init\fP (i2c_master_bus_handle_t master_handle, const \fBltr390uv_config_t\fP *ltr390uv_config, \fBltr390uv_handle_t\fP *ltr390uv_handle)"
.br
.RI "Initializes an LTR390UV device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_ambient_light\fP (\fBltr390uv_handle_t\fP handle, float *const ambient_light)"
.br
.RI "Reads ambient light from LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_als\fP (\fBltr390uv_handle_t\fP handle, uint32_t *const sensor_counts)"
.br
.RI "Reads ALS sensor counts from LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_ultraviolet_index\fP (\fBltr390uv_handle_t\fP handle, float *const ultraviolet_index)"
.br
.RI "Reads ultraviolet index (UVI) from LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_uvs\fP (\fBltr390uv_handle_t\fP handle, uint32_t *const sensor_counts)"
.br
.RI "Reads UVS sensor counts from LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_data_status\fP (\fBltr390uv_handle_t\fP handle, bool *const ready)"
.br
.RI "Reads data ready status flag from LTR390UV\&. This flag is cleared after the register is read\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_power_status\fP (\fBltr390uv_handle_t\fP handle, bool *const power_on)"
.br
.RI "Reads power status flag from LTR390UV\&. This flag is cleared after the register is read\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_interrupt_status\fP (\fBltr390uv_handle_t\fP handle, bool *const interrupt)"
.br
.RI "Reads interrupt status flag from LTR390UV\&. This flag is cleared after the register is read\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_status\fP (\fBltr390uv_handle_t\fP handle, bool *const data_ready, bool *const power_on, bool *const interrupt)"
.br
.RI "Reads interrupt status flags from LTR390UV\&. The flags are cleared after the register is read\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_thresholds\fP (\fBltr390uv_handle_t\fP handle, uint32_t *const lower_threshold, uint32_t *const upper_threshold)"
.br
.RI "Reads UVS/ALS lower and upper thresholds from LTR390UV\&. The thresholds are used to trigger an interrupt when the light level exceeds the upper threshold or falls below the lower threshold\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_set_thresholds\fP (\fBltr390uv_handle_t\fP handle, const uint32_t lower_threshold, const uint32_t upper_threshold)"
.br
.RI "Writes UVS/ALS lower and upper thresholds to LTR390UV\&. The thresholds are used to trigger an interrupt when the light level exceeds the upper threshold or falls below the lower threshold\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_mode\fP (\fBltr390uv_handle_t\fP handle, \fBltr390uv_operation_modes_t\fP *const mode)"
.br
.RI "Reads operation mode from LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_set_mode\fP (\fBltr390uv_handle_t\fP handle, const \fBltr390uv_operation_modes_t\fP mode)"
.br
.RI "Writes operation mode to LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_resolution\fP (\fBltr390uv_handle_t\fP handle, \fBltr390uv_sensor_resolutions_t\fP *const resolution)"
.br
.RI "Reads sensor resolution from LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_set_resolution\fP (\fBltr390uv_handle_t\fP handle, const \fBltr390uv_sensor_resolutions_t\fP resolution)"
.br
.RI "Writes sensor resolution to LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_gain\fP (\fBltr390uv_handle_t\fP handle, \fBltr390uv_measurement_gains_t\fP *const gain)"
.br
.RI "Reads measurement gain from LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_set_gain\fP (\fBltr390uv_handle_t\fP handle, const \fBltr390uv_measurement_gains_t\fP gain)"
.br
.RI "Writes measurement gain to LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_get_rate\fP (\fBltr390uv_handle_t\fP handle, \fBltr390uv_measurement_rates_t\fP *const rate)"
.br
.RI "Reads measurement rate from LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_set_rate\fP (\fBltr390uv_handle_t\fP handle, const \fBltr390uv_measurement_rates_t\fP rate)"
.br
.RI "Writes measurement rate to LTR390UV\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_enable_interrupt\fP (\fBltr390uv_handle_t\fP handle, const \fBltr390uv_ls_interrupts_t\fP light_source)"
.br
.RI "Enables LTR390UV interrupts\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_disable_interrupt\fP (\fBltr390uv_handle_t\fP handle)"
.br
.RI "Disables LTR390UV interrupts\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_enable\fP (\fBltr390uv_handle_t\fP handle)"
.br
.RI "Activates LTR390UV for measurements\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_disable\fP (\fBltr390uv_handle_t\fP handle)"
.br
.RI "Places LTR390UV on standby (default)\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_reset\fP (\fBltr390uv_handle_t\fP handle)"
.br
.RI "Issues soft-reset and initializes LTR390UV\&. See datasheet for details\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_remove\fP (\fBltr390uv_handle_t\fP handle)"
.br
.RI "Removes an LTR390UV device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBltr390uv_delete\fP (\fBltr390uv_handle_t\fP handle)"
.br
.RI "Removes an LTR390UV device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBltr390uv_get_fw_version\fP (void)"
.br
.RI "Converts LTR390UV firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBltr390uv_get_fw_version_number\fP (void)"
.br
.RI "Converts LTR390UV firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_get_interrupt_status1_register\fP (\fBmax30105_handle_t\fP handle, max30105_interrupt_status1_register_t *const reg)"
.br
.RI "Reads interrupt status 1 register from MAX30105\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_get_interrupt_status2_register\fP (\fBmax30105_handle_t\fP handle, max30105_interrupt_status2_register_t *const reg)"
.br
.RI "Reads interrupt status 2 register from MAX30105\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_get_interrupt_enable1_register\fP (\fBmax30105_handle_t\fP handle, max30105_interrupt_enable1_register_t *const reg)"
.br
.RI "Reads interrupt enable 1 register from MAX30105\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_set_interrupt_enable1_register\fP (\fBmax30105_handle_t\fP handle, const max30105_interrupt_enable1_register_t reg)"
.br
.RI "Writes interrupt enable 1 register to MAX30105\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_get_interrupt_enable2_register\fP (\fBmax30105_handle_t\fP handle, max30105_interrupt_enable2_register_t *const reg)"
.br
.RI "Reads interrupt enable 2 register from MAX30105\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_set_interrupt_enable2_register\fP (\fBmax30105_handle_t\fP handle, const max30105_interrupt_enable2_register_t reg)"
.br
.RI "Writes interrupt enable 2 register to MAX30105\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_get_mode_configuration_register\fP (\fBmax30105_handle_t\fP handle, max30105_mode_configuration_register_t *const reg)"
.br
.RI "Reads mode configuration register from MAX30105\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_set_mode_configuration_register\fP (\fBmax30105_handle_t\fP handle, const max30105_mode_configuration_register_t reg)"
.br
.RI "Writes mode configuration register to MAX30105\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_init\fP (i2c_master_bus_handle_t master_handle, const \fBmax30105_config_t\fP *max30105_config, \fBmax30105_handle_t\fP *max30105_handle)"
.br
.RI "Initializes an MAX30105 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_get_optical_counts\fP (\fBmax30105_handle_t\fP handle, float *const red_count, float *const ir_count, float *const green_count)"
.br
.RI "Reads red, IR, and green LED ADC counts from MAX30105\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_get_data_status\fP (\fBmax30105_handle_t\fP handle, bool *const ready)"
.br
.RI "Reads data status from MAX30105\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_get_control_mode\fP (\fBmax30105_handle_t\fP handle, \fBmax30105_control_modes_t\fP *const control_mode)"
.br
.RI "Reads control mode setting from MAX30105\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_set_control_mode\fP (\fBmax30105_handle_t\fP handle, const \fBmax30105_control_modes_t\fP control_mode)"
.br
.RI "Writes control mode setting to MAX30105\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_remove\fP (\fBmax30105_handle_t\fP handle)"
.br
.RI "Removes an MAX30105 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBmax30105_delete\fP (\fBmax30105_handle_t\fP handle)"
.br
.RI "Removes an MAX30105 device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBmax30105_get_fw_version\fP (void)"
.br
.RI "Converts MAX30105 firmware version numbers (major, minor, patch, build) into a string\&. "
.ti -1c
.RI "int32_t \fBmax30105_get_fw_version_number\fP (void)"
.br
.RI "Converts MAX30105 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_config_register\fP (\fBmlx90614_handle_t\fP handle, mlx90614_config_register_t *const reg)"
.br
.RI "Reads configuration register from MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_set_config_register\fP (\fBmlx90614_handle_t\fP handle, const mlx90614_config_register_t reg)"
.br
.RI "Writes configuration register to MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_pwmctrl_register\fP (\fBmlx90614_handle_t\fP handle, mlx90614_pwmctrl_register_t *const reg)"
.br
.RI "Reads PWM control register from MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_set_pwmctrl_register\fP (\fBmlx90614_handle_t\fP handle, const mlx90614_pwmctrl_register_t reg)"
.br
.RI "Writes PWM control register to MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_flags_register\fP (\fBmlx90614_handle_t\fP handle, mlx90614_flags_register_t *const reg)"
.br
.RI "Reads flags register from MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_init\fP (i2c_master_bus_handle_t master_handle, const \fBmlx90614_config_t\fP *mlx90614_config, \fBmlx90614_handle_t\fP *mlx90614_handle)"
.br
.RI "Initializes an MLX90614 device onto the master bus\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_temperatures\fP (\fBmlx90614_handle_t\fP handle, float *const ambient_temperature, float *const object1_temperature, float *const object2_temperature)"
.br
.RI "Reads all three temperatures (ambient, object 1 and object 2) from the MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_ambient_temperature\fP (\fBmlx90614_handle_t\fP handle, float *const ambient_temperature)"
.br
.RI "Reads the ambient temperature from MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_object1_temperature\fP (\fBmlx90614_handle_t\fP handle, float *const object1_temperature)"
.br
.RI "Reads object 1 temperature from mlx90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_object2_temperature\fP (\fBmlx90614_handle_t\fP handle, float *const object2_temperature)"
.br
.RI "Reads object 2 temperature from MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_ir_channel1\fP (\fBmlx90614_handle_t\fP handle, int16_t *const ir_channel1)"
.br
.RI "Reads IR channel 1 from MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_ir_channel2\fP (\fBmlx90614_handle_t\fP handle, int16_t *const ir_channel2)"
.br
.RI "Reads IR channel 2 from MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_ambient_temperature_range\fP (\fBmlx90614_handle_t\fP handle, float *const ambient_temperature_range)"
.br
.RI "Reads ambient temperature range from MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_emissivity\fP (\fBmlx90614_handle_t\fP handle, float *const coefficient)"
.br
.RI "Reads emissivity coefficient (0\&.1 to 1\&.0) setting from MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_set_emissivity\fP (\fBmlx90614_handle_t\fP handle, const float coefficient)"
.br
.RI "Writes emissivity coefficient (0\&.1 to 1\&.0) setting to MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_object_maximum_temperature\fP (\fBmlx90614_handle_t\fP handle, float *const temperature)"
.br
.RI "Reads maximum object temperature setting from MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_set_object_maximum_temperature\fP (\fBmlx90614_handle_t\fP handle, const float temperature)"
.br
.RI "Writes maximum object temperature setting to MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_object_minimum_temperature\fP (\fBmlx90614_handle_t\fP handle, float *const temperature)"
.br
.RI "Reads minimum object temperature setting from MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_set_object_minimum_temperature\fP (\fBmlx90614_handle_t\fP handle, const float temperature)"
.br
.RI "Writes minimum object temperature setting to MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_get_address\fP (\fBmlx90614_handle_t\fP handle, uint8_t *const address)"
.br
.RI "Reads I2C address setting from MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_set_address\fP (\fBmlx90614_handle_t\fP handle, const uint8_t address)"
.br
.RI "Writes I2C address setting to MLX90614\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_sleep\fP (\fBmlx90614_handle_t\fP handle)"
.br
.RI "Puts the MLX90614 into sleep mode\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_wakeup\fP (\fBmlx90614_handle_t\fP handle)"
.br
.RI "Wakes-up the MLX90614 from sleep mode\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_remove\fP (\fBmlx90614_handle_t\fP handle)"
.br
.RI "Removes an MLX90614 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBmlx90614_delete\fP (\fBmlx90614_handle_t\fP handle)"
.br
.RI "Removes an MLX90614 device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBmlx90614_get_fw_version\fP (void)"
.br
.RI "Converts MLX90614 firmware version numbers (major, minor, patch, build) into a string\&. "
.ti -1c
.RI "int32_t \fBmlx90614_get_fw_version_number\fP (void)"
.br
.RI "Converts MLX90614 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_get_status_register\fP (\fBmmc56x3_handle_t\fP handle, mmc56x3_status_register_t *const reg)"
.br
.RI "Reads status register from MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_set_control0_register\fP (\fBmmc56x3_handle_t\fP handle, const mmc56x3_control0_register_t reg)"
.br
.RI "Writes control 0 register to MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_set_control1_register\fP (\fBmmc56x3_handle_t\fP handle, const mmc56x3_control1_register_t reg)"
.br
.RI "Writes control 1 register to MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_set_control2_register\fP (\fBmmc56x3_handle_t\fP handle, const mmc56x3_control2_register_t reg)"
.br
.RI "Writes control 2 register to MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_get_product_id_register\fP (\fBmmc56x3_handle_t\fP handle, uint8_t *const reg)"
.br
.RI "Reads product identifier register from MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_init\fP (i2c_master_bus_handle_t master_handle, const \fBmmc56x3_config_t\fP *mmc56x3_config, \fBmmc56x3_handle_t\fP *mmc56x3_handle)"
.br
.RI "Initializes an MMC56X3 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_get_temperature\fP (\fBmmc56x3_handle_t\fP handle, float *const temperature)"
.br
.RI "Reads temperature from MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_get_magnetic_axes\fP (\fBmmc56x3_handle_t\fP handle, \fBmmc56x3_magnetic_axes_data_t\fP *const axes_data)"
.br
.RI "Reads magnetic axes (x, y, z axes) from MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_get_temperature_data_status\fP (\fBmmc56x3_handle_t\fP handle, bool *const ready)"
.br
.RI "Reads temperature data status from MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_get_magnetic_data_status\fP (\fBmmc56x3_handle_t\fP handle, bool *const ready)"
.br
.RI "Reads magnetic data status from MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_get_data_status\fP (\fBmmc56x3_handle_t\fP handle, bool *const magnetic_ready, bool *const temperature_ready)"
.br
.RI "Reads magnetic and temperature data status from MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_set_measure_mode\fP (\fBmmc56x3_handle_t\fP handle, const bool continuous)"
.br
.RI "Writes measurement mode to MMC56X3\&. The data rate must be configured to a non-zero value before enabling continuous measurements\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_set_data_rate\fP (\fBmmc56x3_handle_t\fP handle, const uint16_t rate)"
.br
.RI "Writes data rate to MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_set_measure_bandwidth\fP (\fBmmc56x3_handle_t\fP handle, const \fBmmc56x3_measurement_times_t\fP bandwidth)"
.br
.RI "Writes measurement bandwidth to MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_enable_periodical_set\fP (\fBmmc56x3_handle_t\fP handle, const \fBmmc56x3_measurement_samples_t\fP samples)"
.br
.RI "Enables MMC56X3 periodical set when the number of samples threshold is met\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_disable_periodical_set\fP (\fBmmc56x3_handle_t\fP handle)"
.br
.RI "Disables MMC56X3 periodical set\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_set_selftest_thresholds\fP (\fBmmc56x3_handle_t\fP handle, const \fBmmc56x3_selftest_axes_data_t\fP axes_data)"
.br
.RI "Writes axes configuration to MMC56X3 to enable or disable axes (x, y, z), axes are enabled by default\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_get_selftest_set_values\fP (\fBmmc56x3_handle_t\fP handle, \fBmmc56x3_selftest_axes_data_t\fP *const axes_data)"
.br
.RI "Reads self-test axes data set-values from MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_set_selftest_set_values\fP (\fBmmc56x3_handle_t\fP handle, const \fBmmc56x3_selftest_axes_data_t\fP axes_data)"
.br
.RI "Writes self-test axes data set-values to MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_magnetic_set_reset\fP (\fBmmc56x3_handle_t\fP handle)"
.br
.RI "Pulses large currents through the sense coils to clear any offset\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_reset\fP (\fBmmc56x3_handle_t\fP handle)"
.br
.RI "Issues soft-reset to MMC56X3\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_remove\fP (\fBmmc56x3_handle_t\fP handle)"
.br
.RI "Removes an MMC56X3 device from master I2C bus\&. "
.ti -1c
.RI "esp_err_t \fBmmc56x3_delete\fP (\fBmmc56x3_handle_t\fP handle)"
.br
.RI "Removes an MMC56X3 device from master I2C bus and delete the handle\&. "
.ti -1c
.RI "float \fBmmc56x3_convert_to_heading\fP (const \fBmmc56x3_magnetic_axes_data_t\fP axes_data)"
.br
.RI "Converts magnetic axes data to a heading\&. See Honeywell application note AN-203 for details\&. "
.ti -1c
.RI "float \fBmmc56x3_convert_to_true_heading\fP (const float declination, const \fBmmc56x3_magnetic_axes_data_t\fP axes_data)"
.br
.RI "Converts magnetic axes data with magnetic declination to a true heading\&. See Honeywell application note AN-203 for details\&. "
.ti -1c
.RI "const char * \fBmmc56x3_get_fw_version\fP (void)"
.br
.RI "Converts MMC56X3 firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBmmc56x3_get_fw_version_number\fP (void)"
.br
.RI "Converts MMC56X3 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_sample_rate_divider_register\fP (\fBmpu6050_handle_t\fP handle, uint8_t *const reg)"
.br
.RI "Reads sample rate divider register from MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_set_sample_rate_divider_register\fP (\fBmpu6050_handle_t\fP handle, const uint8_t reg)"
.br
.RI "Writes sample rate divider register to MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_config_register\fP (\fBmpu6050_handle_t\fP handle, mpu6050_config_register_t *const reg)"
.br
.RI "Reads configuration register from MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_set_config_register\fP (\fBmpu6050_handle_t\fP handle, const mpu6050_config_register_t reg)"
.br
.RI "Writes configuration register to MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_gyro_config_register\fP (\fBmpu6050_handle_t\fP handle, mpu6050_gyro_config_register_t *const reg)"
.br
.RI "Reads gyroscope configuration register from MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_set_gyro_config_register\fP (\fBmpu6050_handle_t\fP handle, const mpu6050_gyro_config_register_t reg)"
.br
.RI "Writes gyroscope configuration register to MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_accel_config_register\fP (\fBmpu6050_handle_t\fP handle, mpu6050_accel_config_register_t *const reg)"
.br
.RI "Reads accelerometer configuration register from MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_set_accel_config_register\fP (\fBmpu6050_handle_t\fP handle, const mpu6050_accel_config_register_t reg)"
.br
.RI "Writes accelerometer configuration register to MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_interrupt_enable_register\fP (\fBmpu6050_handle_t\fP handle, mpu6050_interrupt_enable_register_t *const reg)"
.br
.RI "Reads interrupt enable register from MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_set_interrupt_enable_register\fP (\fBmpu6050_handle_t\fP handle, const mpu6050_interrupt_enable_register_t reg)"
.br
.RI "Writes interrupt enable register to MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_interrupt_pin_config_register\fP (\fBmpu6050_handle_t\fP handle, mpu6050_interrupt_pin_config_register_t *const reg)"
.br
.RI "Reads interrupt pin configuration register from MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_set_interrupt_pin_config_register\fP (\fBmpu6050_handle_t\fP handle, const mpu6050_interrupt_pin_config_register_t reg)"
.br
.RI "Writes interrupt pin configuration register to MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_interrupt_status_register\fP (\fBmpu6050_handle_t\fP handle, mpu6050_interrupt_status_register_t *const reg)"
.br
.RI "Reads interrupt status register from MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_signal_path_reset_register\fP (\fBmpu6050_handle_t\fP handle, mpu6050_signal_path_reset_register_t *const reg)"
.br
.RI "Reads signal path reset register from MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_set_signal_path_reset_register\fP (\fBmpu6050_handle_t\fP handle, const mpu6050_signal_path_reset_register_t reg)"
.br
.RI "Writes signal path reset register to MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_user_control_register\fP (\fBmpu6050_handle_t\fP handle, mpu6050_user_control_register_t *const reg)"
.br
.RI "Reads user control register from MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_set_user_control_register\fP (\fBmpu6050_handle_t\fP handle, const mpu6050_user_control_register_t reg)"
.br
.RI "Writes user control register to MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_power_management1_register\fP (\fBmpu6050_handle_t\fP handle, mpu6050_power_management1_register_t *const reg)"
.br
.RI "Reads power management 1 register from MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_set_power_management1_register\fP (\fBmpu6050_handle_t\fP handle, const mpu6050_power_management1_register_t reg)"
.br
.RI "Writes power management 1 register to MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_power_management2_register\fP (\fBmpu6050_handle_t\fP handle, mpu6050_power_management2_register_t *const reg)"
.br
.RI "Reads power management 2 register from MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_set_power_management2_register\fP (\fBmpu6050_handle_t\fP handle, const mpu6050_power_management2_register_t reg)"
.br
.RI "Writes power management 2 register to MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_who_am_i_register\fP (\fBmpu6050_handle_t\fP handle, mpu6050_who_am_i_register_t *const reg)"
.br
.RI "Reads who am i (i\&.e\&. device identifier) register from MPU6050\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_configure_interrupts\fP (\fBmpu6050_handle_t\fP handle, const \fBmpu6050_config_t\fP *const config)"
.br
.RI "Configures interrupt pin behavior and setup target GPIO\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_init\fP (i2c_master_bus_handle_t master_handle, const \fBmpu6050_config_t\fP *mpu6050_config, \fBmpu6050_handle_t\fP *mpu6050_handle)"
.br
.RI "Initializes an MPU6050 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_status\fP (\fBmpu6050_handle_t\fP handle, bool *fifo_overflow, bool *i2c_master, bool *data_ready)"
.br
.RI "Reads status for FIFO buffer overflow, I2C master, and data ready interrupts\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_data_status\fP (\fBmpu6050_handle_t\fP handle, bool *ready)"
.br
.RI "Reads interrupt status for data ready interrupt\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_motion\fP (\fBmpu6050_handle_t\fP handle, \fBmpu6050_gyro_data_axes_t\fP *gyro_data, \fBmpu6050_accel_data_axes_t\fP *accel_data, float *temperature)"
.br
.RI "Reads gyroscope, accelerometer, and temperature measurements\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_get_rotation\fP (\fBmpu6050_handle_t\fP handle, \fBmpu6050_gyro_data_axes_t\fP *gyro_data)"
.br
.ti -1c
.RI "esp_err_t \fBmpu6050_get_acceleration\fP (\fBmpu6050_handle_t\fP handle, \fBmpu6050_accel_data_axes_t\fP *accel_data)"
.br
.ti -1c
.RI "esp_err_t \fBmpu6050_get_temperature\fP (\fBmpu6050_handle_t\fP handle, float *temperature)"
.br
.ti -1c
.RI "esp_err_t \fBmpu6050_reset_signal_condition\fP (\fBmpu6050_handle_t\fP handle)"
.br
.ti -1c
.RI "esp_err_t \fBmpu6050_reset_fifo\fP (\fBmpu6050_handle_t\fP handle)"
.br
.ti -1c
.RI "esp_err_t \fBmpu6050_reset_sensors\fP (\fBmpu6050_handle_t\fP handle)"
.br
.ti -1c
.RI "esp_err_t \fBmpu6050_register_isr\fP (\fBmpu6050_handle_t\fP handle, const \fBmpu6050_isr_t\fP isr)"
.br
.RI "Registers an Interrupt Service Routine to handle MPU6050 interrupts\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_reset\fP (\fBmpu6050_handle_t\fP handle)"
.br
.RI "Issues soft-reset to MPU6050 and initializes MPU6050 device handle registers\&. However, device configuration registers must be configured before reading data registers\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_remove\fP (\fBmpu6050_handle_t\fP handle)"
.br
.RI "Removes an MPU6050 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBmpu6050_delete\fP (\fBmpu6050_handle_t\fP handle)"
.br
.RI "Removes an MPU6050 device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBmpu6050_get_fw_version\fP (void)"
.br
.RI "Converts MPU6050 firmware version numbers (major, minor, patch, build) into a string\&. "
.ti -1c
.RI "int32_t \fBmpu6050_get_fw_version_number\fP (void)"
.br
.RI "Converts MPU6050 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBsgp4x_init\fP (i2c_master_bus_handle_t master_handle, const \fBsgp4x_config_t\fP *sgp4x_config, \fBsgp4x_handle_t\fP *sgp4x_handle)"
.br
.RI "Initializes an SGP4X device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBsgp4x_execute_compensated_conditioning\fP (\fBsgp4x_handle_t\fP handle, const float temperature, const float humidity, uint16_t *sraw_voc)"
.br
.RI "Starts the conditioning with temperature and humidity compensation, i\&.e\&., the VOC pixel will be operated at the same temperature as it is by calling the sgp41_measure_raw_signals function while the NOx pixel will be operated at a different temperature for conditioning\&. The conditioning should be ran when the device is initially powered for 10-seconds but do not run the conditioning longer than 10-seconds, otherwise damage may occur to the SGP4X\&. "
.ti -1c
.RI "esp_err_t \fBsgp4x_execute_conditioning\fP (\fBsgp4x_handle_t\fP handle, uint16_t *sraw_voc)"
.br
.RI "Starts the conditioning, i\&.e\&., the VOC pixel will be operated at the same temperature as it is by calling the sgp41_measure_raw_signals function while the NOx pixel will be operated at a different temperature for conditioning\&. The conditioning should be ran when the device is initially powered for 10-seconds but do not run the conditioning longer than 10-seconds, otherwise damage may occur to the SGP4X\&. "
.ti -1c
.RI "esp_err_t \fBsgp4x_measure_compensated_signals\fP (\fBsgp4x_handle_t\fP handle, const float temperature, const float humidity, uint16_t *sraw_voc, uint16_t *sraw_nox)"
.br
.RI "Starts and/or continues the VOC and NOX measurement mode with temperature and humidity compensation\&. "
.ti -1c
.RI "esp_err_t \fBsgp4x_measure_signals\fP (\fBsgp4x_handle_t\fP handle, uint16_t *sraw_voc, uint16_t *sraw_nox)"
.br
.RI "Starts and/or continues the VOC and NOX measurement mode using default temperature and humidity compensation\&. "
.ti -1c
.RI "esp_err_t \fBsgp4x_execute_self_test\fP (\fBsgp4x_handle_t\fP handle, sgp4x_self_test_result_t *const result)"
.br
.RI "Performs the built-in self-test that checks for integrity of both hotplate and MOX material\&. "
.ti -1c
.RI "esp_err_t \fBsgp4x_turn_heater_off\fP (\fBsgp4x_handle_t\fP handle)"
.br
.RI "Turns the hotplate off, stops the measurement, and SGP4X enters idle mode\&. "
.ti -1c
.RI "esp_err_t \fBsgp4x_reset\fP (\fBsgp4x_handle_t\fP handle)"
.br
.RI "Issues soft-reset and initializes SGP4X\&. See datasheet for details\&. "
.ti -1c
.RI "esp_err_t \fBsgp4x_remove\fP (\fBsgp4x_handle_t\fP handle)"
.br
.RI "Removes an SGP4X device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBsgp4x_delete\fP (\fBsgp4x_handle_t\fP handle)"
.br
.RI "Removes an SGP4X device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBsgp4x_get_fw_version\fP (void)"
.br
.RI "Converts SGP4X firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBsgp4x_get_fw_version_number\fP (void)"
.br
.RI "Converts SGP4X firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBsht4x_init\fP (const i2c_master_bus_handle_t master_handle, const \fBsht4x_config_t\fP *sht4x_config, \fBsht4x_handle_t\fP *const sht4x_handle)"
.br
.RI "Initializes an SHT4X device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBsht4x_get_measurement\fP (\fBsht4x_handle_t\fP handle, float *const temperature, float *const humidity)"
.br
.RI "Reads high-level measurements from SHT4X\&. This is a blocking function\&. "
.ti -1c
.RI "esp_err_t \fBsht4x_get_measurements\fP (\fBsht4x_handle_t\fP handle, float *const temperature, float *const humidity, float *const dewpoint)"
.br
.RI "Similar to \fRi2c_sht4x_read_measurement\fP but it includes the dewpoint temperature in the results\&. "
.ti -1c
.RI "esp_err_t \fBsht4x_get_repeat_mode\fP (\fBsht4x_handle_t\fP handle, \fBsht4x_repeat_modes_t\fP *const mode)"
.br
.RI "Reads measurement repeatability mode setting from SHT4X\&. "
.ti -1c
.RI "esp_err_t \fBsht4x_set_repeat_mode\fP (\fBsht4x_handle_t\fP handle, const \fBsht4x_repeat_modes_t\fP mode)"
.br
.RI "Writes measurement repeatability mode setting to SHT4X\&. "
.ti -1c
.RI "esp_err_t \fBsht4x_get_heater_mode\fP (\fBsht4x_handle_t\fP handle, \fBsht4x_heater_modes_t\fP *const mode)"
.br
.RI "Reads measurement heater mode setting from SHT4X\&. "
.ti -1c
.RI "esp_err_t \fBsht4x_set_heater_mode\fP (\fBsht4x_handle_t\fP handle, const \fBsht4x_heater_modes_t\fP mode)"
.br
.RI "Writes measurement heater mode setting to SHT4X\&. "
.ti -1c
.RI "esp_err_t \fBsht4x_reset\fP (\fBsht4x_handle_t\fP handle)"
.br
.RI "Issues soft-reset to SHT4X\&. "
.ti -1c
.RI "esp_err_t \fBsht4x_remove\fP (\fBsht4x_handle_t\fP handle)"
.br
.RI "Removes an SHT4X device from master I2C bus\&. "
.ti -1c
.RI "esp_err_t \fBsht4x_delete\fP (\fBsht4x_handle_t\fP handle)"
.br
.RI "Removes an SHT4X device from master I2C bus and delete the handle\&. "
.ti -1c
.RI "const char * \fBsht4x_get_fw_version\fP (void)"
.br
.RI "Converts SHT4X firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBsht4x_get_fw_version_number\fP (void)"
.br
.RI "Converts SHT4X firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_load_bitmap_font\fP (const uint8_t *font, int encoding, uint8_t *bitmap, \fBssd1306_bdf_font_t\fP *const bdf_font)"
.br
.RI "Loads a BDF bitmap font and BDF font structure from a font file\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_bdf_text\fP (\fBssd1306_handle_t\fP handle, const uint8_t *font, const char *text, int xpos, int ypos)"
.br
.RI "Displays text on the SSD1306 with BDF font support\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_bdf_code\fP (\fBssd1306_handle_t\fP handle, const uint8_t *font, int code, int xpos, int ypos)"
.br
.RI "Displays BDF font code on the SSD1306\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_enable_display\fP (\fBssd1306_handle_t\fP handle)"
.br
.RI "Turns SSD1306 display panel on\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_disable_display\fP (\fBssd1306_handle_t\fP handle)"
.br
.RI "Turns SSD1306 display panel off (sleep mode)\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_pages\fP (\fBssd1306_handle_t\fP handle)"
.br
.RI "Displays segment data for each page supported by the SSD1306 display panel\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_set_pages\fP (\fBssd1306_handle_t\fP handle, uint8_t *buffer)"
.br
.RI "Sets segment data for each page supported by the SSD1306 display panel\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_get_pages\fP (\fBssd1306_handle_t\fP handle, uint8_t *buffer)"
.br
.RI "Gets segment data for each page supported by the SSD1306 display panel\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_set_pixel\fP (\fBssd1306_handle_t\fP handle, uint8_t xpos, uint8_t ypos, bool invert)"
.br
.RI "Sets SSD1306 pages and segments data for a pixel\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_set_line\fP (\fBssd1306_handle_t\fP handle, uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, bool invert)"
.br
.RI "Sets SSD1306 pages and segments data for a line\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_set_circle\fP (\fBssd1306_handle_t\fP handle, uint8_t x0, uint8_t y0, uint8_t r, bool invert)"
.br
.RI "Sets SSD1306 pages and segments data for a circle\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_circle\fP (\fBssd1306_handle_t\fP handle, uint8_t x0, uint8_t y0, uint8_t r, bool invert)"
.br
.RI "Sets SSD1306 pages and segments data for a circle and display's the circle\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_filled_circle\fP (\fBssd1306_handle_t\fP handle, uint8_t x0, uint8_t y0, uint8_t r, bool invert)"
.br
.RI "Sets SSD1306 pages and segments data for a filled circle and display's the filled circle\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_set_rectangle\fP (\fBssd1306_handle_t\fP handle, uint8_t x, uint8_t y, uint8_t w, uint8_t h, bool invert)"
.br
.RI "Sets SSD1306 pages and segments data for a rectangle\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_rectangle\fP (\fBssd1306_handle_t\fP handle, uint8_t x, uint8_t y, uint8_t w, uint8_t h, bool invert)"
.br
.RI "Sets SSD1306 pages and segments data for a rectangle and display's the rectangle\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_filled_rectangle\fP (\fBssd1306_handle_t\fP handle, uint8_t x, uint8_t y, uint8_t w, uint8_t h, bool invert)"
.br
.RI "Sets SSD1306 pages and segments data for a filled rectangle and display's the filled rectangle\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_set_contrast\fP (\fBssd1306_handle_t\fP handle, uint8_t contrast)"
.br
.RI "Sets contrast of the SSD1306 display panel\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_set_bitmap\fP (\fBssd1306_handle_t\fP handle, uint8_t xpos, uint8_t ypos, const uint8_t *bitmap, uint8_t width, uint8_t height, bool invert)"
.br
.RI "Sets SSD1306 pages and segments data for a bitmap\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_bitmap\fP (\fBssd1306_handle_t\fP handle, uint8_t xpos, uint8_t ypos, const uint8_t *bitmap, uint8_t width, uint8_t height, bool invert)"
.br
.RI "Displays a bitmap on the SSD1306\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_image\fP (\fBssd1306_handle_t\fP handle, uint8_t page, uint8_t segment, const uint8_t *image, uint8_t width)"
.br
.RI "Displays an image by page and segment on the SSD1306\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_text\fP (\fBssd1306_handle_t\fP handle, uint8_t page, const char *text, bool invert)"
.br
.RI "Displays text by page on the SSD1306 with a maximum of 16-characters\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_text_x2\fP (\fBssd1306_handle_t\fP handle, uint8_t page, const char *text, bool invert)"
.br
.RI "Displays text x2 larger by page on the SSD1306\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_text_x3\fP (\fBssd1306_handle_t\fP handle, uint8_t page, const char *text, bool invert)"
.br
.RI "Displays text x3 larger by page on the SSD1306\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_textbox_banner\fP (\fBssd1306_handle_t\fP handle, uint8_t page, uint8_t segment, const char *text, uint8_t box_width, bool invert, uint8_t delay)"
.br
.RI "Displays scrolling text within a box as banner by page and segment on the SSD1306 with a maximum of 100-characters\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_textbox_ticker\fP (\fBssd1306_handle_t\fP handle, uint8_t page, uint8_t segment, const char *text, uint8_t box_width, bool invert, uint8_t delay)"
.br
.RI "Displays scrolling text within a box as a ticker by page and segment on the SSD1306 with a maximum of 100-characters\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_clear_display_page\fP (\fBssd1306_handle_t\fP handle, uint8_t page, bool invert)"
.br
.RI "Clears a page from the SSD1306 display\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_clear_display\fP (\fBssd1306_handle_t\fP handle, bool invert)"
.br
.RI "Clears the entire SSD1306 display\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_set_hardware_scroll\fP (\fBssd1306_handle_t\fP handle, \fBssd1306_scroll_types_t\fP scroll, \fBssd1306_scroll_frames_t\fP frame_frequency)"
.br
.RI "Sets SSD1306 scroll orientation and frame frequency for hardware based scrolling text\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_set_software_scroll\fP (\fBssd1306_handle_t\fP handle, uint8_t start, uint8_t end)"
.br
.RI "Sets SSD1306 start and end page for software based scrolling text\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_software_scroll_text\fP (\fBssd1306_handle_t\fP handle, const char *text, bool invert)"
.br
.RI "Displays software based scrolling text on the SSD1306\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_clear_display_software_scroll\fP (\fBssd1306_handle_t\fP handle)"
.br
.RI "Clears software based scrolling text from SSD1306 display\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_wrap_around\fP (\fBssd1306_handle_t\fP handle, \fBssd1306_scroll_types_t\fP scroll, uint8_t start, uint8_t end, int8_t delay)"
.br
.RI "Sets SSD1306 scroll orientation, start and end pages to wrap around the display\&. "
.ti -1c
.RI "uint8_t \fBssd1306_copy_bit\fP (uint8_t src, uint8_t src_bits, uint8_t dst, uint8_t dst_bits)"
.br
.RI "Copies bit from source to destination\&. "
.ti -1c
.RI "void \fBssd1306_invert_buffer\fP (uint8_t *buf, size_t blen)"
.br
.RI "Inverts the buffer data\&. "
.ti -1c
.RI "void \fBssd1306_flip_buffer\fP (uint8_t *buf, size_t blen)"
.br
.RI "Flips the buffer data (upsidedown)\&. "
.ti -1c
.RI "uint8_t \fBssd1306_rotate_byte\fP (uint8_t ch1)"
.br
.RI "Rotates 8-bits, as an example, 0x12 becomes 0x48\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_display_fadeout\fP (\fBssd1306_handle_t\fP handle)"
.br
.RI "SSD1306 display is faded out and cleared\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_init\fP (i2c_master_bus_handle_t master_handle, const \fBssd1306_config_t\fP *ssd1306_config, \fBssd1306_handle_t\fP *ssd1306_handle)"
.br
.RI "Initializes an SSD1306 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_remove\fP (\fBssd1306_handle_t\fP handle)"
.br
.RI "Removes an SSD1306 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBssd1306_delete\fP (\fBssd1306_handle_t\fP handle)"
.br
.RI "Removes an SSD1306 device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBssd1306_get_fw_version\fP (void)"
.br
.RI "Converts SSD1306 firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBssd1306_get_fw_version_number\fP (void)"
.br
.RI "Converts SSD1306 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBtbi2cxxx_init\fP (i2c_master_bus_handle_t master_handle, const \fBtbi2cxxx_config_t\fP *tbi2cxxx_config, \fBtbi2cxxx_handle_t\fP *tbi2cxxx_handle)"
.br
.RI "Initializes an TBI2CXXX device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBtbi2cxxx_get_temperatures\fP (\fBtbi2cxxx_handle_t\fP handle, float *const ambient_temperature, float *const object_temperature)"
.br
.RI "Reads ambient and object temperatures from TBI2CXXX\&. "
.ti -1c
.RI "esp_err_t \fBtbi2cxxx_get_ambient_temperature\fP (\fBtbi2cxxx_handle_t\fP handle, float *const temperature)"
.br
.RI "Reads ambient temperature from TBI2CXXX\&. "
.ti -1c
.RI "esp_err_t \fBtbi2cxxx_get_object_temperature\fP (\fBtbi2cxxx_handle_t\fP handle, float *const temperature)"
.br
.RI "Reads object temperature from TBI2CXXX\&. "
.ti -1c
.RI "esp_err_t \fBtbi2cxxx_get_emissivity\fP (\fBtbi2cxxx_handle_t\fP handle, float *const coefficient)"
.br
.RI "Reads emissivity coefficient setting from TBI2CXXX\&. "
.ti -1c
.RI "esp_err_t \fBtbi2cxxx_set_emissivity\fP (\fBtbi2cxxx_handle_t\fP handle, const float coefficient)"
.br
.RI "Writes emissivity coefficient setting to TBI2CXXX\&. "
.ti -1c
.RI "esp_err_t \fBtbi2cxxx_remove\fP (\fBtbi2cxxx_handle_t\fP handle)"
.br
.RI "Removes an TBI2CXXX device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBtbi2cxxx_delete\fP (\fBtbi2cxxx_handle_t\fP handle)"
.br
.RI "Removes an TBI2CXXX device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBtbi2cxxx_get_fw_version\fP (void)"
.br
.RI "Converts TBI2CXXX firmware version numbers (major, minor, patch, build) into a string\&. "
.ti -1c
.RI "int32_t \fBtbi2cxxx_get_fw_version_number\fP (void)"
.br
.RI "Converts TBI2CXXX firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBtlv493d_init\fP (i2c_master_bus_handle_t master_handle, const \fBtlv493d_config_t\fP *tlv493d_config, \fBtlv493d_handle_t\fP *tlv493d_handle)"
.br
.RI "Initializes an TLV493D device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBtlv493d_get_data\fP (\fBtlv493d_handle_t\fP handle, \fBtlv493d_data_t\fP *const data)"
.br
.ti -1c
.RI "esp_err_t \fBtlv493d_get_data_status\fP (\fBtlv493d_handle_t\fP handle, bool *const ready)"
.br
.ti -1c
.RI "esp_err_t \fBtlv493d_power_down\fP (\fBtlv493d_handle_t\fP handle)"
.br
.ti -1c
.RI "esp_err_t \fBtlv493d_power_up\fP (\fBtlv493d_handle_t\fP handle)"
.br
.ti -1c
.RI "esp_err_t \fBtlv493d_reset\fP (\fBtlv493d_handle_t\fP handle)"
.br
.RI "Issues soft-reset and initializes TLV493D\&. See datasheet for details\&. "
.ti -1c
.RI "esp_err_t \fBtlv493d_remove\fP (\fBtlv493d_handle_t\fP handle)"
.br
.RI "Removes an TLV493D device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBtlv493d_delete\fP (\fBtlv493d_handle_t\fP handle)"
.br
.RI "Removes an TLV493D device from master bus and frees handle\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_get_configuration_register\fP (\fBveml6040_handle_t\fP handle, veml6040_config_register_t *const reg)"
.br
.RI "Reads configuration register from VEML6040\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_set_configuration_register\fP (\fBveml6040_handle_t\fP handle, const veml6040_config_register_t reg)"
.br
.RI "Writes configuration register to VEML6040\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_init\fP (i2c_master_bus_handle_t master_handle, const \fBveml6040_config_t\fP *veml6040_config, \fBveml6040_handle_t\fP *veml6040_handle)"
.br
.RI "Initializes an VEML6040 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_get_red_als\fP (\fBveml6040_handle_t\fP handle, float *const als)"
.br
.RI "Reads red illuminance channel from VEML6040\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_get_green_als\fP (\fBveml6040_handle_t\fP handle, float *const als)"
.br
.RI "Reads green illuminance channel from VEML6040\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_get_blue_als\fP (\fBveml6040_handle_t\fP handle, float *const als)"
.br
.RI "Reads blue illuminance channel from VEML6040\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_get_white_als\fP (\fBveml6040_handle_t\fP handle, float *const als)"
.br
.RI "Reads white illuminance channel from VEML6040\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_get_als\fP (\fBveml6040_handle_t\fP handle, float *const red_als, float *const green_als, float *const blue_als, float *const white_als)"
.br
.RI "Reads red, green, blue, and white illuminance channels from VEML6040\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_get_integration_time\fP (\fBveml6040_handle_t\fP handle, \fBveml6040_integration_times_t\fP *const integration_time)"
.br
.RI "Reads integration time from VEML6040\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_set_integration_time\fP (\fBveml6040_handle_t\fP handle, const \fBveml6040_integration_times_t\fP integration_time)"
.br
.RI "Writes integration time to VEML6040\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_get_trigger_method\fP (\fBveml6040_handle_t\fP handle, \fBveml6040_triggers_t\fP *const trigger_method)"
.br
.RI "Reads trigger method from VEML6040\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_set_trigger_method\fP (\fBveml6040_handle_t\fP handle, const \fBveml6040_triggers_t\fP trigger_method)"
.br
.RI "Write trigger method to VEML6040\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_get_mode\fP (\fBveml6040_handle_t\fP handle, \fBveml6040_modes_t\fP *const mode)"
.br
.RI "Reads mode from VEML6040\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_set_mode\fP (\fBveml6040_handle_t\fP handle, const \fBveml6040_modes_t\fP mode)"
.br
.RI "Writes mode to VEML6040\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_disable\fP (\fBveml6040_handle_t\fP handle)"
.br
.RI "Shuts down VEML6040 until woken\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_enable\fP (\fBveml6040_handle_t\fP handle)"
.br
.RI "Wakes up VEML6040 from shutdown\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_remove\fP (\fBveml6040_handle_t\fP handle)"
.br
.RI "Removes an VEML6040 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBveml6040_delete\fP (\fBveml6040_handle_t\fP handle)"
.br
.RI "Removes an VEML6040 device from master I2C bus and delete the handle\&. "
.ti -1c
.RI "const char * \fBveml6040_get_fw_version\fP (void)"
.br
.RI "Converts VEML6040 firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBveml6040_get_fw_version_number\fP (void)"
.br
.RI "Converts VEML6040 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_configuration_register\fP (\fBveml7700_handle_t\fP handle, veml7700_configuration_register_t *const reg)"
.br
.RI "Reads configuration register from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_set_configuration_register\fP (\fBveml7700_handle_t\fP handle, const veml7700_configuration_register_t reg)"
.br
.RI "Writes configuration register to VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_threshold_registers\fP (\fBveml7700_handle_t\fP handle, uint16_t *const hi_threshold, uint16_t *const lo_threshold)"
.br
.RI "Reads high and low threshold registers from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_set_threshold_registers\fP (\fBveml7700_handle_t\fP handle, const uint16_t hi_threshold, const uint16_t lo_threshold)"
.br
.RI "Writes high and low threshold registers to VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_power_saving_mode_register\fP (\fBveml7700_handle_t\fP handle, veml7700_power_saving_mode_register_t *const reg)"
.br
.RI "Reads power saving mode register from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_set_power_saving_mode_register\fP (\fBveml7700_handle_t\fP handle, const veml7700_power_saving_mode_register_t reg)"
.br
.RI "Writes power saving mode register to VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_interrupt_status_register\fP (\fBveml7700_handle_t\fP handle, veml7700_interrupt_status_register_t *const reg)"
.br
.RI "Reads interrupt status register from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_identifier_register\fP (\fBveml7700_handle_t\fP handle, veml7700_identifier_register_t *const reg)"
.br
.RI "Reads identifier register from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_optimize_configuration\fP (\fBveml7700_handle_t\fP handle)"
.br
.RI "Optimizes VEML7700 gain and integration time configuration\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_optimize_configuration___\fP (\fBveml7700_handle_t\fP handle)"
.br
.ti -1c
.RI "esp_err_t \fBveml7700_init\fP (i2c_master_bus_handle_t master_handle, const \fBveml7700_config_t\fP *veml7700_config, \fBveml7700_handle_t\fP *veml7700_handle)"
.br
.RI "Initializes an VEML7700 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_ambient_light_counts\fP (\fBveml7700_handle_t\fP handle, uint16_t *const counts)"
.br
.RI "Reads ambient light counts from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_ambient_light\fP (\fBveml7700_handle_t\fP handle, float *const ambient_light)"
.br
.RI "Reads ambient light (0 lux to 140 klux) from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_ambient_light_auto\fP (\fBveml7700_handle_t\fP handle, float *const ambient_light)"
.br
.RI "Reads optimal ambient light (0 lux to 140 klux) from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_white_channel_counts\fP (\fBveml7700_handle_t\fP handle, uint16_t *const counts)"
.br
.RI "Reads white channel counts from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_white_channel\fP (\fBveml7700_handle_t\fP handle, float *const white_light)"
.br
.RI "Reads white channel from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_white_channel_auto\fP (\fBveml7700_handle_t\fP handle, float *const white_light)"
.br
.RI "Reads optimal white channel from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_thresholds\fP (\fBveml7700_handle_t\fP handle, uint16_t *const hi_threshold, uint16_t *const lo_threshold)"
.br
.RI "Reads high and low als thresholds (lux) from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_set_thresholds\fP (\fBveml7700_handle_t\fP handle, const uint16_t hi_threshold, const uint16_t lo_threshold)"
.br
.RI "Writes high and low als thresholds (lux) to VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_gain\fP (\fBveml7700_handle_t\fP handle, \fBveml7700_gains_t\fP *const gain)"
.br
.RI "Reads als gain from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_set_gain\fP (\fBveml7700_handle_t\fP handle, const \fBveml7700_gains_t\fP gain)"
.br
.RI "Writes als gain to VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_integration_time\fP (\fBveml7700_handle_t\fP handle, \fBveml7700_integration_times_t\fP *const integration_time)"
.br
.RI "Reads als integration time from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_set_integration_time\fP (\fBveml7700_handle_t\fP handle, const \fBveml7700_integration_times_t\fP integration_time)"
.br
.RI "Writes als integration time to VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_persistence_protection\fP (\fBveml7700_handle_t\fP handle, \fBveml7700_persistence_protections_t\fP *const persistence_protection)"
.br
.RI "Reads als persistence protection from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_set_persistence_protection\fP (\fBveml7700_handle_t\fP handle, const \fBveml7700_persistence_protections_t\fP persistence_protection)"
.br
.RI "Writes als persistence protection to VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_power_saving_mode\fP (\fBveml7700_handle_t\fP handle, \fBveml7700_power_saving_modes_t\fP *const power_saving_mode, bool *const power_saving_enabled)"
.br
.RI "Reads power saving mode from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_set_power_saving_mode\fP (\fBveml7700_handle_t\fP handle, const \fBveml7700_power_saving_modes_t\fP power_saving_mode, const bool power_saving_enabled)"
.br
.RI "Reads power saving mode from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_enable_irq\fP (\fBveml7700_handle_t\fP handle)"
.br
.RI "Enables interrupt assertion\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_disable_irq\fP (\fBveml7700_handle_t\fP handle)"
.br
.RI "Disables interrupt assertion\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_get_interrupt_status\fP (\fBveml7700_handle_t\fP handle, bool *const hi_threshold_exceeded, bool *const lo_threshold_exceeded)"
.br
.RI "Reads interrupt status from VEML7700\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_disable\fP (\fBveml7700_handle_t\fP handle)"
.br
.RI "Shuts down VEML7700 until woken\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_enable\fP (\fBveml7700_handle_t\fP handle)"
.br
.RI "Wakes up VEML7700 from shut-down\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_remove\fP (\fBveml7700_handle_t\fP handle)"
.br
.RI "Removes an VEML7700 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBveml7700_delete\fP (\fBveml7700_handle_t\fP handle)"
.br
.RI "Removes an VEML7700 device from master I2C bus and delete the handle\&. "
.ti -1c
.RI "const char * \fBveml7700_get_fw_version\fP (void)"
.br
.RI "Converts VEML7700 firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBveml7700_get_fw_version_number\fP (void)"
.br
.RI "Converts VEML7700 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "bool \fBods18b20_validate_address\fP (const onewire_device_address_t address)"
.br
.RI "Checks 1-wire device address against the ROM ID (i\&.e\&. family code of DS18B20 is 0x28) to determine if the device is a DS18B20\&. "
.ti -1c
.RI "esp_err_t \fBds18b20_detect\fP (\fBonewire_bus_handle_t\fP owb_handle, \fBonewire_device_t\fP *const devices, const uint8_t device_size, uint8_t *const device_count)"
.br
.RI "Detects up to 10 DS18B20 devices on the 1-wire bus\&. "
.ti -1c
.RI "esp_err_t \fBds18b20_connected\fP (\fBds18b20_handle_t\fP handle, bool *const connected)"
.br
.RI "Checks if the DS18B20 is connected to the 1-wire bus\&. "
.ti -1c
.RI "esp_err_t \fBds18b20_init\fP (\fBonewire_device_t\fP *device, const \fBds18b20_config_t\fP *ds18b20_config, \fBds18b20_handle_t\fP *ds18b20_handle)"
.br
.RI "Initializes an DS18B20 device onto the 1-wire master bus\&. "
.ti -1c
.RI "esp_err_t \fBds18b20_get_temperature\fP (\fBds18b20_handle_t\fP handle, float *const temperature)"
.br
.RI "Triggers temperature conversion and reads temperature from DS18B20\&. "
.ti -1c
.RI "esp_err_t \fBds18b20_get_measurement\fP (\fBds18b20_handle_t\fP handle, float *const temperature)"
.br
.RI "Reads temperature from DS18B20\&. "
.ti -1c
.RI "esp_err_t \fBds18b20_trigger_temperature_conversion\fP (\fBds18b20_handle_t\fP handle)"
.br
.RI "Triggers DS18B20 temperature conversion\&. This function must be called before reading the temperature from DS18B20\&. "
.ti -1c
.RI "esp_err_t \fBds18b20_get_resolution\fP (\fBds18b20_handle_t\fP handle, \fBds18b20_resolutions_t\fP *const resolution)"
.br
.RI "Reads temperature conversion resolution from DS18B20\&. "
.ti -1c
.RI "esp_err_t \fBds18b20_set_resolution\fP (\fBds18b20_handle_t\fP handle, const \fBds18b20_resolutions_t\fP resolution)"
.br
.RI "Writes temperature conversion resolution to DS18B20\&. "
.ti -1c
.RI "esp_err_t \fBds18b20_get_alarm_thresholds\fP (\fBds18b20_handle_t\fP handle, int8_t *const high, int8_t *const low)"
.br
.RI "Reads high and low temperature alarm thresholds from DS18B20\&. "
.ti -1c
.RI "esp_err_t \fBds18b20_set_alarm_thresholds\fP (\fBds18b20_handle_t\fP handle, const int8_t high, const int8_t low)"
.br
.RI "Writes high and low temperature alarm thresholds to DS18B20\&. "
.ti -1c
.RI "esp_err_t \fBds18b20_alarm_triggered\fP (\fBds18b20_handle_t\fP handle, bool *const alarm)"
.br
.RI "Check if the DS18B20 temperature alarm triggered\&. "
.ti -1c
.RI "esp_err_t \fBds18b20_get_power_supply_mode\fP (\fBds18b20_handle_t\fP handle, bool *const parasitic)"
.br
.RI "Reads power supply mode setting from DS18B20\&. Parasitic-powered devices are powered by the data pin (DQ) and will pull the bus low during read time slot\&. Parasitic-powered devices are not supported at this time\&. "
.ti -1c
.RI "esp_err_t \fBds18b20_delete\fP (\fBds18b20_handle_t\fP handle)"
.br
.RI "Removes an DS18B20 device from master bus and frees handle\&. "
.ti -1c
.RI "const char * \fBds18b20_get_fw_version\fP (void)"
.br
.RI "Converts DS18B20 firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBds18b20_get_fw_version_number\fP (void)"
.br
.RI "Converts DS18B20 firmware version numbers (major, minor, patch) into an integer value\&. "
.ti -1c
.RI "esp_err_t \fBspi_max31865_get_configuration_register\fP (\fBspi_max31865_handle_t\fP max31865_handle)"
.br
.ti -1c
.RI "esp_err_t \fBspi_max31865_set_configuration_register\fP (\fBspi_max31865_handle_t\fP max31865_handle, const spi_max31865_configuration_register_t config_reg)"
.br
.ti -1c
.RI "esp_err_t \fBspi_max31865_get_fault_status_register\fP (\fBspi_max31865_handle_t\fP max31865_handle)"
.br
.RI "Read fault status register from MAX31865\&. "
.ti -1c
.RI "esp_err_t \fBspi_max31865_init\fP (const \fBspi_max31865_config_t\fP *max31865_config, \fBspi_max31865_handle_t\fP *max31865_handle)"
.br
.RI "Initializes an MAX31865 device onto the I2C master bus\&. "
.ti -1c
.RI "esp_err_t \fBspi_max31865_get_measurement\fP (\fBspi_max31865_handle_t\fP max31865_handle, float *const temperature)"
.br
.RI "Reads temperature from MAX31865\&. "
.ti -1c
.RI "esp_err_t \fBspi_max31865_remove\fP (\fBspi_max31865_handle_t\fP max31865_handle)"
.br
.RI "Removes an MAX31865 device from master bus\&. "
.ti -1c
.RI "esp_err_t \fBspi_max31865_delete\fP (\fBspi_max31865_handle_t\fP max31865_handle)"
.br
.RI "Removes an MAX31865 device from master bus and frees handle\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_init\fP (const \fBdatatable_config_t\fP *datatable_config, \fBdatatable_handle_t\fP *datatable_handle)"
.br
.RI "Initializes a data-table handle\&. A data-table handle instance is required before any other data-table functions can be called\&. Once the data-table is initialized the following functions are used to configure the data-table columns and within the sampling task\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_vector_smp_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name_uc, const char *name_vc, uint8_t *index)"
.br
.RI "Appends a vector based data-type column as a sample to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_vector_avg_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name_uc, const char *name_vc, uint8_t *index)"
.br
.RI "Appends a vector based data-type column as an average to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_vector_min_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name_uc, const char *name_vc, uint8_t *index)"
.br
.RI "Appends a vector based data-type column as a v-component minimum to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_vector_max_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name_uc, const char *name_vc, uint8_t *index)"
.br
.RI "Appends a vector based data-type column as a v-component maximum to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_vector_min_ts_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name_uc, const char *name_vc, uint8_t *index)"
.br
.RI "Appends a vector based data-type column as a v-component minimum with timestamp to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_vector_max_ts_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name_uc, const char *name_vc, uint8_t *index)"
.br
.RI "Appends a vector based data-type column as a v-component maximum with timestamp to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_bool_smp_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name, uint8_t *index)"
.br
.RI "Appends a bool based data-type column as a sample process-type to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_float_smp_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name, uint8_t *index)"
.br
.RI "Appends a float based data-type column as a sample process-type to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_float_avg_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name, uint8_t *index)"
.br
.RI "Appends a float based data-type column as an average process-type to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_float_min_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name, uint8_t *index)"
.br
.RI "Appends a float based data-type column as a minimum process-type to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_float_max_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name, uint8_t *index)"
.br
.RI "Appends a float based data-type column as a maximum process-type to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_float_min_ts_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name, uint8_t *index)"
.br
.RI "Appends a float based data-type column as a minimum with timestamp process-type to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_float_max_ts_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name, uint8_t *index)"
.br
.RI "Appends a float based data-type column as a maximum with timestamp process-type to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_int16_smp_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name, uint8_t *index)"
.br
.RI "Appends a int16 based data-type column as a sample process-type to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_int16_avg_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name, uint8_t *index)"
.br
.RI "Appends a int16 based data-type column as an average process-type to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_int16_min_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name, uint8_t *index)"
.br
.RI "Appends a int16 based data-type column as a minimum process-type to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_int16_max_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name, uint8_t *index)"
.br
.RI "Appends a int16 based data-type column as a maximum process-type to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_int16_min_ts_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name, uint8_t *index)"
.br
.RI "Appends a int16 based data-type column as a minimum with timestamp process-type to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_add_int16_max_ts_column\fP (\fBdatatable_handle_t\fP datatable_handle, const char *name, uint8_t *index)"
.br
.RI "Appends a int16 based data-type column as a maximum with timestamp process-type to the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_get_columns_count\fP (\fBdatatable_handle_t\fP datatable_handle, uint8_t *count)"
.br
.RI "Gets the number of columns in the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_get_rows_count\fP (\fBdatatable_handle_t\fP datatable_handle, uint8_t *count)"
.br
.RI "Gets the number of rows in the data-table\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_get_column\fP (\fBdatatable_handle_t\fP datatable_handle, const uint8_t index, \fBdatatable_column_t\fP **column)"
.br
.RI "Gets the column structure from the data-table based on the column index\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_get_row\fP (\fBdatatable_handle_t\fP datatable_handle, const uint8_t index, \fBdatatable_row_t\fP **row)"
.br
.RI "Gets the row structure from the data-table based on the row index\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_push_vector_sample\fP (\fBdatatable_handle_t\fP datatable_handle, const uint8_t index, const float uc_value, const float vc_value)"
.br
.RI "Pushes a vector data-type sample onto the column sample data buffer stack for processing\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_push_bool_sample\fP (\fBdatatable_handle_t\fP datatable_handle, const uint8_t index, const bool value)"
.br
.RI "Pushes a boolean data-type sample onto the column sample data buffer stack for processing\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_push_float_sample\fP (\fBdatatable_handle_t\fP datatable_handle, const uint8_t index, const float value)"
.br
.RI "Pushes a float data-type sample onto the column sample data buffer stack for processing\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_push_int16_sample\fP (\fBdatatable_handle_t\fP datatable_handle, const uint8_t index, const int16_t value)"
.br
.RI "Pushes an int16 data-type sample onto the column sample data buffer stack for processing\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_sampling_task_delay\fP (\fBdatatable_handle_t\fP datatable_handle)"
.br
.RI "Delays the data-table's sampling task until the next scheduled task event\&. 
.br
 This function should be placed after the \fRfor (;;) {\fP syntax to delay the task based on the configured time-into-interval handle interval type, period, and offset parameters\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_process_samples\fP (\fBdatatable_handle_t\fP datatable_handle)"
.br
.RI "Processes data-table samples on the data buffer stack in each column based on the data-table's 
.br
 configured processing interval\&. When the samples are processed, the data buffer stack is cleared for each column\&. This function must be called after data-table samples are pushed in the sampling task\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_delete\fP (\fBdatatable_handle_t\fP datatable_handle)"
.br
.RI "Deletes the data-table handle to frees up resources\&. "
.ti -1c
.RI "esp_err_t \fBdatatable_to_json\fP (\fBdatatable_handle_t\fP datatable_handle, cJSON **datatable)"
.br
.RI "Converts a data-table to a \fRcJSON\fP object\&. "
.ti -1c
.RI "esp_err_t \fBnvs_init\fP (void)"
.br
.RI "Initialization NVS storage\&. "
.ti -1c
.RI "esp_err_t \fBnvs_write_float\fP (const char *key, float write_value)"
.br
.RI "Writes float typed value to NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_read_float\fP (const char *key, float *read_value)"
.br
.RI "Reads float typed value from NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_write_double\fP (const char *key, double write_value)"
.br
.RI "Writes double typed value to NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_read_double\fP (const char *key, double *read_value)"
.br
.RI "Reads double typed value from NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_write_u8\fP (const char *key, uint8_t write_value)"
.br
.RI "Writes uint8_t typed value to NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_read_u8\fP (const char *key, uint8_t *read_value)"
.br
.RI "Reads uint8_t typed value from NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_write_u16\fP (const char *key, uint16_t write_value)"
.br
.RI "Writes uint16_t typed value to NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_read_u16\fP (const char *key, uint16_t *read_value)"
.br
.RI "Reads uint16_t typed value from NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_write_u32\fP (const char *key, uint32_t write_value)"
.br
.RI "Writes uint32_t typed value to NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_read_u32\fP (const char *key, uint32_t *read_value)"
.br
.RI "Reads uint32_t typed value from NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_write_u64\fP (const char *key, uint64_t write_value)"
.br
.RI "Writes uint64_t typed value to NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_read_u64\fP (const char *key, uint64_t *read_value)"
.br
.RI "Reads uint64_t typed value from NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_write_i8\fP (const char *key, int8_t write_value)"
.br
.RI "Writes int8_t typed value to NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_read_i8\fP (const char *key, int8_t *read_value)"
.br
.RI "Reads int8_t typed value from NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_write_i16\fP (const char *key, int16_t write_value)"
.br
.RI "Writes int16_t typed value to NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_read_i16\fP (const char *key, int16_t *read_value)"
.br
.RI "Reads int16_t typed value from NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_write_i32\fP (const char *key, int32_t write_value)"
.br
.RI "Writes int32_t typed value to NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_read_i32\fP (const char *key, int32_t *read_value)"
.br
.RI "Reads int32_t typed value from NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_write_i64\fP (const char *key, int64_t write_value)"
.br
.RI "Writes int64_t typed value to NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_read_i64\fP (const char *key, int64_t *read_value)"
.br
.RI "Reads int64_t typed value from NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_write_str\fP (const char *key, const char *write_str)"
.br
.RI "Writes string typed value to NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_read_str\fP (const char *key, char **read_str)"
.br
.RI "Reads string typed value from NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_write_struct\fP (const char *key, void *write_struct, size_t size)"
.br
.RI "Writes struct typed value to NVS\&. "
.ti -1c
.RI "esp_err_t \fBnvs_read_struct\fP (const char *key, void **read_struct, size_t size)"
.br
.RI "Reads struct type value from NVS\&. "
.ti -1c
.RI "const char * \fBnvs_ext_get_fw_version\fP (void)"
.br
.RI "Converts \fRnvs_ext\fP firmware version numbers (major, minor, patch) into a string\&. "
.ti -1c
.RI "int32_t \fBnvs_ext_get_fw_version_number\fP (void)"
.br
.RI "Converts \fRnvs_ext\fP firmware version numbers (major, minor, patch) into an integer value\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBahtxx_status_register_t\fP"
.br
.ti -1c
.RI "\fBak8975_control_register_t\fP"
.br
.ti -1c
.RI "\fBak8975_status1_register_t\fP"
.br
.ti -1c
.RI "\fBak8975_status2_register_t\fP"
.br
.ti -1c
.RI "\fBak8975_selftest_control_register_t\fP"
.br
.ti -1c
.RI "\fBas3935_0x00_register_t\fP"
.br
.ti -1c
.RI "\fBas3935_0x01_register_t\fP"
.br
.ti -1c
.RI "\fBas3935_0x02_register_t\fP"
.br
.ti -1c
.RI "\fBas3935_0x03_register_t\fP"
.br
.ti -1c
.RI "\fBas3935_0x07_register_t\fP"
.br
.ti -1c
.RI "\fBas3935_0x08_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_enable_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_config_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_flicker_detection_time1_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_flicker_detection_time2_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_gpio1_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_gpio2_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_led_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_interrupt_enable_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_interrupt_status_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_device_status_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_astatus_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_status2_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_status3_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_status5_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_status6_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_flicker_detection_status_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_auxiliary_id_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_revision_id_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_part_id_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_config0_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_config1_register_t\fP"
.br
.ti -1c
.RI "\fBas7341_config6_register_t\fP"
.br
.ti -1c
.RI "\fBbme680_status0_register_t\fP"
.br
.ti -1c
.RI "\fBbme680_control_measurement_register_t\fP"
.br
.ti -1c
.RI "\fBbme680_control_humidity_register_t\fP"
.br
.ti -1c
.RI "\fBbme680_control_gas1_register_t\fP"
.br
.ti -1c
.RI "\fBbme680_control_gas0_register_t\fP"
.br
.ti -1c
.RI "\fBbme680_gas_lsb_register_t\fP"
.br
.ti -1c
.RI "\fBbme680_config_register_t\fP"
.br
.ti -1c
.RI "\fBbmp280_status_register_t\fP"
.br
.ti -1c
.RI "\fBbmp280_control_measurement_register_t\fP"
.br
.ti -1c
.RI "\fBbmp280_configuration_register_t\fP"
.br
.ti -1c
.RI "\fBbmp390_status_register_t\fP"
.br
.ti -1c
.RI "\fBbmp390_interrupt_status_register_t\fP"
.br
.ti -1c
.RI "\fBbmp390_interrupt_control_register_t\fP"
.br
.ti -1c
.RI "\fBbmp390_power_control_register_t\fP"
.br
.ti -1c
.RI "\fBbmp390_oversampling_register_t\fP"
.br
.ti -1c
.RI "\fBbmp390_output_data_rate_register_t\fP"
.br
.ti -1c
.RI "\fBbmp390_configuration_register_t\fP"
.br
.ti -1c
.RI "\fBccs811_status_register_t\fP"
.br
.ti -1c
.RI "\fBccs811_measure_mode_register_t\fP"
.br
.ti -1c
.RI "\fBccs811_raw_data_register_t\fP"
.br
.ti -1c
.RI "\fBccs811_threshold_value_t\fP"
.br
.ti -1c
.RI "\fBccs811_firmware_version_format_t\fP"
.br
.ti -1c
.RI "\fBccs811_error_code_register_t\fP"
.br
.ti -1c
.RI "\fBens160_status_register_t\fP"
.br
.ti -1c
.RI "\fBens160_interrupt_config_register_t\fP"
.br
.ti -1c
.RI "\fBens160_caqi_data_register_t\fP"
.br
.ti -1c
.RI "\fBhdc1080_configuration_register_t\fP"
.br
.ti -1c
.RI "\fBhdc1080_measurement_register_t\fP"
.br
.ti -1c
.RI "\fBhdc1080_serial_number_register_t\fP"
.br
.ti -1c
.RI "\fBhmc5883l_configuration1_register_t\fP"
.br
.ti -1c
.RI "\fBhmc5883l_configuration2_register_t\fP"
.br
.ti -1c
.RI "\fBhmc5883l_mode_register_t\fP"
.br
.ti -1c
.RI "\fBhmc5883l_status_register_t\fP"
.br
.ti -1c
.RI "\fBina226_config_register_t\fP"
.br
.ti -1c
.RI "\fBina226_mask_enable_register_t\fP"
.br
.ti -1c
.RI "\fBltr390uv_control_register_t\fP"
.br
.ti -1c
.RI "\fBltr390uv_measure_register_t\fP"
.br
.ti -1c
.RI "\fBltr390uv_gain_register_t\fP"
.br
.ti -1c
.RI "\fBltr390uv_status_register_t\fP"
.br
.ti -1c
.RI "\fBltr390uv_interrupt_config_register_t\fP"
.br
.ti -1c
.RI "\fBmax30105_interrupt_status1_register_t\fP"
.br
.ti -1c
.RI "\fBmax30105_interrupt_status2_register_t\fP"
.br
.ti -1c
.RI "\fBmax30105_interrupt_enable1_register_t\fP"
.br
.ti -1c
.RI "\fBmax30105_interrupt_enable2_register_t\fP"
.br
.ti -1c
.RI "\fBmax30105_mode_configuration_register_t\fP"
.br
.ti -1c
.RI "\fBmax30105_multi_led_mode_control_register_t\fP"
.br
.ti -1c
.RI "\fBmax30105_fifo_write_pointer_register_t\fP"
.br
.ti -1c
.RI "\fBmax30105_fifo_overflow_counter_register_t\fP"
.br
.ti -1c
.RI "\fBmax30105_fifo_read_pointer_register_t\fP"
.br
.ti -1c
.RI "\fBmax30105_fifo_data_register_t\fP"
.br
.ti -1c
.RI "\fBmlx90614_config_register_t\fP"
.br
.ti -1c
.RI "\fBmlx90614_pwmctrl_register_t\fP"
.br
.ti -1c
.RI "\fBmlx90614_flags_register_t\fP"
.br
.ti -1c
.RI "\fBmmc56x3_status_register_t\fP"
.br
.ti -1c
.RI "\fBmmc56x3_control0_register_t\fP"
.br
.ti -1c
.RI "\fBmmc56x3_control1_register_t\fP"
.br
.ti -1c
.RI "\fBmmc56x3_control2_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_self_test_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_self_test_a_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_config_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_gyro_config_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_accel_config_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_fifo_enable_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_interrupt_enable_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_interrupt_pin_config_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_interrupt_status_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_signal_path_reset_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_user_control_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_power_management1_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_power_management2_register_t\fP"
.br
.ti -1c
.RI "\fBmpu6050_who_am_i_register_t\fP"
.br
.ti -1c
.RI "\fBsgp4x_self_test_result_t\fP"
.br
.ti -1c
.RI "\fBtlv493d_temperature_msb_register_t\fP"
.br
.ti -1c
.RI "\fBtlv493d_bx_by_lsb_register_t\fP"
.br
.ti -1c
.RI "\fBtlv493d_bz_lsb_register_t\fP"
.br
.ti -1c
.RI "\fBtlv493d_factory_setting1_register_t\fP"
.br
.ti -1c
.RI "\fBtlv493d_factory_setting2_register_t\fP"
.br
.ti -1c
.RI "\fBtlv493d_factory_setting3_register_t\fP"
.br
.ti -1c
.RI "\fBtlv493d_reserved1_register_t\fP"
.br
.ti -1c
.RI "\fBtlv493d_mode1_register_t\fP"
.br
.ti -1c
.RI "\fBtlv493d_reserved2_register_t\fP"
.br
.ti -1c
.RI "\fBtlv493d_mode2_register_t\fP"
.br
.ti -1c
.RI "\fBveml6040_config_register_t\fP"
.br
.ti -1c
.RI "\fBveml7700_configuration_register_t\fP"
.br
.ti -1c
.RI "\fBveml7700_power_saving_mode_register_t\fP"
.br
.ti -1c
.RI "\fBveml7700_interrupt_status_register_t\fP"
.br
.ti -1c
.RI "\fBveml7700_identifier_register_t\fP"
.br
.ti -1c
.RI "\fBds18b20_configuration_register_t\fP"
.br
.ti -1c
.RI "\fBds18b20_scratchpad_t\fP"
.br
.ti -1c
.RI "\fBspi_max31865_configuration_register_t\fP"
.br
.ti -1c
.RI "\fBspi_max31865_fault_status_register_t\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
ESP-IDF driver for guva-s12sd uv sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for ahtxx sensor types

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for ak8975 3-axis electronic compass

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for as3935 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for as7341 11-channel spectrometer

.PP
https://github.com/DFRobot/DFRobot_AS7341/blob/master/DFRobot_AS7341.cpp https://github.com/adafruit/Adafruit_AS7341/blob/master/Adafruit_AS7341.cpp

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for bh1750 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
https://github.com/boschsensortec/BME68x_SensorAPI/blob/master/bme68x.c

.PP
ESP-IDF driver for bme680 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for bmp280 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for bmp390 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for ccs811 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for ens160 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for hdc1080 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for hmc5883l sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for ina226 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for ltr390uv sensor

.PP
Source references: https://github.com/esphome/esphome/blob/dev/esphome/components/ltr390/ltr390.cpp https://github.com/DFRobot/DFRobot_LTR390UV/blob/master/DFRobot_LTR390UV.cpp

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for max30105 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for mlx90614 sensor

.PP
https://github.com/melexis/mlx90614-library

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for mmc56x3 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for mpu6050 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for sgp4x sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for sht4x sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
bitmap images for display panel demos

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for ssd1306 display panel

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for tbi2cxxx ir temperature sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for tbi2cxxx sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for tlv493d sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for veml6040 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for veml7700 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for ds18b20 temperature sensor

.PP
Source references: https://github.com/espressif/esp-bsp/blob/master/components/ds18b20/src/ds18b20.c https://github.com/DavidAntliff/esp32-ds18b20/blob/99eb5dd55536fd79b4bd5790f1430c218c51410f/ds18b20.c https://github.com/adafruit/MAX31850_DallasTemp/blob/master/DallasTemperature.cpp

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF driver for max31865 sensor

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF library for datatable

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE

.PP
ESP-IDF nvs driver extension

.PP
Copyright (c) 2024 Eric Gionet (gionet.c.eric@gmail.com)

.PP
MIT Licensed as described in the file LICENSE 
.SH "Macro Definition Documentation"
.PP 
.SS "#define ADC_S12SD_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                  \\
    \&.adc_unit    = ADC_S12SD_UNIT_DEFAULT,          \\
    \&.adc_channel = ADC_S12SD_CHANNEL_DEFAULT,  }
.PP
.fi

.PP
Macro that initializes \fRadc_s12sd_config_t\fP to default configuration settings\&. public macro definitions 
.SS "#define ADC_S12SD_UNIT_DEFAULT   ADC_UNIT_1"
dependency includes public constant definitions 
.SS "#define ENS160_AQI_MAX   UINT16_C(5)"
ens160 air quality index UBA maximum (table 6) 
.SS "#define ENS160_AQI_MIN   UINT16_C(1)"
ens160 air quality index UBA minimum (table 6) 
.SS "#define ENS160_ECO2_MAX   UINT16_C(65000)"
ens160 equivalent co2 maximum in ppm (table 5) 
.SS "#define ENS160_ECO2_MIN   UINT16_C(400)"
ens160 equivalent co2 minimum in ppm (table 5) 
.SS "#define ENS160_TVOC_MAX   UINT16_C(65000)"
ens160 tvoc maximum in ppb (section 5\&.1) 
.SS "#define ENS160_TVOC_MIN   UINT16_C(0)"
ens160 tvoc minimum in ppb (section 5\&.1) 
.SS "#define I2C_AHT10_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                  \\
    \&.i2c_address     = I2C_AHTXX_DEV_ADDR,          \\
    \&.i2c_clock_speed = I2C_AHTXX_DEV_CLK_SPD,       \\
    \&.sensor_type     = AHTXX_AHT10 }
.PP
.fi

.PP
Macro that initializes \fR\fBahtxx_config_t\fP\fP to default configuration settings for the aht10 sensor type\&. 
.SS "#define I2C_AHT20_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                  \\
    \&.i2c_address     = I2C_AHTXX_DEV_ADDR,          \\
    \&.i2c_clock_speed = I2C_AHTXX_DEV_CLK_SPD,       \\
    \&.sensor_type     = AHTXX_AHT20 }
.PP
.fi

.PP
Macro that initializes \fR\fBahtxx_config_t\fP\fP to default configuration settings for the aht20 sensor type\&. 
.SS "#define I2C_AHT21_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                  \\
    \&.i2c_address     = I2C_AHTXX_DEV_ADDR,          \\
    \&.i2c_clock_speed = I2C_AHTXX_DEV_CLK_SPD,       \\
    \&.sensor_type     = AHTXX_AHT21 }
.PP
.fi

.PP
Macro that initializes \fR\fBahtxx_config_t\fP\fP to default configuration settings for the aht21 sensor type\&. 
.SS "#define I2C_AHT25_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                  \\
    \&.i2c_address     = I2C_AHTXX_DEV_ADDR,          \\
    \&.i2c_clock_speed = I2C_AHTXX_DEV_CLK_SPD,       \\
    \&.sensor_type     = AHTXX_AHT25 }
.PP
.fi

.PP
Macro that initializes \fR\fBahtxx_config_t\fP\fP to default configuration settings for the aht25 sensor type\&. 
.SS "#define I2C_AHT2X_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                  \\
    \&.i2c_address        = I2C_TBI2CXXX_DEV_ADDR,    \\
    \&.i2c_clock_speed    = I2C_TBI2CXXX_DEV_CLK_SPD, \\
    \&.tb_type            = TB_I2C_H04 }
.PP
.fi

.SS "#define I2C_AHT30_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                  \\
    \&.i2c_address     = I2C_AHTXX_DEV_ADDR,          \\
    \&.i2c_clock_speed = I2C_AHTXX_DEV_CLK_SPD,       \\
    \&.sensor_type     = AHTXX_AHT30 }
.PP
.fi

.PP
Macro that initializes \fR\fBahtxx_config_t\fP\fP to default configuration settings for the aht30 sensor type\&. public macro definitions 
.SS "#define I2C_AHTXX_DEV_ADDR   UINT8_C(0x38)"
ahtxx i2c device address 
.SS "#define I2C_AHTXX_DEV_CLK_SPD   UINT32_C(100000)"
dependency includes public constant definitions ahtxx i2c device scl clock frequency (100KHz) 
.SS "#define I2C_AK8975_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                           \\
    \&.i2c_clock_speed    = I2C_AK8975_DEV_CLK_SPD,            \\
    \&.i2c_address        = I2C_AK8975_DEV_ADDR_CAD1_0_CAD0_0, }
.PP
.fi

.PP
Macro that initializes \fRi2c_ak8975_config_t\fP to default configuration settings\&. 
.SS "#define I2C_AS3935_CONFIG_DEFAULT"
\fBValue:\fP
.nf
        {                                             \\
        \&.i2c_clock_speed                = I2C_AS3935_DEV_CLK_SPD,               \\
        \&.i2c_address                    = I2C_AS3935_DEV_ADDR_3,                \\
        \&.irq_io_enabled                 = true,                                 \\
        \&.irq_io_num                     = GPIO_NUM_10,                          \\
        \&.analog_frontend                = AS3935_AFE_INDOOR,                    \\
        \&.min_lightning_strikes          = AS3935_MIN_LIGHTNING_9,               \\
        \&.calibrate_rco                  = true,                                 \\
        \&.disturber_detection_enabled    = true,                                 \\
        \&.noise_level_threshold          = AS3935_NOISE_LEVEL_1140_95            \\
    }
.PP
.fi

.PP
CJMCU-3935 Board Wiring (I2C interface): ADD0 & ADD1 pin to VCC (3\&.3v) -> I2C address 0x03 SI pin to VCC (3\&.3v) -> enable I2C interface SCL pin 10k-ohm pull-up resistor to VCC (3\&.3v) SCL pin to MCU SCL pin MOSI (SDA) pin to MCU SDA pin IRQ pin to MCU interrupt pin VCC pin to 3\&.3v GND pin to common ground\&. AS3935 macro definitions 
.SS "#define I2C_AS3935_DEV_CLK_SPD   UINT32_C(100000)"

.PP
AS3935 definitions\&. as3935 I2C default clock frequency (100KHz) 
.SS "#define I2C_AS7341_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                      \\
    \&.i2c_address        = I2C_AS7341_DEV_ADDR,           \\
    \&.i2c_clock_speed    = I2C_AS7341_DEV_CLK_SPD,        \\
    \&.spectral_gain      = AS7341_SPECTRAL_GAIN_32X,      \\
    \&.atime              = 29,                            \\
    \&.astep              = 599 }
.PP
.fi

.SS "#define I2C_BH1750_CONFIG_DEFAULT"
\fBValue:\fP
.nf
        {                             \\
        \&.i2c_address        = I2C_BH1750_DEV_ADDR_LO,           \\
        \&.i2c_clock_speed    = I2C_BH1750_DEV_CLK_SPD,           \\
        \&.mode               = BH1750_MODE_CM_HI_RESOLUTION,     \\
        \&.power_enabled      = true,                             \\
        \&.set_timespan       = false }
.PP
.fi

.SS "#define I2C_BME680_CONFIG_DEFAULT"
\fBValue:\fP
.nf
        {                                             \\
        \&.i2c_address                = I2C_BME680_DEV_ADDR_HI,                   \\
        \&.i2c_clock_speed            = I2C_BME680_DEV_CLK_SPD,                   \\
        \&.power_mode                 = BME680_POWER_MODE_FORCED,                 \\
        \&.iir_filter                 = BME680_IIR_FILTER_OFF,                    \\
        \&.pressure_oversampling      = BME680_PRESSURE_OVERSAMPLING_4X,          \\
        \&.temperature_oversampling   = BME680_TEMPERATURE_OVERSAMPLING_4X,       \\
        \&.humidity_oversampling      = BME680_HUMIDITY_OVERSAMPLING_4X,          \\
        \&.gas_enabled                = true,                                     \\
        \&.heater_temperature         = 300,                                      \\
        \&.heater_duration            = 300,                                      \\
        \&.heater_profile_size        = 1                                         \\
    }
.PP
.fi

.SS "#define I2C_BMP280_CONFIG_DEFAULT"
\fBValue:\fP
.nf
        {                                          \\
        \&.i2c_address                = I2C_BMP280_DEV_ADDR_HI,                \\
        \&.i2c_clock_speed            = I2C_BMP280_DEV_CLK_SPD,                \\
        \&.power_mode                 = BMP280_POWER_MODE_NORMAL,              \\
        \&.iir_filter                 = BMP280_IIR_FILTER_OFF,                 \\
        \&.pressure_oversampling      = BMP280_PRESSURE_OVERSAMPLING_4X,       \\
        \&.temperature_oversampling   = BMP280_TEMPERATURE_OVERSAMPLING_4X,    \\
        \&.standby_time               = BMP280_STANDBY_TIME_250MS }
.PP
.fi

.PP
Macro that initializes \fR\fBbmp280_config_t\fP\fP to default configuration settings\&. public macro definitions 
.SS "#define I2C_BMP280_DEV_CLK_SPD   UINT32_C(100000)"

.PP
bmp280 I2C default clock frequency (100KHz) dependency includes public constant definitions 
.SS "#define I2C_BMP390_CONFIG_DEFAULT"
\fBValue:\fP
.nf
        {                                          \\
        \&.i2c_address                = I2C_BMP390_DEV_ADDR_HI,                \\
        \&.i2c_clock_speed            = I2C_BMP390_DEV_CLK_SPD,                \\
        \&.power_mode                 = BMP390_POWER_MODE_FORCED,              \\
        \&.iir_filter                 = BMP390_IIR_FILTER_OFF,                 \\
        \&.pressure_oversampling      = BMP390_PRESSURE_OVERSAMPLING_8X,       \\
        \&.temperature_oversampling   = BMP390_TEMPERATURE_OVERSAMPLING_8X,    \\
        \&.output_data_rate           = BMP390_ODR_40MS }
.PP
.fi

.SS "#define I2C_CCS811_CONFIG_DEFAULT"
\fBValue:\fP
.nf
        {                                           \\
        \&.i2c_address                = I2C_CCS811_DEV_ADDR_LO,                   \\
        \&.i2c_clock_speed            = I2C_CCS811_DEV_CLK_SPD,                   \\
        \&.wake_io_enabled            = false,                                    \\
        \&.reset_io_enabled           = false,                                    \\
        \&.irq_threshold_enabled      = false,                                    \\
        \&.irq_data_ready_enabled     = false,                                    \\
        \&.drive_mode                 = CCS811_DRIVE_MODE_CONSTANT_POWER_IAQ,     \\
        \&.set_environmental_data     = false }
.PP
.fi

.SS "#define I2C_ENS160_CONFIG_DEFAULT"
\fBValue:\fP
.nf
        {                                             \\
        \&.i2c_address                = I2C_ENS160_DEV_ADDR_HI,                   \\
        \&.i2c_clock_speed            = I2C_ENS160_DEV_CLK_SPD,                   \\
        \&.irq_enabled                = false,                                    \\
        \&.irq_data_enabled           = false,                                    \\
        \&.irq_gpr_enabled            = false,                                    \\
        \&.irq_pin_driver             = ENS160_INT_PIN_DRIVE_OPEN_DRAIN,          \\
        \&.irq_pin_polarity           = ENS160_INT_PIN_POLARITY_ACTIVE_LO }
.PP
.fi

.PP
Macro that initializes \fRi2c_ens160_config_t\fP to default configuration settings\&. Parameter Range TVOC 0\&.\&.65,000 ppb (Total Volatile Organic Compounds) eCO2 400\&.\&.65,00 ppm (Equivalent Carbon Dioxide) AQI-UBA 1\&.\&.5 (UBA Air Quality Index) 
.SS "#define I2C_HDC1080_CONFIG_DEFAULT"
\fBValue:\fP
.nf
        {                                            \\
        \&.i2c_address                = I2C_HDC1080_DEV_ADDR_0,                   \\
        \&.i2c_clock_speed            = I2C_HDC1080_DEV_CLK_SPD,                  \\
        \&.temperature_resolution     = HDC1080_TEMPERATURE_RESOLUTION_14BIT,     \\
        \&.humidity_resolution        = HDC1080_HUMIDITY_RESOLUTION_14BIT,    }
.PP
.fi

.PP
Macro that initializes \fRi2c_hdc1080_config_t\fP to default configuration settings\&. 
.SS "#define I2C_HMC5883L_CONFIG_DEFAULT"
\fBValue:\fP
.nf
        {                                   \\
        \&.i2c_address                    = I2C_HMC5883L_DEV_ADDR,        \\
        \&.i2c_clock_speed                = I2C_HMC5883L_DEV_CLK_SPD,     \\
        \&.mode                           = HMC5883L_MODE_CONTINUOUS, \\
        \&.sample                         = HMC5883L_SAMPLE_4,        \\
        \&.rate                           = HMC5883L_DATA_RATE_15_00, \\
        \&.gain                           = HMC5883L_GAIN_390,        \\
        \&.bias                           = HMC5883L_BIAS_NORMAL,     \\
        \&.declination                    = \-16\&.0f }
.PP
.fi

.SS "#define I2C_INA226_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                                     \\
    \&.i2c_address                = I2C_INA226_ADDR_GND_GND,              \\
    \&.i2c_clock_speed            = I2C_INA226_DEV_CLK_SPD,               \\
    \&.averaging_mode             = INA226_AVG_MODE_1,                    \\
    \&.shunt_voltage_conv_time    = INA226_VOLT_CONV_TIME_1_1MS,          \\
    \&.bus_voltage_conv_time      = INA226_VOLT_CONV_TIME_1_1MS,          \\
    \&.operating_mode             = INA226_OP_MODE_CONT_SHUNT_BUS,        \\
    \&.shunt_resistance           = 0\&.002,                                \\
    \&.max_current                = 0\&.5                                   \\
    }
.PP
.fi

.SS "#define I2C_LTR390UV_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                       \\
    \&.i2c_address               = I2C_LTR390UV_DEV_ADDR,     \\
    \&.i2c_clock_speed           = I2C_LTR390UV_DEV_CLK_SPD,  \\
    \&.window_factor             = 1,                         \\
    \&.als_sensor_resolution     = LTR390UV_SR_18BIT,         \\
    \&.als_measurement_rate      = LTR390UV_MR_100MS,         \\
    \&.als_measurement_gain      = LTR390UV_MG_X3,            \\
    \&.uvs_sensor_resolution     = LTR390UV_SR_18BIT,         \\
    \&.uvs_measurement_rate      = LTR390UV_MR_100MS,         \\
    \&.uvs_measurement_gain      = LTR390UV_MG_X3,            }
.PP
.fi

.PP
Macro that initializes \fR\fBltr390uv_config_t\fP\fP to default configuration settings\&. 
.SS "#define I2C_MAX30105_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                   \\
    \&.i2c_address            = I2C_MAX30105_DEV_ADDR,    \\
    \&.i2c_clock_speed        = I2C_MAX30105_DEV_CLK_SPD, \\
    }
.PP
.fi

.SS "#define I2C_MLX90614_CONFIG_DEFAULT"
\fBValue:\fP
.nf
        {                        \\
        \&.i2c_address            = I2C_MLX90614_DEV_ADDR,     \\
        \&.i2c_clock_speed        = I2C_MLX90614_DEV_CLK_SPD }
.PP
.fi

.SS "#define I2C_MMC56X3_CONFIG_DEFAULT"
\fBValue:\fP
.nf
        {                                 \\
        \&.i2c_address                    = I2C_MMC56X3_DEV_ADDR,      \\
        \&.i2c_clock_speed                = I2C_MMC56X3_DEV_CLK_SPD,   \\
        \&.data_rate                      = 0,                         \\
        \&.continuous_mode_enabled        = false,                     \\
        \&.declination                    = \-16\&.0f }
.PP
.fi

.PP
Macro that initializes \fR\fBmmc56x3_config_t\fP\fP to default configuration settings\&. 
.SS "#define I2C_MPU6050_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                        \\
    \&.i2c_address                = I2C_MPU6050_DEV_ADDR_L,        \\
    \&.i2c_clock_speed            = I2C_MPU6050_DEV_CLK_SPD,             \\
    \&.low_pass_filter            = MPU6050_DIGITAL_LP_FILTER_ACCEL_260KHZ_GYRO_256KHZ,    \\
    \&.gyro_clock_source          = MPU6050_GYRO_CS_PLL_X_AXIS_REF,   \\
    \&.gyro_full_scale_range      = MPU6050_GYRO_FS_RANGE_500DPS,     \\
    \&.accel_full_scale_range     = MPU6050_ACCEL_FS_RANGE_4G }
.PP
.fi

.SS "#define I2C_SGP41_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                   \\
    \&.i2c_address        = I2C_SGP4X_DEV_ADDR,        \\
    \&.i2c_clock_speed    = I2C_SGP4X_DEV_CLK_SPD,     \\
    \&.dev_version        = SGP4X_VERSION_SGP41 }
.PP
.fi

.SS "#define I2C_SHT4X_CONFIG_DEFAULT"
\fBValue:\fP
.nf
        {                      \\
        \&.i2c_address    = I2C_SHT4X_DEV_ADDR_LO,        \\
        \&.i2c_clock_speed= I2C_SHT4X_DEV_CLK_SPD,        \\
        \&.heater_mode    = SHT4X_HEATER_OFF,             \\
        \&.repeat_mode    = SHT4X_REPEAT_HIGH, }
.PP
.fi

.PP
Macro that initializes \fRi2c_sht4x_config_t\fP to default configuration settings\&. public macro definitions 
.SS "#define I2C_SHT4X_DEV_CLK_SPD   UINT32_C(100000)"

.PP
sht4x i2c default scl clock frequency (100KHz) dependency includes public constant definitions 
.SS "#define I2C_SSD1306_128x128_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {               \\
    \&.i2c_address                 = I2C_SSD1306_DEV_ADDR,     \\
    \&.i2c_clock_speed         = I2C_SSD1306_DEV_CLK_SPD,  \\
    \&.panel_size                 = SSD1306_PANEL_128x128, \\
    \&.offset_x                   = 0,                     \\
    \&.flip_enabled               = false }
.PP
.fi

.PP
Macro that initializes \fR\fBssd1306_config_t\fP\fP to default configuration settings for a 128x128 display\&. 
.SS "#define I2C_SSD1306_128x32_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {               \\
    \&.i2c_address                 = I2C_SSD1306_DEV_ADDR,     \\
    \&.i2c_clock_speed         = I2C_SSD1306_DEV_CLK_SPD,  \\
    \&.panel_size                 = SSD1306_PANEL_128x32,      \\
    \&.offset_x                   = 0,                     \\
    \&.flip_enabled               = false }
.PP
.fi

.PP
Macro that initializes \fR\fBssd1306_config_t\fP\fP to default configuration settings for a 128x32 display\&. public macro definitions 
.SS "#define I2C_SSD1306_128x64_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {               \\
    \&.i2c_address                 = I2C_SSD1306_DEV_ADDR,     \\
    \&.i2c_clock_speed         = I2C_SSD1306_DEV_CLK_SPD,  \\
    \&.panel_size                 = SSD1306_PANEL_128x64,      \\
    \&.offset_x                   = 0,                     \\
    \&.flip_enabled               = false }
.PP
.fi

.PP
Macro that initializes \fR\fBssd1306_config_t\fP\fP to default configuration settings for a 128x64 display\&. 
.SS "#define I2C_SSD1306_DEV_CLK_SPD   UINT32_C(100000)"

.PP
ssd1306 I2C default clock frequency (100KHz) dependency includes public constant definitions 
.SS "#define I2C_TLV493D_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                                    \\
    \&.i2c_address                = I2C_TLV493D_DEV_ADDR_LO,              \\
    \&.i2c_clock_speed            = I2C_TLV493D_DEV_CLK_SPD,             \\
    \&.parity_test_enabled        = true,                                 \\
    \&.power_mode                 = TLV493D_LOW_POWER_MODE,   \\
    \&.irq_pin_enabled            = true }
.PP
.fi

.SS "#define I2C_VEML6040_CONFIG_DEFAULT"
\fBValue:\fP
.nf
            {                                       \\
            \&.i2c_address                = I2C_VEML6040_DEV_ADDR,            \\
            \&.i2c_clock_speed            = I2C_VEML6040_DEV_CLK_SPD,         \\
            \&.integration_time           = VEML6040_INTEGRATION_TIME_160MS,  \\
            \&.shutdown_enabled           = false,                            \\
            \&.mode                       = VEML6040_MODE_AUTO,               \\
            \&.trigger_method             = VEML6040_TRIGGER_NONE,            \\
        }
.PP
.fi

.PP
VEML6040 device configuration initialization default macro\&. 
.SS "#define I2C_VEML7700_CONFIG_DEFAULT"
\fBValue:\fP
.nf
            {                                               \\
            \&.i2c_address                = I2C_VEML7700_DEV_ADDR,                    \\
            \&.i2c_clock_speed            = I2C_VEML7700_DEV_CLK_SPD,                 \\
            \&.gain                       = VEML7700_GAIN_DIV_4,                      \\
            \&.integration_time           = VEML7700_INTEGRATION_TIME_400MS,          \\
            \&.persistence_protect        = VEML7700_PERSISTENCE_PROTECTION_4,        \\
            \&.irq_enabled                = true,                                     \\
            \&.power_disabled             = false,                                    \\
            \&.power_saving_enabled       = false,                                    \\
            \&.power_saving_mode          = VEML7700_POWER_SAVING_MODE_1 }
.PP
.fi

.PP
VEML7700 device configuration initialization default\&. 
.SS "#define OWB_DS18B20_CONFIG_DEFAULT"
\fBValue:\fP
.nf
    {                \\
    \&.resolution      = DS18B20_RESOLUTION_10BIT,    \\
    \&.trigger_enabled = false }
.PP
.fi

.SS "#define STR( x)"
\fBValue:\fP
.nf
STR_QUOTES( x )
.PP
.fi
Macro to create a string of x parameter with all macros fully expanded\&. 
.SS "#define STR_QUOTES( x)"
\fBValue:\fP
.nf
#x
.PP
.fi
public macro definitions Macro to print x parameter as a string i\&.e\&. enclose x in double quotes\&. 
.SS "#define TBI2CXXX_FW_VERSION_INT32"
\fBValue:\fP
.nf
        TBI2CXXX_FW_VERSION_PARAMS_INT32(TBI2CXXX_FW_VERSION_MAJOR,   \\
                TBI2CXXX_FW_VERSION_MINOR,   \\
                TBI2CXXX_FW_VERSION_PATCH)
.PP
.fi
Macro to generate current firmware version numbers (major, minor, patch) as an integer (\fRint32_t\fP) value that can be used for comparison purposes\&.

.PP
As an example, [COMPONENT]_FW_VERSION_INT32 >= [COMPONENT]_FW_VERSION_PARAMS_INT32(4, 0, 0)\&. 
.SS "#define TBI2CXXX_FW_VERSION_MAJOR   1"
public constant definitions Major version number (X\&.x\&.x) 
.SS "#define TBI2CXXX_FW_VERSION_MINOR   1"
Minor version number (x\&.X\&.x) 
.SS "#define TBI2CXXX_FW_VERSION_PARAMS_INT32( major,  minor,  patch)"
\fBValue:\fP
.nf
        ((major << 16) | (minor << 8) | (patch))
.PP
.fi
Macro to convert firmware version parameters (major, minor, patch numbers) into an integer (\fRint32_t\fP) value that can be used for comparison purposes\&.

.PP
As an example, [COMPONENT]_FW_VERSION_INT32 >= [COMPONENT]_FW_VERSION_PARAMS_INT32(4, 0, 0)\&. 
.SS "#define TBI2CXXX_FW_VERSION_PATCH   6"
Patch version number (x\&.x\&.X) 
.SS "#define TBI2CXXX_FW_VERSION_STR"
\fBValue:\fP
.nf
        STR( TBI2CXXX_FW_VERSION_MAJOR ) "\&." \\
        STR( TBI2CXXX_FW_VERSION_MINOR ) "\&." \\
        STR( TBI2CXXX_FW_VERSION_PATCH )
.PP
.fi
Macro to generate current firmware version numbers (major, minor, patch) into a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef enum \fBahtxx_sensor_types_e\fP \fBahtxx_sensor_types_t\fP"

.PP
AHTXX sensor types enumerator definition\&. public enumerator, union, and structure definitions 

.PP
\fBNote\fP
.RS 4
AHTXX types vary slightly with respect to setup and initialization according to available documentation\&. The AHT10 and AHT20 are setup through the initialization command\&. The AHT21, AHT25 and AHT30 are setup by resetting 0x1b, 0x1c, and 0x1e initializing registers\&. 
.RE
.PP

.SS "typedef struct \fBak8975_magnetic_axes_data_s\fP \fBak8975_magnetic_axes_data_t\fP"

.PP
AK8975 processed compass axes data structure and axes have a range +/-1229 uT\&. 
.PP
\fBNote\fP
.RS 4
AK8975 data overflow of axes (x, y, z) is a sum of the absolute values for each axis and the sum of the axes should be smaller than 2400 uT (|X|+|Y|+|Z| < 2400 uT)\&. 
.RE
.PP

.SS "typedef enum \fBas3935_analog_frontends_e\fP \fBas3935_analog_frontends_t\fP"

.PP
AS3935 enumerator and structure declarations\&. AS3935 analog frontends (AFE) REG0x00[5:1] enumerator\&. 
.SS "typedef enum \fBbmp280_iir_filters_e\fP \fBbmp280_iir_filters_t\fP"

.PP
BMP280 IIR filters coefficient enumerator definition\&. public enumerator, union, and structure definitions 
.SS "typedef enum \fBccs811_drive_modes_e\fP \fBccs811_drive_modes_t\fP"
CCS811 drive modes enumerator\&. 
.SS "typedef enum \fBccs811_firmware_modes_e\fP \fBccs811_firmware_modes_t\fP"
CCS811 firmware modes enumerator\&. 
.SS "typedef struct \fBhmc5883l_axes_data_s\fP \fBhmc5883l_axes_data_t\fP"
HMC5883L raw measurement result 
.SS "typedef enum \fBhmc5883l_biases_e\fP \fBhmc5883l_biases_t\fP"
HMC5883L possible measurement mode of the device (bias) 
.SS "typedef enum \fBhmc5883l_calibration_options_e\fP \fBhmc5883l_calibration_options_t\fP"
HMC5883L possible calibration options 
.SS "typedef enum \fBhmc5883l_data_rates_e\fP \fBhmc5883l_data_rates_t\fP"
HMC5883L possible data output rate in continuous measurement mode 
.SS "typedef enum \fBhmc5883l_gains_e\fP \fBhmc5883l_gains_t\fP"
HMC5883L possible device gains 
.SS "typedef struct \fBhmc5883l_magnetic_axes_data_s\fP \fBhmc5883l_magnetic_axes_data_t\fP"
HMC5883L measurement result, milligauss 
.SS "typedef enum \fBhmc5883l_modes_e\fP \fBhmc5883l_modes_t\fP"
HMC5883L possible operating modes 
.SS "typedef enum \fBhmc5883l_sample_averages_e\fP \fBhmc5883l_sample_averages_t\fP"
HMC5883L number of samples averaged per measurement 
.SS "typedef enum \fBina226_averaging_modes_e\fP \fBina226_averaging_modes_t\fP"

.PP
Averaging modes enumerator for ADC resolution/averaging\&. ADC resolution/averaging 
.SS "typedef struct \fBs12sd_config_s\fP \fBs12sd_config_t\fP"

.PP
S12SD configuration structure definition\&. public enumerator, union, and structure definitions 
.SS "typedef enum \fBtlv493d_power_modes_e\fP \fBtlv493d_power_modes_t\fP"

.PP
TLV493D power modes enumerator\&. Fast, Low Power, Low Power Period, Measurement Time 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBahtxx_sensor_types_e\fP"

.PP
AHTXX sensor types enumerator definition\&. public enumerator, union, and structure definitions 

.PP
\fBNote\fP
.RS 4
AHTXX types vary slightly with respect to setup and initialization according to available documentation\&. The AHT10 and AHT20 are setup through the initialization command\&. The AHT21, AHT25 and AHT30 are setup by resetting 0x1b, 0x1c, and 0x1e initializing registers\&. 
.RE
.PP

.SS "enum \fBak8975_operating_modes_e\fP"

.PP
AK8975 operating modes enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIAK8975_OPMODE_POWER_DOWN \fP
power-down mode 
.TP
\f(BIAK8975_OPMODE_SINGLE_MEAS \fP
single measurement mode 
.TP
\f(BIAK8975_OPMODE_SELF_TEST \fP
self-test mode 
.TP
\f(BIAK8975_OPMODE_FUSE_ROM \fP
fuse rom access mode 
.SS "enum \fBas3935_analog_frontends_e\fP"

.PP
AS3935 enumerator and structure declarations\&. AS3935 analog frontends (AFE) REG0x00[5:1] enumerator\&. 
.SS "enum \fBas3935_interrupt_states_e\fP"

.PP
AS3935 interrupt states REG0x03[3:0] enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIAS3935_INT_NOISE \fP
noise level too high 
.TP
\f(BIAS3935_INT_DISTURBER \fP
disturber detected 
.TP
\f(BIAS3935_INT_LIGHTNING \fP
lightning detected 
.TP
\f(BIAS3935_INT_NONE \fP
no interrupt 
.SS "enum \fBas3935_noise_levels_e\fP"

.PP
AS3935 noise floor generator and evaluation REG0x01[6:4] enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIAS3935_NOISE_LEVEL_390_28 \fP
390 uVrms outdoor and 28 uVrms indoor 
.TP
\f(BIAS3935_NOISE_LEVEL_630_45 \fP
630 uVrms outdoor and 45 uVrms indoor 
.TP
\f(BIAS3935_NOISE_LEVEL_860_62 \fP
860 uVrms outdoor and 63 uVrms indoor (default) 
.TP
\f(BIAS3935_NOISE_LEVEL_1100_78 \fP
1100 uVrms outdoor and 78 uVrms indoor 
.TP
\f(BIAS3935_NOISE_LEVEL_1140_95 \fP
1140 uVrms outdoor and 95 uVrms indoor 
.TP
\f(BIAS3935_NOISE_LEVEL_1570_112 \fP
1570 uVrms outdoor and 112 uVrms indoor 
.TP
\f(BIAS3935_NOISE_LEVEL_1800_130 \fP
1800 uVrms outdoor and 130 uVrms indoor 
.TP
\f(BIAS3935_NOISE_LEVEL_2000_146 \fP
2000 uVrms outdoor and 146 uVrms indoor 
.SS "enum \fBas7341_als_modes_e\fP"

.PP
AS7341 ambient light sensing mode enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIAS7341_ALS_SPM_MODE \fP
as7341 spectral measurement, normal mode 
.TP
\f(BIAS7341_ALS_SYNS_MODE \fP
as7341 SYNS mode 
.TP
\f(BIAS7341_ALS_RESERVED_MODE \fP
as7341 reserved, do not use 
.TP
\f(BIAS7341_ALS_SYND_MODE \fP
as7341 SYND mode, use spectra data registers 0x60 to 0x6F in this mode 
.SS "enum \fBas7341_flicker_detection_states_e\fP"

.PP
AS7341 flicker detection states enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIAS7341_FLICKER_DETECTION_INVALID \fP
flicker detection is invalid 
.TP
\f(BIAS7341_FLICKER_DETECTION_UNKNOWN \fP
flicker detection valid but unknown 
.TP
\f(BIAS7341_FLICKER_DETECTION_SATURATED \fP
flicker detection is saturated 
.TP
\f(BIAS7341_FLICKER_DETECTION_100HZ \fP
flicker detection at 100 hz 
.TP
\f(BIAS7341_FLICKER_DETECTION_120HZ \fP
flicker detection at 120 hz 
.SS "enum \fBas7341_led_drive_strengths_e\fP"

.PP
AS7341 led driving strengths enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIAS7341_LED_DRIVE_STRENGTH_4MA \fP
as7341 
.TP
\f(BIAS7341_LED_DRIVE_STRENGTH_6MA \fP
as7341 
.TP
\f(BIAS7341_LED_DRIVE_STRENGTH_8MA \fP
as7341 
.TP
\f(BIAS7341_LED_DRIVE_STRENGTH_10MA \fP
as7341 
.TP
\f(BIAS7341_LED_DRIVE_STRENGTH_12MA \fP
as7341 (default) 
.TP
\f(BIAS7341_LED_DRIVE_STRENGTH_256MA \fP
as7341 
.TP
\f(BIAS7341_LED_DRIVE_STRENGTH_258MA \fP
as7341 
.SS "enum \fBas7341_smux_commands_e\fP"

.PP
AS7341 available SMUX commands enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIAS7341_SMUX_CMD_ROM_RESET \fP
ROM code initialization of SMUX\&. 
.TP
\f(BIAS7341_SMUX_CMD_READ \fP
Read SMUX configuration to RAM from SMUX chain\&. 
.TP
\f(BIAS7341_SMUX_CMD_WRITE \fP
Write SMUX configuration from RAM to SMUX chain\&. 
.SS "enum \fBbh1750_measurement_modes_e\fP"

.PP
BH1750 measurement modes enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBH1750_MODE_OM_HI_RESOLUTION \fP
one time measurement high resolution (1 lx) mode, goes into power down mode after measurement 
.TP
\f(BIBH1750_MODE_OM_HI2_RESOLUTION \fP
one time measurement high resolution (0\&.5 lx) mode 2, goes into power down mode after measurement 
.TP
\f(BIBH1750_MODE_OM_LO_RESOLUTION \fP
one time measurement low resolution (4 lx) mode, goes into power down mode after measurement 
.TP
\f(BIBH1750_MODE_CM_HI_RESOLUTION \fP
continuous measurement high resolution (1 lx) mode 
.TP
\f(BIBH1750_MODE_CM_HI2_RESOLUTION \fP
continuous measurement high resolution (0\&.5 lx) mode 2 
.TP
\f(BIBH1750_MODE_CM_LO_RESOLUTION \fP
continuous measurement low resolution (4 lx) mode 
.SS "enum \fBbme680_humidity_oversampling_e\fP"

.PP
BME680 humidity oversampling enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBME680_HUMIDITY_OVERSAMPLING_SKIPPED \fP
skipped, no measurement, output set to 0x80000 
.TP
\f(BIBME680_HUMIDITY_OVERSAMPLING_1X \fP
ultra low power 
.TP
\f(BIBME680_HUMIDITY_OVERSAMPLING_2X \fP
low power 
.TP
\f(BIBME680_HUMIDITY_OVERSAMPLING_4X \fP
standard 
.TP
\f(BIBME680_HUMIDITY_OVERSAMPLING_8X \fP
high resolution 
.TP
\f(BIBME680_HUMIDITY_OVERSAMPLING_16X \fP
ultra high resolution 
.SS "enum \fBbme680_power_modes_e\fP"

.PP
BME680 power modes enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBME680_POWER_MODE_SLEEP \fP
sleep mode, default after power-up 
.TP
\f(BIBME680_POWER_MODE_FORCED \fP
measurement is initiated by user 
.TP
\f(BIBME680_POWER_MODE_PARALLEL \fP
parallel mode, gas and TPH measurements are done in parallel 
.TP
\f(BIBME680_POWER_MODE_SEQUENTIAL \fP
sequential mode, gas and TPH measurements are done in sequence 
.SS "enum \fBbme680_pressure_oversampling_e\fP"

.PP
BME680 pressure oversampling enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBME680_PRESSURE_OVERSAMPLING_SKIPPED \fP
skipped, no measurement, output set to 0x80000 
.TP
\f(BIBME680_PRESSURE_OVERSAMPLING_1X \fP
ultra low power 
.TP
\f(BIBME680_PRESSURE_OVERSAMPLING_2X \fP
low power 
.TP
\f(BIBME680_PRESSURE_OVERSAMPLING_4X \fP
standard 
.TP
\f(BIBME680_PRESSURE_OVERSAMPLING_8X \fP
high resolution 
.TP
\f(BIBME680_PRESSURE_OVERSAMPLING_16X \fP
ultra high resolution 
.SS "enum \fBbme680_temperature_oversampling_e\fP"

.PP
BME680 temperature oversampling enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBME680_TEMPERATURE_OVERSAMPLING_SKIPPED \fP
skipped, no measurement, output set to 0x80000 
.TP
\f(BIBME680_TEMPERATURE_OVERSAMPLING_1X \fP
ultra low power 
.TP
\f(BIBME680_TEMPERATURE_OVERSAMPLING_2X \fP
low power 
.TP
\f(BIBME680_TEMPERATURE_OVERSAMPLING_4X \fP
standard 
.TP
\f(BIBME680_TEMPERATURE_OVERSAMPLING_8X \fP
high resolution 
.TP
\f(BIBME680_TEMPERATURE_OVERSAMPLING_16X \fP
ultra high resolution 
.SS "enum \fBbmp280_iir_filters_e\fP"

.PP
BMP280 IIR filters coefficient enumerator definition\&. public enumerator, union, and structure definitions 
.SS "enum \fBbmp280_power_modes_e\fP"

.PP
BMP280 power modes enumerator definition\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBMP280_POWER_MODE_SLEEP \fP
sleep mode, default after power-up 
.TP
\f(BIBMP280_POWER_MODE_FORCED \fP
measurement is initiated by user 
.TP
\f(BIBMP280_POWER_MODE_FORCED1 \fP
measurement is initiated by user 
.TP
\f(BIBMP280_POWER_MODE_NORMAL \fP
continuously cycles between active measurement and inactive (standby-time) periods 
.SS "enum \fBbmp280_pressure_oversampling_e\fP"

.PP
BMP280 pressure oversampling enumerator definition\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBMP280_PRESSURE_OVERSAMPLING_SKIPPED \fP
skipped, no measurement, output set to 0x80000 
.TP
\f(BIBMP280_PRESSURE_OVERSAMPLING_1X \fP
ultra low power 
.TP
\f(BIBMP280_PRESSURE_OVERSAMPLING_2X \fP
low power 
.TP
\f(BIBMP280_PRESSURE_OVERSAMPLING_4X \fP
standard 
.TP
\f(BIBMP280_PRESSURE_OVERSAMPLING_8X \fP
high resolution 
.TP
\f(BIBMP280_PRESSURE_OVERSAMPLING_16X \fP
ultra high resolution 
.SS "enum \fBbmp280_standby_times_e\fP"

.PP
BMP280 stand-by times enumerator definition\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBMP280_STANDBY_TIME_0_5MS \fP
stand by time 0\&.5ms 
.TP
\f(BIBMP280_STANDBY_TIME_62_5MS \fP
stand by time 62\&.5ms 
.TP
\f(BIBMP280_STANDBY_TIME_125MS \fP
stand by time 125ms 
.TP
\f(BIBMP280_STANDBY_TIME_250MS \fP
stand by time 250ms 
.TP
\f(BIBMP280_STANDBY_TIME_500MS \fP
stand by time 500ms 
.TP
\f(BIBMP280_STANDBY_TIME_1000MS \fP
stand by time 1s 
.TP
\f(BIBMP280_STANDBY_TIME_2000MS \fP
stand by time 2s BMP280, 10ms BME280 
.TP
\f(BIBMP280_STANDBY_TIME_4000MS \fP
stand by time 4s BMP280, 20ms BME280 
.SS "enum \fBbmp280_temperature_oversampling_e\fP"

.PP
BMP280 temperature oversampling enumerator definition\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBMP280_TEMPERATURE_OVERSAMPLING_SKIPPED \fP
skipped, no measurement, output set to 0x80000 
.TP
\f(BIBMP280_TEMPERATURE_OVERSAMPLING_1X \fP
ultra low power 
.TP
\f(BIBMP280_TEMPERATURE_OVERSAMPLING_2X \fP
low power 
.TP
\f(BIBMP280_TEMPERATURE_OVERSAMPLING_4X \fP
standard 
.TP
\f(BIBMP280_TEMPERATURE_OVERSAMPLING_8X \fP
high resolution 
.TP
\f(BIBMP280_TEMPERATURE_OVERSAMPLING_16X \fP
ultra high resolution 
.TP
\f(BIBMP280_TEMPERATURE_OVERSAMPLING_16X1 \fP
ultra high resolution 
.TP
\f(BIBMP280_TEMPERATURE_OVERSAMPLING_16X2 \fP
ultra high resolution 
.SS "enum \fBbmp390_output_data_rates_e\fP"

.PP
BMP390 output data rates enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBMP390_ODR_5MS \fP
sampling period 5ms 
.TP
\f(BIBMP390_ODR_10MS \fP
sampling period 10ms 
.TP
\f(BIBMP390_ODR_20MS \fP
sampling period 20ms 
.TP
\f(BIBMP390_ODR_40MS \fP
sampling period 40ms 
.TP
\f(BIBMP390_ODR_80MS \fP
sampling period 80ms 
.TP
\f(BIBMP390_ODR_160MS \fP
sampling period 160ms 
.TP
\f(BIBMP390_ODR_320MS \fP
sampling period 320ms 
.TP
\f(BIBMP390_ODR_640MS \fP
sampling period 640ms 
.SS "enum \fBbmp390_power_modes_e\fP"

.PP
BMP390 power modes enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBMP390_POWER_MODE_SLEEP \fP
sleep mode, default after power-up 
.TP
\f(BIBMP390_POWER_MODE_FORCED \fP
measurement is initiated by user 
.TP
\f(BIBMP390_POWER_MODE_FORCED1 \fP
measurement is initiated by user 
.TP
\f(BIBMP390_POWER_MODE_NORMAL \fP
continuously cycles between active measurement and inactive (standby-time) periods 
.SS "enum \fBbmp390_pressure_oversampling_e\fP"

.PP
BMP390 pressure oversampling enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBMP390_PRESSURE_OVERSAMPLING_SKIPPED \fP
skipped, no measurement, output set to 0x80000 
.TP
\f(BIBMP390_PRESSURE_OVERSAMPLING_2X \fP
ultra low power 
.TP
\f(BIBMP390_PRESSURE_OVERSAMPLING_4X \fP
low power 
.TP
\f(BIBMP390_PRESSURE_OVERSAMPLING_8X \fP
standard 
.TP
\f(BIBMP390_PRESSURE_OVERSAMPLING_16X \fP
high resolution 
.TP
\f(BIBMP390_PRESSURE_OVERSAMPLING_32X \fP
ultra high resolution 
.SS "enum \fBbmp390_temperature_oversampling_e\fP"

.PP
BMP390 temperature oversampling enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBMP390_TEMPERATURE_OVERSAMPLING_SKIPPED \fP
skipped, no measurement, output set to 0x80000 
.TP
\f(BIBMP390_TEMPERATURE_OVERSAMPLING_2X \fP
ultra low power 
.TP
\f(BIBMP390_TEMPERATURE_OVERSAMPLING_4X \fP
low power 
.TP
\f(BIBMP390_TEMPERATURE_OVERSAMPLING_8X \fP
standard 
.TP
\f(BIBMP390_TEMPERATURE_OVERSAMPLING_16X \fP
high resolution 
.TP
\f(BIBMP390_TEMPERATURE_OVERSAMPLING_32X \fP
ultra high resolution 
.SS "enum \fBccs811_drive_modes_e\fP"
CCS811 drive modes enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BICCS811_DRIVE_MODE_IDLE \fP
idle (measurements are disabled in this mode) 
.TP
\f(BICCS811_DRIVE_MODE_CONSTANT_POWER_IAQ \fP
constant power mode, IAQ measurement every second 
.TP
\f(BICCS811_DRIVE_MODE_PULSE_HEATING_IAQ \fP
pulse heating mode IAQ measurement every 10 seconds 
.TP
\f(BICCS811_DRIVE_MODE_LP_PULSE_HEATING_IAQ \fP
low power pulse heating mode IAQ measurement every 60 seconds 
.TP
\f(BICCS811_DRIVE_MODE_CONSTANT_POWER \fP
constant power mode, sensor measurement every 250ms 
.SS "enum \fBccs811_firmware_modes_e\fP"
CCS811 firmware modes enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BICCS811_FW_MODE_BOOT \fP
firmware is in boot mode, this allows new firmware to be loaded 
.TP
\f(BICCS811_FW_MODE_APP \fP
formware is in application mode, deivce is ready to take ADC measurements 
.SS "enum \fBdatatable_column_data_types_tag\fP"

.PP
Data-table column data-types enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIDATATABLE_COLUMN_DATA_ID \fP
record identifier column data-type, system default, see \fRdatatable_id_data_type_t\fP for data-type structure\&. 
.TP
\f(BIDATATABLE_COLUMN_DATA_TS \fP
record timestamp (date and time) column data type, system default, see \fRdatatable_ts_data_type_t\fP for data-type structure\&. 
.TP
\f(BIDATATABLE_COLUMN_DATA_VECTOR \fP
vector (u and v components) column data type, user-defined, see \fRdatatable_vector_data_type_t\fP for data-type structure\&. 
.TP
\f(BIDATATABLE_COLUMN_DATA_BOOL \fP
boolean column data type, user-defined, see \fRdatatable_bool_data_type_t\fP for data-type structure\&. 
.TP
\f(BIDATATABLE_COLUMN_DATA_FLOAT \fP
float 32-bit column data type, user-defined, see \fRdatatable_float_data_type_t\fP for data-type structure\&. 
.TP
\f(BIDATATABLE_COLUMN_DATA_INT16 \fP
int16 column data type, user-defined, see \fRdatatable_int16_data_type_t\fP for data-type structure\&. 
.SS "enum \fBdatatable_column_process_types_tag\fP"

.PP
Data-table column statistical process-types enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIDATATABLE_COLUMN_PROCESS_SMP \fP
a sample is stored at every processing interval 
.TP
\f(BIDATATABLE_COLUMN_PROCESS_AVG \fP
stored samples are averaged over the processing interval 
.TP
\f(BIDATATABLE_COLUMN_PROCESS_MIN \fP
stored samples are analyzed for minimum over the processing interval 
.TP
\f(BIDATATABLE_COLUMN_PROCESS_MAX \fP
stored samples are analyzed for maximum over the processing interval 
.TP
\f(BIDATATABLE_COLUMN_PROCESS_MIN_TS \fP
stored samples are analyzed for minimum with timestamp over the processing interval 
.TP
\f(BIDATATABLE_COLUMN_PROCESS_MAX_TS \fP
stored samples are analyzed for maximum with timestamp over the processing interval 
.SS "enum \fBdatatable_data_storage_types_tag\fP"

.PP
Data-table data storage-types enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIDATATABLE_DATA_STORAGE_MEMORY_RING \fP
data-table ring memory performs a first-in first-out (FIFO) with the data-table 
.TP
\f(BIDATATABLE_DATA_STORAGE_MEMORY_RESET \fP
data-table memory reset performs a data-table reset when data-table is full 
.TP
\f(BIDATATABLE_DATA_STORAGE_MEMORY_STOP \fP
data-table memory stop pauses data storage when data-table is full 
.SS "enum \fBdatatable_event_types_tag\fP"

.PP
Data-table event types enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIDATATABLE_EVENT_INIT \fP
data-table initialized successfully 
.TP
\f(BIDATATABLE_EVENT_RESET_ROWS \fP
data-table rows were reset 
.TP
\f(BIDATATABLE_EVENT_RESET_SAMPLES \fP
data-table buffer samples were reset 
.TP
\f(BIDATATABLE_EVENT_FIFO_ROWS \fP
data-table rows underwent a FIFO operation 
.TP
\f(BIDATATABLE_EVENT_FIFO_SAMPLES \fP
data-table buffer samples underwent a FIFO operation 
.TP
\f(BIDATATABLE_EVENT_SAMPLE_PUSHED \fP
data-table sample was pushed onto the buffer samples stack 
.TP
\f(BIDATATABLE_EVENT_PROCESS \fP
data-table processed successfully 
.TP
\f(BIDATATABLE_EVENT_PROCESS_ELAPSED \fP
data-table processing time-into-interval has elapsed 
.SS "enum \fBds18b20_resolutions_e\fP"

.PP
DS18B20 supported resolutions enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIDS18B20_RESOLUTION_9BIT \fP
9bit, increment of 0\&.5°C, needs ~93\&.75ms convert time (Tconv/8) 
.TP
\f(BIDS18B20_RESOLUTION_10BIT \fP
10bit, increment of 0\&.25°C, needs ~187\&.5ms convert time (Tconv/4) 
.TP
\f(BIDS18B20_RESOLUTION_11BIT \fP
11bit, increment of 0\&.125°C, needs ~375ms convert time (Tconv/2) 
.TP
\f(BIDS18B20_RESOLUTION_12BIT \fP
12bit, increment of 0\&.0625°C, needs ~750ms convert time (Tconv) 
.SS "enum \fBens160_aqi_uba_indexes_e\fP"

.PP
ENS160 air quality index of the uba enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIENS160_AQI_UBA_INDEX_UNKNOWN \fP
uba air quality index is unknown 
.TP
\f(BIENS160_AQI_UBA_INDEX_1 \fP
uba air quality index of 1 is excellent 
.TP
\f(BIENS160_AQI_UBA_INDEX_2 \fP
uba air quality index of 2 is good 
.TP
\f(BIENS160_AQI_UBA_INDEX_3 \fP
uba air quality index of 3 is moderate 
.TP
\f(BIENS160_AQI_UBA_INDEX_4 \fP
uba air quality index of 4 is poor 
.TP
\f(BIENS160_AQI_UBA_INDEX_5 \fP
uba air quality index of 5 is unhealthy 
.SS "enum \fBens160_commands_e\fP"

.PP
ENS160 commands enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIENS160_CMD_NORMAL \fP
ens160 normal operation command (default) 
.TP
\f(BIENS160_CMD_GET_FW_APPVER \fP
ens160 get firmware version command 
.TP
\f(BIENS160_CMD_CLEAR_GPR \fP
ens160 clear general purpose read registers command 
.SS "enum \fBens160_interrupt_pin_drivers_e\fP"

.PP
ENS160 interrupt pin drivers enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIENS160_INT_PIN_DRIVE_OPEN_DRAIN \fP
ens160 interrupt pin drive open drain 
.TP
\f(BIENS160_INT_PIN_DRIVE_PUSH_PULL \fP
ens160 interrupt pin drive push/pull 
.SS "enum \fBens160_interrupt_pin_polarities_e\fP"

.PP
ENS160 interrupt pin polarities enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIENS160_INT_PIN_POLARITY_ACTIVE_LO \fP
ens160 interrupt pin polarity active low (default) 
.TP
\f(BIENS160_INT_PIN_POLARITY_ACTIVE_HI \fP
ens160 interrupt pin polarity active high 
.SS "enum \fBens160_operating_modes_e\fP"

.PP
ENS160 operating modes enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIENS160_OPMODE_DEEP_SLEEP \fP
ens160 deep sleep mode (low-power standby) 
.TP
\f(BIENS160_OPMODE_IDLE \fP
ens160 idle mode (low-power) (default) 
.TP
\f(BIENS160_OPMODE_STANDARD \fP
ens160 standard gas sensing mode 
.TP
\f(BIENS160_OPMODE_RESET \fP
ens160 reset mode 
.SS "enum \fBens160_validity_flags_e\fP"

.PP
ENS160 validity flags enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIENS160_VALFLAG_NORMAL \fP
ens160 normal operation validity flag 
.TP
\f(BIENS160_VALFLAG_WARMUP \fP
ens160 warm-up phase validity flag (first 3-minutes after power-on) 
.TP
\f(BIENS160_VALFLAG_INITIAL_STARTUP \fP
ens160 initial start-up phase validity flag (first full hour of operation after power-on, once in the sensor's lifetime) 
.TP
\f(BIENS160_VALFLAG_INVALID_OUTPUT \fP
ens160 invalid output validity flag 
.SS "enum \fBhdc1080_acquisition_modes_e\fP"

.PP
HDC1080 acquisition modes enumerator definition\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIHDC1080_ACQUISITION_SINGLE \fP
acquisition in single mode for temperature or humidity 
.TP
\f(BIHDC1080_ACQUISITION_SEQUENCED \fP
acquisition in sequenced mode for both temperature and humidity 
.SS "enum \fBhdc1080_battery_states_e\fP"

.PP
HDC1080 battery states enumerator definition\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIHDC1080_BATT_VOLT_OVER_2_8V \fP
battery voltage is over 2\&.8 volts 
.TP
\f(BIHDC1080_BATT_VOLT_UNDER_2_8V \fP
battery voltage is under 2\&.8 volts 
.SS "enum \fBhdc1080_humidity_resolutions_e\fP"

.PP
HDC1080 humidity measurement resolutions enumerator definition\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIHDC1080_HUMIDITY_RESOLUTION_14BIT \fP
humidity measurement 14-bit resolution 
.TP
\f(BIHDC1080_HUMIDITY_RESOLUTION_11BIT \fP
humidity measurement 11-bit resolution 
.TP
\f(BIHDC1080_HUMIDITY_RESOLUTION_8BIT \fP
humidity measurement 8-bit resolution 
.SS "enum \fBhdc1080_temperature_resolutions_e\fP"

.PP
HDC1080 temperature measurement resolutions enumerator definition\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIHDC1080_TEMPERATURE_RESOLUTION_14BIT \fP
temperature measurement 14-bit resolution 
.TP
\f(BIHDC1080_TEMPERATURE_RESOLUTION_11BIT \fP
temperature measurement 11-bit resolution 
.SS "enum \fBhmc5883l_biases_e\fP"
HMC5883L possible measurement mode of the device (bias) 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIHMC5883L_BIAS_NORMAL \fP
Default flow, no bias\&. 
.TP
\f(BIHMC5883L_BIAS_POSITIVE \fP
Positive bias configuration all axes, used for self test (see datasheet) 
.TP
\f(BIHMC5883L_BIAS_NEGATIVE \fP
Negative bias configuration all axes, used for self test (see datasheet) 
.SS "enum \fBhmc5883l_calibration_options_e\fP"
HMC5883L possible calibration options 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIHMC5883L_CAL_GAIN_DIFF \fP
calculates the difference in the gain of the each axis magnetometer axis 
.TP
\f(BIHMC5883L_CAL_AXES_MEAN \fP
calculates the mean of each axes magnetic field, when the Magnetometer is rotated 360 degree 
.TP
\f(BIHMC5883L_CAL_BOTH \fP
do both 
.SS "enum \fBhmc5883l_data_rates_e\fP"
HMC5883L possible data output rate in continuous measurement mode 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIHMC5883L_DATA_RATE_00_75 \fP
0\&.75 Hz 
.TP
\f(BIHMC5883L_DATA_RATE_01_50 \fP
1\&.5 Hz 
.TP
\f(BIHMC5883L_DATA_RATE_03_00 \fP
3 Hz 
.TP
\f(BIHMC5883L_DATA_RATE_07_50 \fP
7\&.5 Hz 
.TP
\f(BIHMC5883L_DATA_RATE_15_00 \fP
15 Hz, default 
.TP
\f(BIHMC5883L_DATA_RATE_30_00 \fP
30 Hz 
.TP
\f(BIHMC5883L_DATA_RATE_75_00 \fP
75 Hz 
.TP
\f(BIHMC5883L_DATA_RATE_RESERVED \fP
220 Hz, HMC5983 only 
.SS "enum \fBhmc5883l_gains_e\fP"
HMC5883L possible device gains 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIHMC5883L_GAIN_1370 \fP
0\&.73 mG/LSb, range -0\&.88\&.\&.+0\&.88 G 
.TP
\f(BIHMC5883L_GAIN_1090 \fP
0\&.92 mG/LSb, range -1\&.3\&.\&.+1\&.3 G, default 
.TP
\f(BIHMC5883L_GAIN_820 \fP
1\&.22 mG/LSb, range -1\&.9\&.\&.+1\&.9 G 
.TP
\f(BIHMC5883L_GAIN_660 \fP
1\&.52 mG/LSb, range -2\&.5\&.\&.+2\&.5 G 
.TP
\f(BIHMC5883L_GAIN_440 \fP
2\&.27 mG/LSb, range -4\&.0\&.\&.+4\&.0 G 
.TP
\f(BIHMC5883L_GAIN_390 \fP
2\&.56 mG/LSb, range -4\&.7\&.\&.+4\&.7 G 
.TP
\f(BIHMC5883L_GAIN_330 \fP
3\&.03 mG/LSb, range -5\&.6\&.\&.+5\&.6 G 
.TP
\f(BIHMC5883L_GAIN_230 \fP
4\&.35 mG/LSb, range -8\&.1\&.\&.+8\&.1 G 
.SS "enum \fBhmc5883l_modes_e\fP"
HMC5883L possible operating modes 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIHMC5883L_MODE_CONTINUOUS \fP
Continuous mode\&. 
.TP
\f(BIHMC5883L_MODE_SINGLE \fP
Single measurement mode, default\&. 
.TP
\f(BIHMC5883L_MODE_IDLE \fP
Idle mode\&. 
.TP
\f(BIHMC5883L_MODE_IDLE2 \fP
Idle mode\&. 
.SS "enum \fBhmc5883l_sample_averages_e\fP"
HMC5883L number of samples averaged per measurement 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIHMC5883L_SAMPLE_1 \fP
1 sample, default 
.TP
\f(BIHMC5883L_SAMPLE_2 \fP
2 samples 
.TP
\f(BIHMC5883L_SAMPLE_4 \fP
4 samples 
.TP
\f(BIHMC5883L_SAMPLE_8 \fP
8 samples 
.SS "enum \fBina226_averaging_modes_e\fP"

.PP
Averaging modes enumerator for ADC resolution/averaging\&. ADC resolution/averaging 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIINA226_AVG_MODE_1 \fP
default 
.SS "enum \fBina226_operating_modes_e\fP"

.PP
Current conversion times enumerator for ADC resolution/averaging\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIINA226_OP_MODE_SHUTDOWN \fP
device is powered down 
.TP
\f(BIINA226_OP_MODE_TRIG_SHUNT_VOLT \fP
triggers single-shot conversion when set 
.TP
\f(BIINA226_OP_MODE_TRIG_BUS_VOLT \fP
triggers single-shot conversion when set 
.TP
\f(BIINA226_OP_MODE_TRIG_SHUNT_BUS \fP
triggers single-shot conversion when set 
.TP
\f(BIINA226_OP_MODE_SHUTDOWN2 \fP
device is powered down 
.TP
\f(BIINA226_OP_MODE_CONT_SHUNT_VOLT \fP
normal operating mode 
.TP
\f(BIINA226_OP_MODE_CONT_BUS_VOLT \fP
normal operating mode 
.TP
\f(BIINA226_OP_MODE_CONT_SHUNT_BUS \fP
normal operating mode default 
.SS "enum \fBina226_volt_conv_times_e\fP"

.PP
Voltage conversion times enumerator for ADC resolution/averaging\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIINA226_VOLT_CONV_TIME_1_1MS \fP
1\&.1 ms default 
.SS "enum \fBltr390uv_measurement_gains_e\fP"

.PP
LTR390UV measurement gains enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BILTR390UV_MG_X1 \fP
ltr390uv 
.TP
\f(BILTR390UV_MG_X3 \fP
ltr390uv (default) 
.TP
\f(BILTR390UV_MG_X6 \fP
ltr390uv 
.TP
\f(BILTR390UV_MG_X9 \fP
ltr390uv 
.TP
\f(BILTR390UV_MG_X18 \fP
ltr390uv 
.SS "enum \fBltr390uv_measurement_rates_e\fP"

.PP
LTR390UV measurement rates enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BILTR390UV_MR_25MS \fP
ltr390uv 
.TP
\f(BILTR390UV_MR_50MS \fP
ltr390uv 
.TP
\f(BILTR390UV_MR_100MS \fP
ltr390uv (default) 
.TP
\f(BILTR390UV_MR_200MS \fP
ltr390uv 
.TP
\f(BILTR390UV_MR_500MS \fP
ltr390uv 
.TP
\f(BILTR390UV_MR_1000MS \fP
ltr390uv 
.TP
\f(BILTR390UV_MR_2000MS \fP
ltr390uv 
.TP
\f(BILTR390UV_MR_2000_MS \fP
ltr390uv 
.SS "enum \fBltr390uv_sensor_resolutions_e\fP"

.PP
LTR390UV sensor resolutions enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BILTR390UV_SR_20BIT \fP
ltr390uv 20-bit resolution, conversion time = 400ms 
.TP
\f(BILTR390UV_SR_19BIT \fP
ltr390uv 19-bit resolution, conversion time = 200ms 
.TP
\f(BILTR390UV_SR_18BIT \fP
ltr390uv 18-bit resolution, conversion time = 100ms (default) 
.TP
\f(BILTR390UV_SR_17BIT \fP
ltr390uv 17-bit resolution, conversion time = 50ms 
.TP
\f(BILTR390UV_SR_16BIT \fP
ltr390uv 16-bit resolution, conversion time = 25ms 
.TP
\f(BILTR390UV_SR_13BIT \fP
ltr390uv 13-bit resolution, conversion time = 12\&.5ms 
.SS "enum \fBmax30105_adc_range_controls_e\fP"

.PP
MAX30105 particle-sensing ADC range controls (18-bit resolution) enumerator (register 0x0a)\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMAX30105_ARC_7_81LSB \fP
max30105 7\&.81 LSB size (pA), 2048 full-scale (nA) 
.TP
\f(BIMAX30105_ARC_15_63LSB \fP
max30105 15\&.63 LSB size (pA), 4096 full-scale (nA) 
.TP
\f(BIMAX30105_ARC_31_25LSB \fP
max30105 31\&.25 LSB size (pA), 8192 full-scale (nA) 
.TP
\f(BIMAX30105_ARC_62_5LSB \fP
max30105 62\&.5 LSB size (pA), 16384 full-scale (nA) 
.SS "enum \fBmax30105_control_modes_e\fP"

.PP
MAX30105 control modes enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMAX30105_CM_PARTICLE_SENSING_1LED \fP
max30105 particle sensing mode with 1 LED 
.TP
\f(BIMAX30105_CM_PARTICLE_SENSING_2LED \fP
max30105 particle sensing mode with 2 LEDs 
.TP
\f(BIMAX30105_CM_MULTIPLE_LED \fP
max30105 multiple LED mode 
.SS "enum \fBmax30105_led_pulse_amplitudes_e\fP"

.PP
MAX30105 LED pulse amplitudes enumerator (registers 0x0c-0x10)\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMAX30105_LPA_0_0MA \fP
max30105 LED pulse amplitude at 0\&.0 mA 
.TP
\f(BIMAX30105_LPA_0_2MA \fP
max30105 LED pulse amplitude at 0\&.2 mA 
.TP
\f(BIMAX30105_LPA_0_4MA \fP
max30105 LED pulse amplitude at 0\&.4 mA 
.TP
\f(BIMAX30105_LPA_3_1MA \fP
max30105 LED pulse amplitude at 3\&.1 mA 
.TP
\f(BIMAX30105_LPA_6_4MA \fP
max30105 LED pulse amplitude at 6\&.4 mA 
.TP
\f(BIMAX30105_LPA_12_5MA \fP
max30105 LED pulse amplitude at 12\&.5 mA 
.TP
\f(BIMAX30105_LPA_25_4MA \fP
max30105 LED pulse amplitude at 25\&.4 mA 
.TP
\f(BIMAX30105_LPA_50_0MA \fP
max30105 LED pulse amplitude at 50\&.0 mA 
.SS "enum \fBmax30105_led_pulse_width_controls_e\fP"

.PP
MAX30105 LED pulse width controls enumerator (register 0x0a)\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMAX30105_LPWC_69US_15BITS \fP
max30105 68\&.95us pulse width with 15-bit ADC resolution 
.TP
\f(BIMAX30105_LPWC_118US_16BITS \fP
max30105 117\&.78us pulse width with 16-bit ADC resolution 
.TP
\f(BIMAX30105_LPWC_215US_17BITS \fP
max30105 215\&.44us pulse width with 17-bit ADC resolution 
.TP
\f(BIMAX30105_LPWC_411US_18BITS \fP
max30105 410\&.75us pulse width with 18-bit ADC resolution 
.SS "enum \fBmax30105_multi_led_control_modes_e\fP"

.PP
MAX30105 multi-LED control modes enumerator (registers 0x11-0x12)\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMAX30105_MLCM_DISABLED \fP
max30105 
.TP
\f(BIMAX30105_MLCM_RED_LED \fP
max30105 
.TP
\f(BIMAX30105_MLCM_IR_LED \fP
max30105 
.TP
\f(BIMAX30105_MLCM_GREEN_LED \fP
max30105 
.TP
\f(BIMAX30105_MLCM_NONE \fP
max30105 
.TP
\f(BIMAX30105_MLCM_RED_PILOT \fP
max30105 
.TP
\f(BIMAX30105_MLCM_IR_PILOT \fP
max30105 
.TP
\f(BIMAX30105_MLCM_GREEN_PILOT \fP
max30105 
.SS "enum \fBmax30105_sample_rate_controls_e\fP"

.PP
MAX30105 particle-sensing sample rate control enumerator (register 0x0a)\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMAX30105_SRC_50SPS \fP
max30105 50 samples per second 
.TP
\f(BIMAX30105_SRC_100SPS \fP
max30105 100 samples per second 
.TP
\f(BIMAX30105_SRC_200SPS \fP
max30105 200 samples per second 
.TP
\f(BIMAX30105_SRC_400SPS \fP
max30105 400 samples per second 
.TP
\f(BIMAX30105_SRC_800SPS \fP
max30105 800 samples per second 
.TP
\f(BIMAX30105_SRC_1000SPS \fP
max30105 1000 samples per second 
.TP
\f(BIMAX30105_SRC_1600SPS \fP
max30105 1600 samples per second 
.TP
\f(BIMAX30105_SRC_3200SPS \fP
max30105 3200 samples per second 
.SS "enum \fBmpu6050_accel_full_scale_ranges_e\fP"

.PP
MPU6050 accelerometer full-scale ranges enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMPU6050_ACCEL_FS_RANGE_2G \fP
mpu6050 accelerometer full-scale range ± 2g 
.TP
\f(BIMPU6050_ACCEL_FS_RANGE_4G \fP
mpu6050 accelerometer full-scale range ± 4g 
.TP
\f(BIMPU6050_ACCEL_FS_RANGE_8G \fP
mpu6050 accelerometer full-scale range ± 8g 
.TP
\f(BIMPU6050_ACCEL_FS_RANGE_16G \fP
mpu6050 accelerometer full-scale range ± 16g 
.SS "enum \fBmpu6050_digital_low_pass_filters_e\fP"

.PP
MPU6050 digital low-pass filters enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMPU6050_DIGITAL_LP_FILTER_ACCEL_260KHZ_GYRO_256KHZ \fP
mpu6050 
.TP
\f(BIMPU6050_DIGITAL_LP_FILTER_ACCEL_184KHZ_GYRO_188KHZ \fP
mpu6050 
.TP
\f(BIMPU6050_DIGITAL_LP_FILTER_ACCEL_94KHZ_GYRO_98KHZ \fP
mpu6050 
.TP
\f(BIMPU6050_DIGITAL_LP_FILTER_ACCEL_44KHZ_GYRO_42KHZ \fP
mpu6050 
.TP
\f(BIMPU6050_DIGITAL_LP_FILTER_ACCEL_21KHZ_GYRO_20KHZ \fP
mpu6050 
.TP
\f(BIMPU6050_DIGITAL_LP_FILTER_ACCEL_10KHZ_GYRO_10KHZ \fP
mpu6050 
.TP
\f(BIMPU6050_DIGITAL_LP_FILTER_ACCEL_5KHZ_GYRO_5KHZ \fP
mpu6050 
.TP
\f(BIMPU6050_DIGITAL_LP_FILTER_RESERVED \fP
mpu6050 reserved but disables low-pass filter 
.SS "enum \fBmpu6050_ext_sync_settings_e\fP"

.PP
MPU6050 external synchronization settings enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMPU6050_EXT_SYNC_SETTING_INPUT_DISABLED \fP
mpu6050 
.TP
\f(BIMPU6050_EXT_SYNC_SETTING_TEMP_OUT_L \fP
mpu6050 
.TP
\f(BIMPU6050_EXT_SYNC_SETTING_GYRO_XOUT_L \fP
mpu6050 
.TP
\f(BIMPU6050_EXT_SYNC_SETTING_GYRO_YOUT_L \fP
mpu6050 
.TP
\f(BIMPU6050_EXT_SYNC_SETTING_GYRO_ZOUT_L \fP
mpu6050 
.TP
\f(BIMPU6050_EXT_SYNC_SETTING_ACCEL_XOUT_L \fP
mpu6050 
.TP
\f(BIMPU6050_EXT_SYNC_SETTING_ACCEL_YOUT_L \fP
mpu6050 
.TP
\f(BIMPU6050_EXT_SYNC_SETTING_ACCEL_ZOUT_L \fP
mpu6050 
.SS "enum \fBmpu6050_gyro_clock_sources_e\fP"

.PP
MPU6050 gyroscope clock sources enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMPU6050_GYRO_CS_INT_8MHZ \fP
mpu6050 internal 8MHz oscillator 
.TP
\f(BIMPU6050_GYRO_CS_PLL_X_AXIS_REF \fP
mpu6050 PLL with x-axis gyroscope reference 
.TP
\f(BIMPU6050_GYRO_CS_PLL_Y_AXIS_REF \fP
mpu6050 PLL with y-axis gyroscope reference 
.TP
\f(BIMPU6050_GYRO_CS_PLL_Z_AXIS_REF \fP
mpu6050 PLL with z-axis gyroscope reference 
.TP
\f(BIMPU6050_GYRO_CS_PLL_EXT_32_768KHZ_REF \fP
mpu6050 PLL with external 32\&.768kHz reference 
.TP
\f(BIMPU6050_GYRO_CS_PLL_EXT_19_2MHZ_REF \fP
mpu6050 PLL with external 19\&.2MHz reference 
.TP
\f(BIMPU6050_GYRO_CS_RESERVED \fP
mpu6050 reserved 
.TP
\f(BIMPU6050_GYRO_CS_CLOCK_STOP_IN_RESET \fP
mpu6050 stops the clock an keeps the timing generator in reset 
.SS "enum \fBmpu6050_gyro_full_scale_ranges_e\fP"

.PP
MPU6050 gyroscope full-scale ranges enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMPU6050_GYRO_FS_RANGE_250DPS \fP
mpu6050 gyroscope full-scale range ± 250 °/s 
.TP
\f(BIMPU6050_GYRO_FS_RANGE_500DPS \fP
mpu6050 gyroscope full-scale range ± 500 °/s 
.TP
\f(BIMPU6050_GYRO_FS_RANGE_1000DPS \fP
mpu6050 gyroscope full-scale range ± 1000 °/s 
.TP
\f(BIMPU6050_GYRO_FS_RANGE_2000DPS \fP
mpu6050 gyroscope full-scale range ± 2000 °/s 
.SS "enum \fBmpu6050_irq_clear_e\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMPU6050_IRQ_CLEAR_ON_ANY_READ \fP
INT_STATUS register bits are cleared on any register read 
.TP
\f(BIMPU6050_IRQ_CLEAR_ON_STATUS_READ \fP
INT_STATUS register bits are cleared only by reading INT_STATUS value 
.SS "enum \fBmpu6050_irq_latch_e\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMPU6050_IRQ_LATCH_50US \fP
The mpu6050 produces a 50 microsecond pulse on interrupt 
.TP
\f(BIMPU6050_IRQ_LATCH_UNTIL_CLEARED \fP
The mpu6050 latches its INT pin to its active level, until interrupt is cleared 
.SS "enum \fBmpu6050_irq_pin_active_level_e\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMPU6050_IRQ_PIN_ACTIVE_HIGH \fP
The mpu6050 sets its INT pin HIGH on interrupt 
.TP
\f(BIMPU6050_IRQ_PIN_ACTIVE_LOW \fP
The mpu6050 sets its INT pin LOW on interrupt 
.SS "enum \fBmpu6050_irq_pin_mode_e\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMPU6050_IRQ_PIN_PUSH_PULL \fP
The mpu6050 configures its INT pin as push-pull 
.TP
\f(BIMPU6050_IRQ_PIN_OPEN_DRAIN \fP
The mpu6050 configures its INT pin as open drain 
.SS "enum \fBmpu6050_low_power_wake_controls_e\fP"

.PP
MPU6050 low-power wake controls enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMPU6050_LP_WAKE_CONTROL_1_25HZ \fP
mpu6050 1\&.25Hz wake-up frequency 
.TP
\f(BIMPU6050_LP_WAKE_CONTROL_5HZ \fP
mpu6050 5Hz wake-up frequency 
.TP
\f(BIMPU6050_LP_WAKE_CONTROL_20HZ \fP
mpu6050 20Hz wake-up frequency 
.TP
\f(BIMPU6050_LP_WAKE_CONTROL_40HZ \fP
mpu6050 40Hz wake-up frequency 
.SS "enum \fBsgp4x_versions_e\fP"

.PP
SGP4X versions enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISGP4X_VERSION_SGP40 \fP
not implemented 
.SS "enum \fBsht4x_heater_modes_e\fP"

.PP
SHT4X measurement heater modes enumerator definition\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISHT4X_HEATER_OFF \fP
heater is off, default 
.TP
\f(BISHT4X_HEATER_HIGH_LONG \fP
high power (~200mW), 1 second pulse 
.TP
\f(BISHT4X_HEATER_HIGH_SHORT \fP
high power (~200mW), 0\&.1 second pulse 
.TP
\f(BISHT4X_HEATER_MEDIUM_LONG \fP
medium power (~110mW), 1 second pulse 
.TP
\f(BISHT4X_HEATER_MEDIUM_SHORT \fP
medium power (~110mW), 0\&.1 second pulse 
.TP
\f(BISHT4X_HEATER_LOW_LONG \fP
low power (~20mW), 1 second pulse 
.TP
\f(BISHT4X_HEATER_LOW_SHORT \fP
low power (~20mW), 0\&.1 second pulse 
.SS "enum \fBsht4x_repeat_modes_e\fP"

.PP
SHT4X measurement repeatability modes enumerator definition\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISHT4X_REPEAT_HIGH \fP
high repeatability (high resolution) 
.TP
\f(BISHT4X_REPEAT_MEDIUM \fP
medium repeatability (medium resolution) 
.TP
\f(BISHT4X_REPEAT_LOW \fP
low repeatability (low resolution) 
.SS "enum \fBspi_max31865_connection_types_t\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISPI_MAX31865_2WIRE_OR_4WIRE \fP
2-wires or 4-wires 
.TP
\f(BISPI_MAX31865_3WIRE \fP
3-wires 
.SS "enum \fBspi_max31865_filters_t\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISPI_MAX31865_FILTER_60HZ \fP
60Hz 
.TP
\f(BISPI_MAX31865_FILTER_50HZ \fP
50Hz 
.SS "enum \fBspi_max31865_modes_t\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISPI_MAX31865_MODE_SINGLE \fP
Single consersion mode, default 
.TP
\f(BISPI_MAX31865_MODE_AUTO \fP
Automatic conversion mode at 50/60Hz rate 
.SS "enum \fBspi_max31865_standards_t\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISPI_MAX31865_ITS90 \fP
ITS-90 
.TP
\f(BISPI_MAX31865_DIN43760 \fP
DIN43760 
.TP
\f(BISPI_MAX31865_US_INDUSTRIAL \fP
US INDUSTRIAL 
.SS "enum \fBssd1306_panel_sizes_e\fP"

.PP
SSD1306 panel sizes enumerator definition\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISSD1306_PANEL_128x32 \fP
128x32 ssd1306 display 
.TP
\f(BISSD1306_PANEL_128x64 \fP
128x64 ssd1306 display 
.TP
\f(BISSD1306_PANEL_128x128 \fP
128x128 ssd1327 display 
.SS "enum \fBtbi2cxxx_types_e\fP"

.PP
TBI2CXXX types enumerators\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BITBI2CH04 \fP
tb(p) series non-contact infrared temperature sensor with 3\&.814° FOV and heatsink(O) 
.TP
\f(BITBI2CH08 \fP
tb(p) series non-contact infrared temperature sensor with 7\&.16° FOV and heatsink(O) 
.TP
\f(BITBI2CH70 \fP
tb(p) series non-contact infrared temperature sensor with 70° FOV and heatsink(O) 
.TP
\f(BITBI2CS70 \fP
tb(p) series non-contact infrared temperature sensor with 70° FOV and heatsink(X) 
.SS "enum \fBtlv493d_power_modes_e\fP"

.PP
TLV493D power modes enumerator\&. Fast, Low Power, Low Power Period, Measurement Time 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BITLV493D_POWER_DOWN_MODE \fP
0, 0, 0, 1000 
.TP
\f(BITLV493D_FAST_MODE \fP
1, 0, 0, 0 
.TP
\f(BITLV493D_LOW_POWER_MODE \fP
0, 1, 1, 10 
.TP
\f(BITLV493D_ULTRA_LOW_POWER_MODE \fP
0, 1, 0, 100 
.TP
\f(BITLV493D_MASTER_CONTROLLED_MODE \fP
1, 1, 1, 10 
.SS "enum \fBveml6040_modes_e\fP"

.PP
VEML6040 modes enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIVEML6040_MODE_AUTO \fP
veml6040 auto mode 
.TP
\f(BIVEML6040_MODE_MANUAL \fP
veml6040 manual force mode 
.SS "enum \fBveml6040_triggers_e\fP"

.PP
VEML6040 triggers enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIVEML6040_TRIGGER_NONE \fP
veml6040 no trigger 
.TP
\f(BIVEML6040_TRIGGER_ONE_TIME \fP
veml6040 trigger one time detect cycle 
.SS "enum \fBveml7700_gains_e\fP"

.PP
VEML7700 gains enumerator\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIVEML7700_GAIN_1 \fP
ALS gain x 1 
.TP
\f(BIVEML7700_GAIN_2 \fP
ALS gain x 2 
.TP
\f(BIVEML7700_GAIN_DIV_8 \fP
ALS gain x (1/8) 
.TP
\f(BIVEML7700_GAIN_DIV_4 \fP
ALS gain x (1/4) 
.SH "Function Documentation"
.PP 
.SS "union __attribute__ ((packed) )"

.PP
AHTXX status register structure definition\&. MAX31865 SPI fault status register structure\&.

.PP
MAX31865 SPI configuration register structure\&.

.PP
DS18B20 scratchpad structure\&. Power-up state depends on value(s) stored in EEPROM\&.

.PP
DS18B20 configuration register structure\&. See datasheet for details, Figure 10 and Table 2\&.

.PP
VEML7700 identifier register structure\&.

.PP
VEML7700 interrupt status register structure\&.

.PP
VEML7700 power saving mode register structure\&.

.PP
VEML7700 configuration register structure\&.

.PP
VEML6040 configuration register structure\&.

.PP
write only 0x03

.PP
write only 0x02

.PP
write only 0x01

.PP
write only 0x00

.PP
read only 0x09

.PP
read only 0x08

.PP
read only 0x07

.PP
SGP4X self-test result structure\&.

.PP
MPU6050 who am i or device identifier register structure\&.

.PP
MPU6050 power management 2 register structure\&.

.PP
MPU6050 power management 1 register structure\&.

.PP
MPU6050 user control register structure\&.

.PP
MPU6050 signal path reset register structure\&.

.PP
MPU6050 interrupt status register structure\&.

.PP
MPU6050 interrupt pin configuration register structure\&.

.PP
MPU6050 interrupt enable register structure\&.

.PP
MPU6050 FIFO enable register structure\&.

.PP
MPU6050 accelerometer configuration register structure\&.

.PP
MPU6050 gyroscope configuration register structure\&.

.PP
MPU6050 configuration register structure\&.

.PP
MPU6050 self-test a register structure\&.

.PP
MPU6050 self-test register (self-test x, y, z) structure\&.

.PP
MMC56X3 control 2 register (0x1D Write) (POR 0x00) structure\&.

.PP
MMC56X3 control 1 register (0x1C Write) (POR 0x00) structure\&.

.PP
MMC56X3 control 0 register (0x1B Write) (POR 0x00) structure\&.

.PP
MMC56X3 status 1 register (0x18 Read) (POR 0x00) structure\&.

.PP
MLX90614 flags register structure\&.

.PP
MLX90614 PWM control register structure\&.

.PP
MLX90614 configuration register structure\&.

.PP
MAX30105 FIFO data register (0x07, read-write | POR State 0x00) structure\&.

.PP
MAX30105 FIFO read pointer register (0x06, read-write | POR State 0x00) structure\&.

.PP
MAX30105 FIFO overflow counter register (0x05, read-write | POR State 0x00) structure\&.

.PP
MAX30105 FIFO write pointer register (0x04, read-write | POR State 0x00) structure\&.

.PP
MAX30105 multi-LED mode control registers (0x11-0x12, read-write | POR State 0x00) structure\&.

.PP
MAX30105 mode configuration register (0x09, read-write | POR State 0x00) structure\&.

.PP
MAX30105 interrupt enable 2 register (0x03, read-write | POR State 0x00) structure\&.

.PP
MAX30105 interrupt enable 1 register (0x02, read-write | POR State 0x00) structure\&.

.PP
MAX30105 interrupt status 2 register (0x01, read-only | POR State 0x00) structure\&.

.PP
MAX30105 interrupt status 1 register (0x00, read-only | POR State 0x00) structure\&.

.PP
LTR390UV interrupt configuration register (0x19 read-write | POR State 0x10) structure\&.

.PP
LTR390UV main status register (0x07 read-only | POR State 0x20) structure\&.

.PP
LTR390UV ALS UVS gain register (0x04 read-write | POR State 0x01) structure\&.

.PP
LTR390UV ALS UVS measurement register (0x04 read-write | POR State 0x22) structure\&.

.PP
LTR390UV main control register (0x00 read-write | POR State 0x00) structure\&.

.PP
Alert configuration and Conversion Ready flag\&.

.PP
All-register reset, shunt voltage and bus voltage ADC conversion times and averaging, operating mode\&.

.PP
HMC5883L status register structure\&.

.PP
HMC5883L mode register structure\&.

.PP
HMC5883L configuration 2 (b) register structure\&.

.PP
HMC5883L configuration 1 (a) register structure\&.

.PP
HDC1080 serial number register structure definition\&.

.PP
HDC1080 temperature or humidity measurement register structure definition\&.

.PP
HDC1080 device configuration register structure definition\&.

.PP
ENS160 calculated air quality index (aqi) data register structure\&. See datasheet for AQI-UBA details\&.

.PP
ENS160 interrupt configuration register structure\&.

.PP
ENS160 status register structure\&.

.PP
CCS811 error codes \fRERROR_ID\fP register structure\&.

.PP
CCS811 firmware version format (bootloader 0x23 and application 0x24) structure (review)\&.

.PP
CCS811 threshold value structure (big endien)\&.

.PP
CCS811 raw data register structure (review - not correct)\&.

.PP
CCS811 measure mode and condition register structure\&.

.PP
CCS811 status register structure\&.

.PP
BMP390 configuration register (0x1f) structure\&. The reset state is 0x00 for this register\&.

.PP
BMP390 ODR register (0x1d) structure\&. The reset state is 0x00 for this register\&.

.PP
BMP390 OSR register (0x1c) structure\&. The reset state is 0x02 for this register\&.

.PP
BMP390 power control register (0x1b) structure\&. The reset state is 0x00 for this register\&.

.PP
BMP390 interrupt control register (0x19) structure\&. The reset state is 0x02 for this register\&.

.PP
BMP390 interrupt status register (0x11) structure\&. The reset state is ? for this register\&.

.PP
BMP390 status register (0x03) structure\&. The reset state is 0x00 for this register\&.

.PP
BMP280 configuration register (0xf5) structure definition\&. The reset state is 0x00 for this register\&.

.PP
BMP280 control measurement register (0xf4) structure definition\&. The reset state is 0x00 for this register\&.

.PP
BMP280 status register (0xf3) structure definition\&. The reset state is 0x00 for this register\&.

.PP
BME680 configuration register (0x75) structure\&. The reset state is 0x00 for this register\&. This register contains SPI and IIR filter settings\&.

.PP
BME680 control gas_r_lsb register (0x2b) structure\&. The reset state is 0x00 for this register\&. This register contains the gas resistance lsb, gas validation flag, heater stab, and gas range settings\&.

.PP
BME680 control gas 1 register (0x70) structure\&. The reset state is 0x00 for this register\&. This register contains heater setting\&.

.PP
BME680 control gas 0 register (0x71) structure\&. The reset state is 0x00 for this register\&. This register contains the heater set-point and gas conversion settings\&.

.PP
BME680 control measurement register (0x72) structure\&. The reset state is 0x00 for this register\&. This register contains humidity oversampling and SPI interrupt settings\&.

.PP
BME680 control measurement register (0x74) structure\&. The reset state is 0x00 for this register\&. This register contains the power mode, pressure and temperature oversampling settings\&.

.PP
BME680 status 0 register (0x1d) structure\&. The reset state is 0x00 for this register\&. This register contains the gas measurement index, measuring status, gas measuring status, and new data status\&.

.PP
AS7341 configuration 6 register (0xaf) structure\&.

.PP
AS7341 configuration 1 register (0xaa) structure\&.

.PP
AS7341 configuration 0 register (0xa9) structure\&.

.PP
AS7341 part number identifier register (0x92) structure\&.

.PP
AS7341 revision number identifier register (0x91) structure\&.

.PP
AS7341 auxiliary identifier register (0x90) structure\&.

.PP
AS7341 flicker detection status register (0xdb) structure\&.

.PP
AS7341 status 6 register (0xa7) structure\&.

.PP
AS7341 status 5 register (0xa6) structure\&.

.PP
AS7341 status 3 register (0xa4) structure\&.

.PP
AS7341 status 2 register (0xa3) structure\&.

.PP
AS7341 astatus register (0x94) structure\&.

.PP
AS7341 device status register (0x71) structure\&.

.PP
AS7341 interrupt status register (0x93) structure\&.

.PP
AS7341 interrupt enable register (0xf9) structure\&.

.PP
AS7341 led register (0x74) structure\&.

.PP
AS7341 gpio2 register (0xbe) structure\&.

.PP
AS7341 gpio1 register (0x73) structure\&.

.PP
AS7341 flicker detection time 2 register (0xDA) structure\&.

.PP
AS7341 flicker detection time 1 register (0xD8) structure\&. THIS ISN'T NEEDED\&.

.PP
AS7341 configuration register (0x70) structure\&.

.PP
AS7341 enable register (0x80) structure\&.

.PP
AS3935 register 0x08 structure\&.

.PP
AS3935 register 0x07 structure\&.

.PP
AS3935 register 0x03 structure\&.

.PP
AS3935 register 0x02 structure\&.

.PP
AS3935 register 0x01 structure\&.

.PP
AS3935 register 0x00 structure\&.

.PP
AK8975 self-test control register structure\&.

.PP
AK8975 status 2 register structure\&.

.PP
AK8975 status 1 register structure\&.

.PP
AK8975 control register structure\&.

.PP
violet -> F1 indigo -> F2 blue -> F3 cyan -> F4 green -> F5 yellow -> F6 orange -> F7 red -> F8 

.PP
\fBNote\fP
.RS 4
To operate the device enable power and interrupts before enabling spectral measurements\&.

.PP
Each bit will clear after the register is read\&.
.RE
.PP
Table 1 - Configuration Register #0 (see datasheet pg\&. 7) REGISTER NAME BIT Reserved 15:13 ALS_GAIN 12:11 Reserved 10 ALS_IT 9:6 ALS_PERS 5:4 Reserved 3:2 ALS_INT_END 1 ALS_SD 0

.PP
Table 4 - Power Saving Modes (see datasheet pg\&. 8) REGISTER NAME BIT Reserved 15:3 PSM 2:1 PSM_EN 0

.PP
Table 7 - Interrupt Status (see datasheet pg\&. 9) REGISTER NAME BIT < reserved (bit:0-2) 
.br

.PP
< ahtxx is calibrated when true (bit:3)

.PP
< reserved (bit:4-6)

.PP
< ahtxx is busy when true (bit:7)

.PP
< operating mode (bit:0-3) 
.br

.PP
< reserved and set to 0 (bit:4-7) 
.br

.PP
< represents the 8-bit control register parts in bits\&. 
.br

.PP
< represents the 8-bit control register as \fRuint8_t\fP\&. 
.br

.PP
< data ready status (bit:0) 
.br

.PP
< reserved and set to 0 (bit:1-7) 
.br

.PP
< represents the 8-bit status 1 register parts in bits\&. 
.br

.PP
< represents the 8-bit status 1 register as \fRuint8_t\fP\&. 
.br

.PP
< reserved and set to 0 (bit:0-1) 
.br

.PP
< data error status (bit:2) 
.br

.PP
< magnetic sensor overflow status (bit:3) 
.br

.PP
< reserved and set to 0 (bit:4-7) 
.br

.PP
< represents the 8-bit status 2 register parts in bits\&. 
.br

.PP
< represents the 8-bit status 2 register as \fRuint8_t\fP\&. 
.br

.PP
< reserved and set to 0 (bit:0-5) 
.br

.PP
< self-test status (bit:6) 
.br

.PP
< reserved and set to 0 (bit:7) 
.br

.PP
< represents the 8-bit self-test control register parts in bits\&. 
.br

.PP
< represents the 8-bit self-test control register as \fRuint8_t\fP\&. 
.br

.PP
< power on or off (bit:0) 
.br

.PP
< analog front-end (AFE) and watchdog (bit:1-5)

.PP
< reserved and set to 0 (bit:6-7)

.PP
< represents the 8-bit control register parts in bits\&.

.PP
< represents the 8-bit control register as \fRuint8_t\fP

.PP
< watchdog threshold (bit:0-3)

.PP
< noise floor level (bit:4-6)

.PP
< reserved and set to 0 (bit:7) 
.br

.PP
< represents the 8-bit control register parts in bits\&.

.PP
< represents the 8-bit control register as \fRuint8_t\fP

.PP
< spike rejection (bit:0-3)

.PP
< minimum number of lightning (bit:4-5)

.PP
< clear statistics (bit:6) 
.br

.PP
< reserved and set to 0 (bit:7) 
.br

.PP
< represents the 8-bit control register parts in bits\&.

.PP
< represents the 8-bit control register as \fRuint8_t\fP

.PP
< lightning event interrupt (bit:0-3)

.PP
< reserved and set to 0 (bit:4) 
.br

.PP
< disturber detection state (bit:5) 
.br

.PP
< lco frequency division (bit:6-7)

.PP
< represents the 8-bit control register parts in bits\&.

.PP
< represents the 8-bit control register as \fRuint8_t\fP

.PP
< lightning distance estimation (bit:0-5)

.PP
< reserved and set to 0 (bit:6-7)

.PP
< represents the 8-bit control register parts in bits\&.

.PP
< represents the 8-bit control register as \fRuint8_t\fP

.PP
< internal tuning capacitors from 0 to 120pF in steps of 8pF (0-15) (bit:0-3)

.PP
< reserved and set to 0 (bit:4)

.PP
< display trco on irq pin (bit:5)

.PP
< display srco on irq pin (bit:6)

.PP
< display lco on irq pin (bit:7)

.PP
< represents the 8-bit control register parts in bits\&.

.PP
< represents the 8-bit control register as \fRuint8_t\fP

.PP
< as7341 power enabled when true (bit:0) 
.br

.PP
< as7341 spectral measurement enabled when true (bit:1) 
.br

.PP
< reserved (bit:2)

.PP
< as7341 wait time between two consecutive spectral measurements enabled when true (bit:3)

.PP
< as7341 starts SMUX command when true and bit is cleared when SMUX operation is finished (bit:4)

.PP
< reserved (bit:5)

.PP
< as7341 flicker detection enabled when true (bit:6) 
.br

.PP
< reserved (bit:7)

.PP
< as7341 ambient light sensing mode (bit:0-1) 
.br

.PP
< as7341 sync signal applied on output pin interrupt when true (bit:2)

.PP
< as7341 register LED controls LED connected to pin LDR when true (register 0x74), otherwise, exernal LED is not controlled by as7341 (bit:3)

.PP
< reserved (bit:4-7)

.PP
< as7341 flicker detection integration time LSB (t = FD_TIME * 2\&.78us) (bit:0-7)

.PP
< as7341 flicker detection integration time MSB (t = FD_TIME * 2\&.78us) (bit:0-2)

.PP
< as7341 flicker detection gain (bit:3-7)

.PP
< as7341 photo diode connected to interrupt pin when true (bit:0)

.PP
< as7341 photo diode connected to GPIO pin when true (bit:1)

.PP
< reserved (bit:2-7)

.PP
< as7341 GPIO pin is input when true if gpio input is enabled (bit:0)

.PP
< as7341 output state of GPIO pin is active when true (bit:1)

.PP
< as7341 GPIO pin accepts non-floating input when true (bit:2)

.PP
< as7341 output state of GPIO pin is inverted when true (bit:3)

.PP
< reserved (bit:4-7)

.PP
< as7341 LED driving strength (bit:0-6)

.PP
< as7341 external LED connected to LDR pin is enabled when true (bit:7)

.PP
< as7341 interrupt asserted when system interrupts occur when enabled (bit:0)

.PP
< reserved (bit:1)

.PP
< as7341 interrupt asserted when FIFO LVL exceeds FIFO threshold condition when enabled (bit:2)

.PP
< as7341 interrupt asserted subject to spectral thresholds and persistence filter when enabled (bit:3)

.PP
< reserved (bit:4-6)

.PP
< as7341 spectral and flicker detection interrupt asserted when enabled (bit:7)

.PP
< as7341 system interrupt asserted when true (bit:0)

.PP
< as7341 calibration interrupt asserted when true (bit:1)

.PP
< as7341 interrupt asserted when FIFO LVL exceeds FIFO threshold condition when true (bit:2)

.PP
< as7341 interrupt asserted subject to spectral threholds and persistence filter when true (bit:3)

.PP
< reserved (bit:4-6)

.PP
< as7341 spectral and flicker detection interrupt asserted when true (bit:7)

.PP
< as7341 spectral measurement status is ready when true (bit:0)

.PP
< as7341 device waits for sync pulse on GPIO to start integration when true (bit:1)

.PP
< reserved (bit:2-7)

.PP
< as7341 gain applied for the spectral data latched to this ASTATUS read (bit:3-0)

.PP
< reserved (bit:4-6)

.PP
< as7341 latched data is affected by analog or digital saturation (bit:7)

.PP
< as7341 maximum counter value has been reached during flicker detection when true (bit:0)

.PP
< as7341 intensity of ambient light ha exceeded the maximum integration level for analg circuit for flicker detection when true (bit:1)

.PP
< reserved (bit:2)

.PP
< as7341 intensity of ambient light ha exceeded the maximum integration level for spectral analg circuit when true (bit:3)

.PP
< as7341 maximum counter value has been reached when true, dependent of ATIME register (bit:4)

.PP
< reserved (bit:5)

.PP
< as7341 spectral measurement has been completed when true (bit:6)

.PP
< reserved (bit:7)

.PP
< reserved (bit:3-0)

.PP
< as7341 spectral interrupt asserted when data is below the low threshold (bit:4)

.PP
< as7341 spectral interrupt asserted when data is above the high threshold (bit:5)

.PP
< reserved (bit:6-7)

.PP
< reserved (bit:1-0)

.PP
< as7341 SMUX command execution has finished when true (bit:2)

.PP
< as7341 FD_STATUS register status has changed when true and if SIEN_FD is enabled (bit:3)

.PP
< reserved (bit:4-7)

.PP
< as7341 device is initializing when true, wait until cleared (bit:0)

.PP
< as7341 device is in sleep due to an interrupt when true (bit:1)

.PP
< as7341 timing error when true, WTIME to short for ATIME (bit:2)

.PP
< reserved (bit:3)

.PP
< as7341 timing error that prevents flicker detect from working correctly (bit:4)

.PP
< as7341 device temperature is to high when true (bit:5)

.PP
< reserved (bit:6)

.PP
< as7341 FIFO buffer overflowed and information is lost when true (bit:7)

.PP
< as7341 ambient light source is flickering at 100Hz when true (bit:0)

.PP
< as7341 ambient light source is flickering at 120Hz when true (bit:1)

.PP
< as7341 100Hz flicker detection calculation is valid when true, write true to clear (bit:2)

.PP
< as7341 120Hz flicker detection calculation is valid when true, write true to clear (bit:3)

.PP
< as7341 saturation ocurred during the last flicker detection measurement when true,write true to clear (bit:4)

.PP
< as7341 flicker detection measurement is complete when true, write true to clear (bit:5)

.PP
< reserved (bit:6-7)

.PP
< as7341 auxiliary identification (bit:0-3)

.PP
< reserved (bit:4-7)

.PP
< as7341 revision number identification (bit:0-2)

.PP
< reserved (bit:3-7)

.PP
< reserved (bit:0-1)

.PP
< as7341 device part number identification (bit:2-7)

.PP
< reserved (bit:1-0)

.PP
< increase te WTIME setting by a factor of 16 when asserted (bit:2)

.PP
< reserved (bit:3)

.PP
< bit needs to be set to access registers 0x60 to 0x70 (bit:4)

.PP
< device will run in a low power modem when asserted (bit:5)

.PP
< reserved (bit:6-7)

.PP
< spectral sensitivity (bit:4-0)

.PP
< reserved (bit:5-7)

.PP
< reserved (bit:2-0)

.PP
< as7341 SMUX command to execute when smux enabled gets set (bit:3-4)

.PP
< reserved (bit:5-7)

.PP
< bme680 user can program sequence of up to 10 conversions by setting nb_conv<3:0> (bit:0-3)

.PP
< reserved (bit:4)

.PP
< bmp680 automatically set to 1 whenever a conversion is running and back to 0 when results transferred to data registers (bit:5)

.PP
< bme680 automatically set to 1 during gas measurement and back to 0 when results transferred to data registers (bit:6)

.PP
< bme680 measured data are stored into the data registers when true (bit:7)

.PP
< bme680 power mode of the device (bit:0-1) 
.br

.PP
< bme680 oversampling of pressure data (bit:2-4)

.PP
< bme680 oversampling of temperature data (bit:5-7)

.PP
< bme680 oversampling of humidity data (bit:0-2) 
.br

.PP
< bme680 reserved (bit:3-5)

.PP
< bme680 3-wire SPI interrupt enabled when true (bit:6) 
.br

.PP
< bme680 reserved (bit:7)

.PP
< bme680 (bit:0-3) 
.br

.PP
< bme680 gas conversions are started only appropriate mode when true (bit:4) 
.br

.PP
< bme680 reserved (bit:5-7)

.PP
< bme680 (bit:0-2) 
.br

.PP
< bme680 heater is off when true (bit:3) 
.br

.PP
< bme680 reserved (bit:4-7)

.PP
< bme680 adc range of measure gas sensor resistance (bit:0-3) 
.br

.PP
< bme680 heater temperature stability for target heater resistance (bit:4) 
.br

.PP
< bme680 gas conversion is valid when true (bit:5) 
.br

.PP
< bme680 gas resistance lsb (bit:6-7)

.PP
< bme680 3-wire SPI interface enabled when true (bit:0) 
.br

.PP
< bme680 reserved (bit:1)

.PP
< bme680 time constant of the IIR filter (bit:2-4)

.PP
< bme680 reserved (bit:5-7)

.PP
< bmp280 automatically set to 1 when NVM data are being copied to image registers and back to 0 when done (bit:0) 
.br

.PP
< reserved (bit:1-2)

.PP
< bmp280 automatically set to 1 whenever a conversion is running and back to 0 when results transferred to data registers (bit:3)

.PP
< reserved (bit:4-7)

.PP
< bmp280 power mode of the device (bit:0-1) 
.br

.PP
< bmp280 oversampling of pressure data (bit:2-4)

.PP
< bmp280 oversampling of temperature data (bit:5-7)

.PP
< bmp280 3-wire SPI interface enabled when true (bit:0) 
.br

.PP
< bmp280 reserved (bit:1)

.PP
< bmp280 time constant of the IIR filter (bit:2-4)

.PP
< bmp280 inactive duration in normal mode (bit:5-7)

.PP
< bmp390 reserved (bit:0-3)

.PP
< bmp390 command decoder is ready to accept a new command when true (bit:4)

.PP
< bmp390 pressure data ready when true and it is reset when data register is read out (bit:5)

.PP
< bmp390 temperature data ready when true and it is reset when data register is read out (bit:6)

.PP
< bmp390 reserved (bit:7)

.PP
< bmp390 FIFO watermark interrupt, cleared after reading (bit:0)

.PP
< bmp390 FIFO full interrupt, cleared after reading (bit:1)

.PP
< bmp390 reserved (bit:2)

.PP
< bmp390 data ready interrupt, cleared after reading (bit:3)

.PP
< bmp390 reserved (bit:4-7)

.PP
< bmp390 open-drain (true) or push-pull (false) (bit:0)

.PP
< bmp390 active-high (true) or active-low (false) (bit:1)

.PP
< bmp390 latching of interrupt pin is enabled when true (bit:2)

.PP
< bmp390 (bit:3)

.PP
< bmp390 (bit:4)

.PP
< bmp390 high (true) or low (false) (bit:5)

.PP
< (bit:6)

.PP
< bmp390 reserved (bit:7)

.PP
< bmp390 pressure sensor enabled when true (bit:0)

.PP
< bmp390 temperature sensor enabled when true (bit:1)

.PP
< bmp380 reserved (bit:2-3)

.PP
< bmp390 power mode of the device (bit:4-5) 
.br

.PP
< bmp390 reserved (bit:6-7)

.PP
< bmp390 oversampling of pressure data (bit:0-2)

.PP
< bmp390 oversampling of temperature data (bit:3-5)

.PP
< bmp390 reserved (bit:6-7)

.PP
< bmp390 output data rate (bit:0-4)

.PP
< bmp390 reserved (bit:5-7)

.PP
< bmp390 reserved (bit:0)

.PP
< bmp390 time constant of the IIR filter (bit:1-3)

.PP
< bmp390 reserved (bit:4-7)

.PP
< error when true (bit:0) 
.br

.PP
< reserved and set to 0 (bit:2-1)

.PP
< data ready when true (bit:3) 
.br

.PP
< application firmware passed when true (bit:4) 
.br

.PP
< application verify completed when true (bit:5) 
.br

.PP
< application erase completed when true (bit:6) 
.br

.PP
< firmware mode (bit:7) 
.br

.PP
< represents the 8-bit register parts in bits\&.

.PP
< represents the 8-bit register as \fRuint8_t\fP

.PP
< reserved and set to 0 (bit:1-0)

.PP
< threshold interrupt enabled when true (bit:2) 
.br

.PP
< data ready interrupt enabled when true (bit:3) 
.br

.PP
< drive mode (bit:6-4)

.PP
< reserved and set to 0 (bit:7) 
.br

.PP
< represents the 8-bit register parts in bits\&.

.PP
< represents the 8-bit register as \fRuint8_t\fP 
.br

.PP
< raw adc (bit:)

.PP
< current (bit:7) 
.br

.PP
< represents the 16-bit register parts in bits\&.

.PP
< represents the 16-bit register as \fRuint16_t\fP 
.br

.PP
< low to medium threshold (1500ppm = 0x05DC default) (bit:7-0) 
.br

.PP
< low to medium threshold (1500ppm = 0x05DC default) (bit:8-15) 
.br

.PP
< represents the 16-bit register parts in bits\&.

.PP
< represents the 16-bit threshold value register as \fRuint16_t\fP 
.br

.PP
< major (bit:3-0) 
.br

.PP
< minor (bit:4-7) 
.br

.PP
< trivial (bit:15-8)

.PP
< represents the 16-bit version parts in bits\&.

.PP
< represents the 16-bit version as \fRuint16_t\fP 
.br

.PP
< write register invalid when tru (bit:0)

.PP
< read register invalid when true (bit:1)

.PP
< measurement drive mode invalid when true (bit:2)

.PP
< maximum resistance exceeded when true (bit:3)

.PP
< heater current supply fault when true (bit:4)

.PP
< heater voltage supply fault when true (bit:5)

.PP
< reserved and set to 0 (bit:6)

.PP
< reserved and set to 0 (bit:7)

.PP
< represents the 8-bit register parts in bits\&.

.PP
< represents the 8-bit register as \fRuint8_t\fP 
.br

.PP
< true indicates new data is available in \fRGPR_READ\fP registers (bit:0) 
.br

.PP
< true indicates new data is available in \fRDATA_x\fP registers (bit:1) 
.br

.PP
< device status (bit:2-3)

.PP
< reserved and set 0 (bit:4-5)

.PP
< true indicates an error is detected (bit:6) 
.br

.PP
< true indicates an operating mode is running (bit:7) 
.br

.PP
< represents the 8-bit status register parts in bits\&. 
.br

.PP
< represents the 8-bit status register as \fRuint8_t\fP\&. 
.br

.PP
< true indicates interrupt pin is enabled (bit:0) 
.br

.PP
< true indicates interrupt pin is asserted when new data is available in \fRDATA_XXX\fP registers (bit:1) 
.br

.PP
< reserved and set to 0 (bit:2) 
.br

.PP
< true indicates interrupt pin is asserted when new data is available in general purpose registers (bit:3)

.PP
< reserved and set to 0 (bit:4) 
.br

.PP
< interrupt pin driver configuration (bit:5) 
.br

.PP
< interrupt pin polarity configuration (bit:6) 
.br

.PP
< reserved and set to 0 (bit:7) 
.br

.PP
< represents the 8-bit interrupt configuration register parts in bits\&. 
.br

.PP
< represents the 8-bit interrupt configuration register as \fRuint8_t\fP\&. 
.br

.PP
< air quality index per uba[1\&.\&.5] (default: 0x01) (bit:0-2) 
.br

.PP
< reserved and set to 0 (bit:3-7) 
.br

.PP
< represents the 8-bit calculated air quality index data register parts in bits\&. 
.br

.PP
< represents the 8-bit calculated air quality index data register as \fRuint8_t\fP\&. 
.br

.PP
< reserved and set to 0 (bit:0-7)

.PP
< humidity measurement resolution (bit:8-9)

.PP
< temperature measurement resolution (bit:10)

.PP
< battery status (bit:11)

.PP
< acquisition mode (bit:12)

.PP
< heater enabled when true (bit:13)

.PP
< reserved and set to 0 (bit:14)

.PP
< software reset when true (bit:15)

.PP
< represents the 16-bit configuration register parts in bits\&.

.PP
< represents the 16-bit configuration register as \fRuint16_t\fP

.PP
< reserved and set to 0 (bit:0-1)

.PP
< measurement value (bit:2-14)

.PP
< represents the 16-bit measurement register parts in bits\&.

.PP
< represents the 16-bit measurement register as \fRuint16_t\fP

.PP
< reserved and set to 0 (bit:0-6) 
.br

.PP
< serial id 0 (bit:7-15) 
.br

.PP
< serial id 1 (bit:16-31)

.PP
< serial id 2 (bit:32-47)

.PP
< represents the 64-bit measurement register parts in bits\&.

.PP
< represents the 64-bit measurement register as \fRuint64_t\fP

.PP
< measurement configuration, measurement bias (bit:0-1) 
.br

.PP
< data rate at which data is written (bit:2-4) 
.br

.PP
< number of samples averaged (bit:5-6) 
.br

.PP
< reserved and set to 0 (bit:7) 
.br

.PP
< represents the 8-bit configuration 1 register parts in bits\&. 
.br

.PP
< represents the 8-bit configuration 1 register as \fRuint8_t\fP\&. 
.br

.PP
< reserved and set to 0 (bit:0-4) 
.br

.PP
< gain configuration for all channels (bit:5-7) 
.br

.PP
< represents the 8-bit configuration 2 register parts in bits\&. 
.br

.PP
< represents the 8-bit configuration 2 register as \fRuint8_t\fP\&. 
.br

.PP
< operation mode (bit:0-1) 
.br

.PP
< set high to enable i2c high speed (3400khz) (bit:2-7) 
.br

.PP
< represents the 8-bit mode register parts in bits\&. 
.br

.PP
< represents the 8-bit mode register as \fRuint8_t\fP\&. 
.br

.PP
< data is ready when asserted to true (bit:0) 
.br

.PP
< data is locked when asserted to true (bit:1) 
.br

.PP
< reserved (bit:2-7) 
.br

.PP
< represents the 8-bit status register parts in bits\&. 
.br

.PP
< represents the 8-bit status register as \fRuint8_t\fP\&. 
.br

.PP
< reset state BIT15

.PP
< represents the 16-bit control register parts in bits\&.

.PP
< represents the 16-bit control register as \fRuint16_t\fP

.PP
< (bit:0)

.PP
< (bit:1)

.PP
< (bit:2)

.PP
< (bit:3)

.PP
< (bit:4)

.PP
< (bit:5-9)

.PP
< (bit:10)

.PP
< (bit:11)

.PP
< (bit:12)

.PP
< (bit:13)

.PP
< (bit:14)

.PP
< (bit:15)

.PP
< represents the 16-bit mask/enable register parts in bits\&.

.PP
< represents the 16-bit mask/enable register as \fRuint16_t\fP

.PP
< reserved (bit:0) 
.br

.PP
< ltr390uv light sensor (ALS/UVS) standby when false and active when true (bit:1)

.PP
< reserved (bit:2) 
.br

.PP
< ltr390uv operation mode (ALS or UVS) (bit:3)

.PP
< ltr390uv software reset triggered when true (bit:4)

.PP
< reserved (bit:5-7)

.PP
< (bit:0-2) 
.br

.PP
< reserved (bit:3)

.PP
< ltr390uv (bit:4-6)

.PP
< reserved (bit:7)

.PP
< ltr390uv (bit:0-2)

.PP
< reserved (bit:4-6)

.PP
< reserved (bit:0-2) 
.br

.PP
< ltr390uv (bit:3)

.PP
< ltr390uv (bit:4)

.PP
< ltr390uv (bit:5)

.PP
< reserved (bit:6-7)

.PP
< reserved (bit:0-1) 
.br

.PP
< ltr390uv (bit:2)

.PP
< reserved (bit:3)

.PP
< ltr390uv (bit:4-5)

.PP
< reserved (bit:6-7)

.PP
< max30105 On power-up or after a brownout condition, when the supply voltage VDD transitions from below the undervoltage-lockout (UVLO) voltage to above the UVLO voltage, a power-ready interrupt is triggered to signal that the module is powered-up and ready to collect data\&. (bit:0) 
.br

.PP
< reserved (bit:1-3)

.PP
< max30105 the proximity interrupt is triggered when the proximity threshold is reached, and particle-sensing mode has begun\&. This lets the host processor know to begin running the particle-sensing algorithm and collect data\&. The interrupt is cleared by reading the Interrupt Status 1 register (0x00)\&. (bit:4)

.PP
< max30105 this interrupt triggers when the ambient light cancellation function of the particle-sensing photodiode has reached its maximum limit, The interrupt is cleared by reading the Interrupt Status 1 register (0x00)\&. (bit:5)

.PP
< max30105 in particle-sensing mode, this interrupt triggers when there is a new sample in the data FIFO\&. The interrupt is cleared by reading the Interrupt Status 1 register (0x00), or by reading the FIFO_DATA register\&. (bit:6)

.PP
< max30105 in particle-sensing mode, this interrupt triggers when the FIFO write pointer has a certain number of free spaces remaining\&. The interrupt is cleared by reading the Interrupt Status 1 register (0x00)\&. (bit:7)

.PP
< reserved (bit:0)

.PP
< max30105 when an internal die temperature conversion is finished, this interrupt is triggered so the processor can read the temperature data registers\&. The interrupt is cleared by reading either the Interrupt Status 2 register (0x01) or the TFRAC register (0x20)\&. (bit:1) 
.br

.PP
< reserved (bit:2-7)

.PP
< reserved (bit:0-3)

.PP
< max30105 proximity interrupt is asserted when enabled (bit:4)

.PP
< max30105 ambient light cancellation interrupt is asserted when enabled (bit:5)

.PP
< max30105 data ready interrupt is asserted when enabled (bit:6)

.PP
< max30105 interrupt is asserted when enabled (bit:7)

.PP
< reserved (bit:0)

.PP
< max30105 internal temperature ready interrupt is asserted when enabled (bit:1)

.PP
< reserved (bit:2-7)

.PP
< max30105 These bits set the operating state of the MAX30105\&. Changing modes does not change any other setting, nor does it erase any previously stored data inside the data registers\&. (bit:0-2)

.PP
< reserved (bit:5-3)

.PP
< max30105 soft-reset is asserted when enabled, When the RESET bit is set to one, all configuration, threshold, and data registers are reset to their power-on-state through a power-on reset\&. (bit:6)

.PP
< max30105 shutdown is asserted when enabled, The part can be put into a power-save mode by setting this bit to one\&. While in power-save mode, all registers retain their values, and write/read operations function as normal\&. All interrupts are cleared to zero in this mode\&. (bit:7)

.PP
< max30105 multi-LED mode time slot 1 or 3 (bit:0-2)

.PP
< reserved (bit:3)

.PP
< max30105 multi-LED mode time slot 2 or 4 (bit:4-6)

.PP
< reserved (bit:7)

.PP
< max30105 (bit:0-4)

.PP
< reserved (bit:5-7)

.PP
< max30105 (bit:0-4)

.PP
< reserved (bit:5-7)

.PP
< max30105 (bit:0-4)

.PP
< reserved (bit:5-7)

.PP
< max30105 (bit:0-7)

.PP
< iir setting (bit:0-2)

.PP
< repeat sensor test state (bit:3)

.PP
< temperature sensor configuration (bit:4-5)

.PP
< ir sensor type (bit:6)

.PP
< positive or negative signs of k (bit:7)

.PP
< fir setting (bit:8-10)

.PP
< gain setting (bit:11-13)

.PP
< positive or negative signs of kt2 (bit:14)

.PP
< sensor test state (bit:15)

.PP
< represents the 16-bit config register parts in bits\&.

.PP
< represents the 16-bit config register as \fRuint16_t\fP

.PP
< PWM mode (bit:0)

.PP
< PWM mode state (bit:1)

.PP
< SDA pin mode (bit:2)

.PP
< thermal mode (bit:3)

.PP
< PWM repetition number 0\&.\&.\&.62 step of 2 (bit:4-8)

.PP
< PWM period in ms is 1\&.024*bits (single PWM mode) or 2\&.048*bits (extended PWM mode), bits is the multiplier (bit:9-15)

.PP
< represents the 16-bit PWM control register parts in bits\&.

.PP
< represents the 16-bit PWM control register as \fRuint16_t\fP

.PP
< PWM period in ms is calculated from \fRpwm_period_mult\fP and \fRpwm_mode\fP\&.

.PP
< reserved 0 (bit:0-2)

.PP
< not implemented (bit:3)

.PP
< POR initialization routine is still ongoing\&. Low active\&. (bit:4)

.PP
< EEPROM double error has occurred\&. High active (bit:5)

.PP
< unused (bit:6)

.PP
< the previous write/erase EEPROM access is still in progress\&. High active (bit:7)

.PP
< reserved 0 (bit:8-15)

.PP
< represents the 16-bit flags register parts in bits\&.

.PP
< represents the 16-bit flags register as \fRuint16_t\fP

.PP
< reserved and set to 0 (bit:0-3)

.PP
< true when otp memory read (bit:4) 
.br

.PP
< false when selftest pass (bit:5) 
.br

.PP
< true when magnetic measurement done and data is ready, reset when any magnetic data register is read (bit:6) 
.br

.PP
< true when temperature measurement done and data is ready, reset when temperature data register is read (bit:7) 
.br

.PP
< represents the 8-bit status 1 register parts in bits\&. 
.br

.PP
< represents the 8-bit status 1 register as \fRuint8_t\fP and has a reset-value of 0x00\&. 
.br

.PP
< perform magnetic measurement when true and self clears at the end of the measurement (bit:0)

.PP
< perform temperature measurement when true and self clears at the end of the measurement (bit:1)

.PP
< reserved and set to 0 (bit:2)

.PP
< perform set operation when true and self clears at the end of set operation (bit:3)

.PP
< perform reset operation when true and self clears at the end of reset operation (bit:4)

.PP
< enable automatic periodic set/reset when true (bit:5)

.PP
< enable automatic selftest when true and self clears at the end of the operation, set registers 0x1e, 0x1f, and 0x20 beforehand (bit:6)

.PP
< enable measurement period calculation when true and self clears once measurement period is calculated (bit:7)

.PP
< represents the 8-bit control 0 register parts in bits\&. 
.br

.PP
< represents the 8-bit control 0 register as \fRuint8_t\fP and has a reset-value of 0x00\&. 
.br

.PP
< measurement time (bit:0-1)

.PP
< x channel disabled true (bit:2)

.PP
< y channel disabled true (bit:3)

.PP
< z channel disabled true (bit:4)

.PP
< bring selftest coil dc current when true (bit:5)

.PP
< same as st_enp but opposite polarity (bit:6)

.PP
< causes software-reset when true (bit:7)

.PP
< represents the 8-bit control 1 register parts in bits\&. 
.br

.PP
< represents the 8-bit control 1 register as \fRuint8_t\fP and has a reset-value of 0x00\&. 
.br

.PP
< number of samples before set is executed, period set and auto set-reset must be enabled (bit:0-2)

.PP
< perform periodical set when true (bit:3)

.PP
< continuous mode when true, data period (odr) must be non-zero and contineous frequency enabled beforehand (bit:4)

.PP
< reserved and set to 0 (bit:5-6)

.PP
< achieve 1000Hz odr when true (bit:7)

.PP
< represents the 8-bit control 2 register parts in bits\&. 
.br

.PP
< represents the 8-bit control 2 register as \fRuint8_t\fP and has a reset-value of 0x00\&. 
.br

.PP
< mpu6050 (bit:0-4)

.PP
< mpu6050 (bit:5-7)

.PP
< mpu6050 (bit:0-1)

.PP
< mpu6050 (bit:2-3)

.PP
< mpu6050 (bit:4-5)

.PP
< reserved and set to 0 (bit:6-7)

.PP
< mpu6050 digital low-pass filter configuration (bit:0-2)

.PP
< mpu6050 external synchronization setting (bit:3-5)

.PP
< mpu6050 reserved and set to 0 (bit:6-7)

.PP
< mpu6050 reserved and set to 0 (bit:0-2)

.PP
< mpu6050 gyroscope full scale range (bit:3-4)

.PP
< mpu6050 z-axis gyroscope performs self-test when enabled (bit:5)

.PP
< mpu6050 y-axis gyroscope performs self-test when enabled (bit:6)

.PP
< mpu6050 x-axis gyroscope performs self-test when enabled (bit:7)

.PP
< mpu6050 reserved and set to 0 (bit:0-2)

.PP
< mpu6050 accelerometer full scale range (bit:3-4)

.PP
< mpu6050 z-axis accelerometer performs self-test when enabled (bit:5)

.PP
< mpu6050 y-axis accelerometer performs self-test when enabled (bit:6)

.PP
< mpu6050 x-axis accelerometer performs self-test when enabled (bit:7)

.PP
< mpu6050 enables slave 0 to be written into the FIFO buffer (bit:0)

.PP
< mpu6050 enables slave 1 to be written into the FIFO buffer (bit:1)

.PP
< mpu6050 enables slave 2 to be written into the FIFO buffer (bit:2)

.PP
< mpu6050 enables accelerometer (x, y, z) to be written into the FIFO buffer (bit:3)

.PP
< mpu6050 enables gyroscope z-axis to be written into the FIFO buffer (bit:4)

.PP
< mpu6050 enables gyroscope y-axis to be written into the FIFO buffer (bit:5)

.PP
< mpu6050 enables gyroscope x-axis to be written into the FIFO buffer (bit:6)

.PP
< mpu6050 enables temperature to be written into the FIFO buffer (bit:7)

.PP
< mpu6050 enables data ready interrupt (bit:0)

.PP
< mpu6050 reserved and set to 0 (bit:1-2)

.PP
< mpu6050 enables i2c master interrupt (bit:3)

.PP
< mpu6050 enabled fifo overflow interrupt (bit:4)

.PP
< mpu6050 reserved and set to 0 (bit:5-7)

.PP
< reserved and set to 0 (bit:0) 
.br

.PP
< (bit:1)

.PP
< (bit:2)

.PP
< (bit:3)

.PP
< (bit:4)

.PP
< (bit:5)

.PP
< (bit:6)

.PP
< (bit:7)

.PP
< mpu6050 data is ready true when interrupt is generated (bit:0)

.PP
< mpu6050 reserved and set to 0 (bit:1-2)

.PP
< mpu6050 i2c master interrupt generated when true (bit:3)

.PP
< mpu6050 fifo overflow interrupt generated when true (bit:4)

.PP
< mpu6050 reserved and set to 0 (bit:5-7)

.PP
< mpu6050 reset temperature analog and digital signal paths when true (bit:0)

.PP
< mpu6050 reset accelerometer analog and digital signal paths when true (bit:1)

.PP
< mpu6050 reset gyroscope analog and digital signal paths when true (bit:2)

.PP
< mpu6050 reserved and set to 0 (bit:3-7)

.PP
< mpu6050 resets signal paths for all sensors when true (bit:0)

.PP
< mpu6050 resets i2c master when true (bit:1)

.PP
< mpu6050 resets fifo buffer when true (bit:2)

.PP
< mpu6050 reserved and set to 0 (bit:3)

.PP
< mpu6050 disables i2c interface and enables spi interface (bit:4)

.PP
< mpu6050 enables i2c master mode (bit:5)

.PP
< mpu6050 enables fifo operation (bit:6)

.PP
< mpu6050 reserved and set to 0 (bit:7)

.PP
< mpu6050 device clock source (bit:0-2)

.PP
< mpu6050 disables temperature sensor when true (bit:3)

.PP
< mpu6050 reserved and set to 0 (bit:4)

.PP
< mpu6050 will cycle between sleep mode to waking up when enabled to take a single smaple of data from active sensors (bit:5)

.PP
< mpu6050 puts the device into sleep mode when enabled (bit:6)

.PP
< mpu6050 resets all internal registers to default values when enabled (bit:7)

.PP
< mpu6050 gyroscope z-axis in stand-by mode when true (bit:0)

.PP
< mpu6050 gyroscope y-axis in stand-by mode when true (bit:1)

.PP
< mpu6050 gyroscope x-axis in stand-by mode when true (bit:2)

.PP
< mpu6050 accelerometer z-axis in stand-by mode when true (bit:3)

.PP
< mpu6050 accelerometer y-axis in stand-by mode when true (bit:4)

.PP
< mpu6050 accelerometer x-axis in stand-by mode when true (bit:5)

.PP
< mpu6050 frequency of wake-ups in low-power mode (bit:6-7)

.PP
< reserved and set to 0 (bit:0) 
.br

.PP
< mpu6050 device identifier (default: 0x68) (bit:1-6)

.PP
< reserved and set to 0 (bit:7) 
.br

.PP
< one or more tests have failed when true (bit:0) 
.br

.PP
< one or more tests have failed when true (bit:1)

.PP
< reserved (bit:2-7)

.PP
< channel conversion status (bit:0-1) 
.br

.PP
< frame counter (bit:2-3)

.PP
< temperature msb (bit:4-7)

.PP
< by lsb (bit:0-3) 
.br

.PP
< bx lsb (bit:4-7)

.PP
< bz lsb (bit:0-3) 
.br

.PP
< power-down flag, bx, by, bz and temperature conversion completed when true (bit:4)

.PP
< parity fuse flag, fuse setup is okay with true (PT bit must be enabled MOD2) (bit:5)

.PP
< test-mode flag, when false the data is valid (bit:6)

.PP
< reserved, do not modify (bit:7)

.PP
< reserved (bit:0-2) 
.br

.PP
< factory setting - device spefici (bit:3-4) 
.br

.PP
< reserved (bit:5-7)

.PP
< factory setting - device spefici (bit:0-7) 
.br

.PP
< factory setting - device spefici (bit:0-4) 
.br

.PP
< reserved (bit:5-7)

.PP
< factory setting - device specific 0x00 (reset) (bit:0-7) 
.br

.PP
< low power mode enabled when true (bit:0) 
.br

.PP
< fast mode enabled when true (bit:1)

.PP
< interrupt pin assertion when true (bit:2)

.PP
< factory setting - device specific 0x07 (bit:3-4)

.PP
< defines slave address in bus configuration (bit:5-6)

.PP
< parity of configuration map (bit:7)

.PP
< factory setting - device specific 0x08 (bit:0-7) 
.br

.PP
< factory setting - device specific 0x09 (bit:0-4) 
.br

.PP
< parity test enabled when true (bit:5)

.PP
< low power period, 12ms or 100ms (bit:6)

.PP
< temperature measurement is disabled when true (bit:7)

.PP
< shut-down when true (bit:0) 
.br

.PP
< mode, auto or manual (bit:1)

.PP
< trigger, none or one-time detect cycle (bit:2) 
.br

.PP
< reserved and set to 0 (bit:3) 
.br

.PP
< time to measure (bit:6-4) 
.br

.PP
< reserved and set to 0 (bit:7) 
.br

.PP
< reserved and set to 0 (high byte) (bit:0-7) 
.br

.PP
< als shut-down when true (bit:0) 
.br

.PP
< als interrupt enable when true (bit:1) 
.br

.PP
< reserved and set to 0 (bit:2-3) 
.br

.PP
< sample count before the interrupt triggers (bit:4-5) 
.br

.PP
< time to measure (bit:6-9) 
.br

.PP
< reserved and set to 0 (bit:10) 
.br

.PP
< control the sensitivity (bit:11-12)

.PP
< reserved and set to 0 (bit:13-15)

.PP
< power saving enabeld when true (bit:0) 
.br

.PP
< power saving mode (bit:1-2) 
.br

.PP
< reserved and set to 0 (bit:3-15)

.PP
< reserved and set to 0 (bit:0-13)

.PP
< normal unless hi threshold is exceeded (bit:14) 
.br

.PP
< normal unless lo threshold is exceeded (bit:15) 
.br

.PP
< device id code (fixed 0x81) (bit:0-7) 
.br

.PP
< slave address option code (bit:8-15) 
.br

.PP
< reserved and set 1 (bit:0-4)

.PP
< temperature resolution (bit:5-6)

.PP
< reserved and set 0 (bit:7) 
.br

.PP
< represents the 8-bit configuration register parts in bits\&. 
.br

.PP
< represents the 8-bit configuration register as \fRuint8_t\fP\&. 
.br

.PP
< lsb of temperature

.PP
< msb of temperature

.PP
< high trigger alarm threshold

.PP
< low trigger alarm threshold

.PP
< configuration register

.PP
< reserved

.PP
< reserved

.PP
< reserved

.PP
< crc value of scratchpad data

.PP
< filter (bit:0) 
.br

.PP
< (bit:1)

.PP
< (bit:2-3)

.PP
< (bit:4)

.PP
< (bit:5)

.PP
< (bit:6)

.PP
< (bit:7)

.PP
< reserved (bit:0-1) 
.br

.PP
< (bit:2)

.PP
< (bit:3)

.PP
< (bit:4)

.PP
< (bit:5)

.PP
< (bit:6)

.PP
< (bit:7)
.SS "esp_err_t ahtxx_delete (\fBahtxx_handle_t\fP handle)"

.PP
Removes an AHTXX device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AHTXX device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ahtxx_get_busy_status (\fBahtxx_handle_t\fP handle, bool *const busy)"

.PP
Reads busy status flag from AHTXX\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AHTXX device handle\&. 
.br
\fIbusy\fP AHTXX is busy when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ahtxx_get_calibration_status (\fBahtxx_handle_t\fP handle, bool *const calibrated)"

.PP
Reads calibration status flag from AHTXX\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AHTXX device handle\&. 
.br
\fIcalibrated\fP AHTXX is calibrated when true\&. See \fRi2c_ahtxx_setup\fP and datasheet for details\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * ahtxx_get_fw_version (void )"

.PP
Converts AHTXX firmware version numbers (major, minor, patch, build) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* AHTXX firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t ahtxx_get_fw_version_number (void )"

.PP
Converts AHTXX firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t AHTXX firmware version number\&. 
.RE
.PP

.SS "esp_err_t ahtxx_get_measurement (\fBahtxx_handle_t\fP handle, float *const temperature, float *const humidity)"

.PP
Reads temperature and relative humidity from AHTXX\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AHTXX device handle\&. 
.br
\fItemperature\fP Temperature in degree Celsius\&. 
.br
\fIhumidity\fP Relative humidity in percentage\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ahtxx_get_measurements (\fBahtxx_handle_t\fP handle, float *const temperature, float *const humidity, float *const dewpoint)"

.PP
Similar to \fRi2c_aht2x_read_measurement\fP but it includes dewpoint in the results\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AHTXX device handle\&. 
.br
\fItemperature\fP Temperature in degree Celsius\&. 
.br
\fIhumidity\fP Relative humidity in percentage\&. 
.br
\fIdewpoint\fP Calculated dewpoint temperature in degree Celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ahtxx_get_status (\fBahtxx_handle_t\fP handle, bool *const busy, bool *const calibrated)"

.PP
Reads busy and calibrated status flags from AHTXX\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AHTXX device handle\&. 
.br
\fIbusy\fP AHTXX is busy when true\&. 
.br
\fIcalibrated\fP AHTXX is calibrated when true\&. See \fRi2c_ahtxx_setup\fP and datasheet for details\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ahtxx_get_status_register (\fBahtxx_handle_t\fP handle, ahtxx_status_register_t *const reg)"

.PP
Reads status register from AHTXX\&. public function and subroutine declarations 

.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AHTXX device handle\&. 
.br
\fIreg\fP AHTXX status register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ahtxx_init (const i2c_master_bus_handle_t master_handle, const \fBahtxx_config_t\fP * ahtxx_config, \fBahtxx_handle_t\fP *const ahtxx_handle)"

.PP
Initializes an AHTXX device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIahtxx_config\fP AHTXX device configuration\&. 
.br
\fIahtxx_handle\fP AHTXX device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ahtxx_remove (\fBahtxx_handle_t\fP handle)"

.PP
Removes an AHTXX device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AHTXX device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ahtxx_reset (\fBahtxx_handle_t\fP handle)"

.PP
Issues soft-reset and initializes AHTXX\&. See datasheet for details\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AHTXX device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "float ak8975_convert_to_heading (const \fBak8975_magnetic_axes_data_t\fP axes_data)"

.PP
Converts heading (0-359 degrees) from magnetic axes\&. 
.PP
\fBReturns\fP
.RS 4
float heading in degrees (0-359)\&. 
.RE
.PP

.SS "esp_err_t ak8975_delete (\fBak8975_handle_t\fP handle)"

.PP
Removes an AK8975 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AK8975 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ak8975_get_asa_registers (\fBak8975_handle_t\fP handle, uint8_t *const asa_x_reg, uint8_t *const asa_y_reg, uint8_t *const asa_z_reg)"

.PP
Reads ASA (X, Y, Z) registers from AK8975\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AK8975 device handle\&. 
.br
\fIasa_x_reg\fP X-axis ASA compensation value\&. 
.br
\fIasa_y_reg\fP Y-axis ASA compensation value\&. 
.br
\fIasa_z_reg\fP Z-axis ASA compensation value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ak8975_get_control_register (\fBak8975_handle_t\fP handle, ak8975_control_register_t *const reg)"

.PP
Reads control register from AK8975\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AK8975 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * ak8975_get_fw_version (void )"

.PP
Converts AK8975 firmware version numbers (major, minor, patch, build) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* AK8975 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t ak8975_get_fw_version_number (void )"

.PP
Converts AK8975 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t AK8975 firmware version number\&. 
.RE
.PP

.SS "esp_err_t ak8975_get_magnetic_axes (\fBak8975_handle_t\fP handle, \fBak8975_magnetic_axes_data_t\fP *const axes_data)"

.PP
Read magnetic measurement from AK8975\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AK8975 device handle\&. 
.br
\fIaxes_data\fP AK8975 magnetic axes data (X, Y, Z) with sensitivity adjustments applied\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ak8975_get_selftest_control_register (\fBak8975_handle_t\fP handle, ak8975_selftest_control_register_t *const reg)"

.PP
Reads self-test control register from AK8975\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AK8975 device handle\&. 
.br
\fIreg\fP AK8975 self-test control register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ak8975_get_status1_register (\fBak8975_handle_t\fP handle, ak8975_status1_register_t *const reg)"

.PP
Reads status 1 register from AK8975\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AK8975 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ak8975_get_status2_register (\fBak8975_handle_t\fP handle, ak8975_status2_register_t *const reg)"

.PP
Reads status 2 register from AK8975\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AK8975 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ak8975_init (i2c_master_bus_handle_t master_handle, const \fBak8975_config_t\fP * ak8975_config, \fBak8975_handle_t\fP * ak8975_handle)"

.PP
Initializes an AK8975 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIak8975_config\fP AK8975 device configuration\&. 
.br
\fIak8975_handle\fP AK8975 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ak8975_remove (\fBak8975_handle_t\fP handle)"

.PP
Removes an AK8975 device from master I2C bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AK8975 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ak8975_selftest (\fBak8975_handle_t\fP handle, \fBak8975_magnetic_axes_data_t\fP *const axes_data)"

.PP
Self-test judgement of AK8975 to check if sensor is working normally\&. 
.PP
\fBNote\fP
.RS 4
Axes data should be within the following ranges: x-axis (-100<=X<=+100), y-axis (-100<=Y<=+100), z-axis (-1000<=Z<=-300)
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AK8975 device handle\&. 
.br
\fIaxes_data\fP AK8975 magnetic axes data (X, Y, Z) with sensitivity adjustments applied\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ak8975_set_control_register (\fBak8975_handle_t\fP handle, const ak8975_control_register_t reg)"

.PP
Writes control register to AK8975\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AK8975 device handle\&. 
.br
\fIreg\fP AK8975 control register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_calibrate_rco (\fBas3935_handle_t\fP handle)"

.PP
calibrates AS3935 RC oscillator\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_clear_lightning_statistics (\fBas3935_handle_t\fP handle)"

.PP
clears AS3935 lightning statistics\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_delete (\fBas3935_handle_t\fP handle)"

.PP
Removes an AS3935 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_get_0x00_register (\fBas3935_handle_t\fP handle, as3935_0x00_register_t *const reg)"

.PP
gets 0x00 register from AS3935\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_get_0x01_register (\fBas3935_handle_t\fP handle, as3935_0x01_register_t *const reg)"

.PP
gets 0x01 register from AS3935\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.br
\fIreg\fP AS3935 0x01 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_get_0x02_register (\fBas3935_handle_t\fP handle, as3935_0x02_register_t *const reg)"

.PP
gets 0x02 register from AS3935\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.br
\fIreg\fP AS3935 0x02 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_get_0x03_register (\fBas3935_handle_t\fP handle, as3935_0x03_register_t *const reg)"

.PP
gets 0x03 register from AS3935\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.br
\fIreg\fP AS3935 0x03 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_get_0x08_register (\fBas3935_handle_t\fP handle, as3935_0x08_register_t *const reg)"

.PP
gets 0x08 register from AS3935\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.br
\fIreg\fP AS3935 0x08 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * as3935_get_fw_version (void )"

.PP
Converts AS3935 firmware version numbers (major, minor, patch, build) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* AS3935 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t as3935_get_fw_version_number (void )"

.PP
Converts AS3935 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t AS3935 firmware version number\&. 
.RE
.PP

.SS "esp_err_t as3935_get_interrupt_state (\fBas3935_handle_t\fP handle, \fBas3935_interrupt_states_t\fP *const state)"

.PP
gets interrupt state of AS3935\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.br
\fIstate\fP interrupt state of AS3935\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_init (i2c_master_bus_handle_t master_handle, const \fBas3935_config_t\fP * as3935_config, \fBas3935_handle_t\fP * as3935_handle)"

.PP
initializes an AS3935 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIas3935_config\fP AS3935 device configuration\&. 
.br
\fIas3935_handle\fP AS3935 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_monitor_add_handler (\fBas3935_monitor_handle_t\fP monitor_handle, esp_event_handler_t event_handler, void * handler_args)"

.PP
adds user defined event handler for AS3935 monitor\&. 
.PP
\fBParameters\fP
.RS 4
\fImonitor_handle\fP AS3935 monitor handle\&. 
.br
\fIevent_handler\fP user defined event handler\&. 
.br
\fIhandler_args\fP handler specific arguments\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t
.IP "\(bu" 2
ESP_OK on success\&.
.IP "\(bu" 2
ESP_ERR_NO_MEM when unable to allocate memory for the handler\&.
.IP "\(bu" 2
ESP_ERR_INVALIG_ARG when invalid combination of event base and event id is provided\&. 
.PP
.RE
.PP

.SS "esp_err_t as3935_monitor_deinit (\fBas3935_monitor_handle_t\fP monitor_handle)"

.PP
de-initialize AS3935 monitor instance\&. 
.PP
\fBParameters\fP
.RS 4
\fImonitor_handle\fP AS3935 monitor handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_monitor_init (i2c_master_bus_handle_t master_handle, const \fBas3935_config_t\fP * as3935_config, \fBas3935_monitor_handle_t\fP * monitor_handle)"

.PP
initialize AS3935 monitor instance\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP i2c master bus handle\&. 
.br
\fIas3935_config\fP AS3935 configuration\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBas3935_monitor_handle_t\fP AS3935 monitor handle\&. 
.RE
.PP

.SS "esp_err_t as3935_monitor_remove_handler (\fBas3935_monitor_handle_t\fP monitor_handle, esp_event_handler_t event_handler)"

.PP
removes user defined event handler for AS3935 monitor\&. 
.PP
\fBParameters\fP
.RS 4
\fImonitor_handle\fP AS3935 monitor handle\&. 
.br
\fIevent_handler\fP user defined event handler\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t
.IP "\(bu" 2
ESP_OK on success\&.
.IP "\(bu" 2
ESP_ERR_INVALIG_ARG when invalid combination of event base and event id is provided\&. 
.PP
.RE
.PP

.SS "esp_err_t as3935_remove (\fBas3935_handle_t\fP handle)"

.PP
Removes an AS3935 device from I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP as3935 device handle 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_reset_to_defaults (\fBas3935_handle_t\fP handle)"

.PP
resets AS3935 to defaults\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_set_0x00_register (\fBas3935_handle_t\fP handle, const as3935_0x00_register_t reg)"

.PP
sets 0x00 register on AS3935\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.br
\fIreg\fP AS3935 0x00 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_set_0x01_register (\fBas3935_handle_t\fP handle, const as3935_0x01_register_t reg)"

.PP
sets 0x01 register on AS3935\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.br
\fIreg\fP AS3935 0x01 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_set_0x02_register (\fBas3935_handle_t\fP handle, const as3935_0x02_register_t reg)"

.PP
sets 0x02 register on AS3935\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.br
\fIreg\fP AS3935 0x02 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_set_0x03_register (\fBas3935_handle_t\fP handle, const as3935_0x03_register_t reg)"

.PP
sets 0x03 register on AS3935\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.br
\fIreg\fP AS3935 0x03 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as3935_set_0x08_register (\fBas3935_handle_t\fP handle, const as3935_0x08_register_t reg)"

.PP
sets 0x08 register on AS3935\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS3935 device handle\&. 
.br
\fIreg\fP AS3935 0x08 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_clear_flicker_detection_status_register (\fBas7341_handle_t\fP handle)"

.PP
Clears flicker detection status (0xDB) register on AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_delete (\fBas7341_handle_t\fP handle)"

.PP
Removes an AS7341 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_disable_enable_register (\fBas7341_handle_t\fP handle)"

.PP
Disables spectral readings, flicker detection, power, etc\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_disable_flicker_detection (\fBas7341_handle_t\fP handle)"

.PP
Disables AS7341 flicker detection\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_disable_led (\fBas7341_handle_t\fP handle)"

.PP
Disables AS7341 onboard LED\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_disable_power (\fBas7341_handle_t\fP handle)"

.PP
Disables AS7341 power\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_disable_spectral_measurement (\fBas7341_handle_t\fP handle)"

.PP
Disables AS7341 spectral measurement\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_disable_wait_time (\fBas7341_handle_t\fP handle)"

.PP
Disables AS7341 wait time between two consecutive spectral measurements\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_enable_flicker_detection (\fBas7341_handle_t\fP handle)"

.PP
Enables AS7341 flicker detection\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_enable_hi_register_bank (\fBas7341_handle_t\fP handle)"

.PP
Enables access to the AS7341 high register bank (0x80 to 0xFF)\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_enable_led (\fBas7341_handle_t\fP handle)"

.PP
Enables AS7341 onboard LED\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_enable_lo_register_bank (\fBas7341_handle_t\fP handle)"

.PP
Enables access to the AS7341 low register bank (0x60 to 0x74)\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_enable_power (\fBas7341_handle_t\fP handle)"

.PP
Enables AS7341 power\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_enable_smux (\fBas7341_handle_t\fP handle)"

.PP
Enables AS7341 supper multiplier (SMUX) special interrupt\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_enable_spectral_measurement (\fBas7341_handle_t\fP handle)"

.PP
Enables AS7341 spectral measurement\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_enable_wait_time (\fBas7341_handle_t\fP handle)"

.PP
Enables AS7341 wait time between two consecutive spectral measurements\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_ambient_light_sensing_mode (\fBas7341_handle_t\fP handle, \fBas7341_als_modes_t\fP *const mode)"

.PP
Reads ambient light sensing mode from AS7341\&. SPM mode (spectral measurement), normal mode, is configured by default\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fImode\fP AS7341 ambient light sensing mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_astatus_register (\fBas7341_handle_t\fP handle, as7341_astatus_register_t *const reg)"

.PP
Reads ASTATUS register (0x94) from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP ASTATUS register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_astep (\fBas7341_handle_t\fP handle, uint16_t *const astep)"

.PP
Reads the number of integration time steps for the ADC integration time from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIastep\fP Integration time step size\&. Integration time step increment of 2\&.78us, a value of 599 is recommended as a starting point, 50ms integration time\&. ATIME and ASTEP cannot both be zero\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_astep_register (\fBas7341_handle_t\fP handle, uint16_t *const reg)"

.PP
Reads ASTEP (0xCA, 0xCB) register from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Integration time step size\&. Integration time step increment of 2\&.78us, a value of 599 is recommended as a starting point, 50ms integration time\&. ATIME and ASTEP cannot both be zero\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_atime (\fBas7341_handle_t\fP handle, uint8_t *const atime)"

.PP
Reads the number of integration steps for the ADC integration time from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIatime\fP Number of integration steps from 1 to 256, a value of 29 is recommended as a starting point, 50ms integration time\&. ATIME and ASTEP cannot both be zero\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_atime_register (\fBas7341_handle_t\fP handle, uint8_t *const reg)"

.PP
Reads ATIME (0x81) register from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Number of integration steps from 1 to 256, a value of 29 is recommended as a starting point, 50ms integration time\&. ATIME and ASTEP cannot both be zero\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_auxiliary_id_register (\fBas7341_handle_t\fP handle, as7341_auxiliary_id_register_t *const reg)"

.PP
Reads auxiliary id register (0x90) from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Auxiliary id register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_basic_counts (\fBas7341_handle_t\fP handle, const \fBas7341_channels_spectral_data_t\fP spectral_data, \fBas7341_channels_basic_counts_data_t\fP *const basic_counts_data)"

.PP
Converts AS7341 spectral sensors measurements to basic counts\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIspectral_data\fP Spectral sensors data from AS7341\&. 
.br
\fIbasic_counts_data\fP Converted basic counts data from spectral sensors data\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_config0_register (\fBas7341_handle_t\fP handle, as7341_config0_register_t *const reg)"

.PP
Reads configuration 0 register (0xA9) from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Configuration 0 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_config1_register (\fBas7341_handle_t\fP handle, as7341_config1_register_t *const reg)"

.PP
Reads configuration 1 (0xAA) register from AS7341\&. This register configures the 6 integrated ADC (CH0 to CH5)\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Configuration 1 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_config6_register (\fBas7341_handle_t\fP handle, as7341_config6_register_t *const reg)"

.PP
Reads configuration 6 register (0xAF) from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Configuration 6 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_config_register (\fBas7341_handle_t\fP handle, as7341_config_register_t *const reg)"

.PP
Reads configuration register (0x70) from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Configuration register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_data_status (\fBas7341_handle_t\fP handle, bool *const ready)"

.PP
Reads data status from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIready\fP Data is ready when asserted to true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_enable_register (\fBas7341_handle_t\fP handle, as7341_enable_register_t *const reg)"

.PP
Reads enable register (0x80) from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Enable register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_flicker_detection_status (\fBas7341_handle_t\fP handle, \fBas7341_flicker_detection_states_t\fP *const state)"

.PP
Reads flicker detection status from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIstate\fP Flicker detection state, 100Hz, 120Hz or flicker saturation was detected\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success, ESP_ERR_TIMEOUT if operation timed out\&. 
.RE
.PP

.SS "esp_err_t as7341_get_flicker_detection_status_register (\fBas7341_handle_t\fP handle, as7341_flicker_detection_status_register_t *const reg)"

.PP
Reads flicker detection status (0xDB) register from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Flicker detection status register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * as7341_get_fw_version (void )"

.PP
Converts AS7341 firmware version numbers (major, minor, patch, build) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* AS7341 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t as7341_get_fw_version_number (void )"

.PP
Converts AS7341 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t AS7341 firmware version number\&. 
.RE
.PP

.SS "esp_err_t as7341_get_led_register (\fBas7341_handle_t\fP handle, as7341_led_register_t *const reg)"

.PP
Reads LED register (0x74) from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP LED register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_part_id_register (\fBas7341_handle_t\fP handle, as7341_part_id_register_t *const reg)"

.PP
Reads part id register (0x92) from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Part id register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_revision_id_register (\fBas7341_handle_t\fP handle, as7341_revision_id_register_t *const reg)"

.PP
Reads revision id register (0x91) from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Revision id register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_spectral_gain (\fBas7341_handle_t\fP handle, \fBas7341_spectral_gains_t\fP *const gain)"

.PP
Reads spectral gain setting from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIgain\fP AS7341 spectral gain setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_spectral_measurements (\fBas7341_handle_t\fP handle, \fBas7341_channels_spectral_data_t\fP *const spectral_data)"

.PP
Reads spectral sensors measurements, F1 to F8, Clear and NIR, from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIspectral_data\fP Spectral sensors data from AS7341\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_get_status2_register (\fBas7341_handle_t\fP handle, as7341_status2_register_t *const reg)"

.PP
Reads status 2 register (0xA3) from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Status 2 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_init (i2c_master_bus_handle_t master_handle, const \fBas7341_config_t\fP * as7341_config, \fBas7341_handle_t\fP * as7341_handle)"

.PP
Initializes an AS7341 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIas7341_config\fP AS7341 device configuration\&. 
.br
\fIas7341_handle\fP AS7341 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_remove (\fBas7341_handle_t\fP handle)"

.PP
Removes an AS7341 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_ambient_light_sensing_mode (\fBas7341_handle_t\fP handle, const \fBas7341_als_modes_t\fP mode)"

.PP
Writes ambient light sensing mode to AS7341\&. SPM mode (spectral measurement), normal mode, is configured by default\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fImode\fP AS7341 ambient light sensing mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_astep (\fBas7341_handle_t\fP handle, const uint16_t astep)"

.PP
Writes the number of integration time steps for the ADC integration time to AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIastep\fP Integration time step size\&. Integration time step increment of 2\&.78us, a value of 599 is recommended as a starting point, 50ms integration time\&. ATIME and ASTEP cannot both be zero\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_astep_register (\fBas7341_handle_t\fP handle, const uint16_t reg)"

.PP
Writes ASTEP (0xCA, 0xCB) register to AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Integration time step size\&. Integration time step increment of 2\&.78us, a value of 599 is recommended as a starting point, 50ms integration time\&. ATIME and ASTEP cannot both be zero\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_atime (\fBas7341_handle_t\fP handle, const uint8_t atime)"

.PP
Writes the number of integration steps for the ADC integration time to AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIatime\fP Number of integration steps from 1 to 256, a value of 29 is recommended as a starting point, 50ms integration time\&. ATIME and ASTEP cannot both be zero\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_atime_register (\fBas7341_handle_t\fP handle, const uint8_t reg)"

.PP
Writes ATIME (0x81) register to AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Number of integration steps from 1 to 256, a value of 29 is recommended as a starting point, 50ms integration time\&. ATIME and ASTEP cannot both be zero\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_config0_register (\fBas7341_handle_t\fP handle, const as7341_config0_register_t reg)"

.PP
Writes configuration 0 register (0xA9) from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Configuration 0 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_config1_register (\fBas7341_handle_t\fP handle, const as7341_config1_register_t reg)"

.PP
Writes configuration 1 (0xAA) register to AS7341\&. This register configures the 6 integrated ADC (CH0 to CH5)\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Configuration 1 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_config6_register (\fBas7341_handle_t\fP handle, const as7341_config6_register_t reg)"

.PP
Writes configuration 6 register (0xAF) to AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Configuration 6 register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_config_register (\fBas7341_handle_t\fP handle, const as7341_config_register_t reg)"

.PP
Writes configuration register (0x70) from AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Configuration register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_enable_register (\fBas7341_handle_t\fP handle, const as7341_enable_register_t reg)"

.PP
Writes enable register (0x80) to AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Enable register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_flicker_detection_status_register (\fBas7341_handle_t\fP handle, const as7341_flicker_detection_status_register_t reg)"

.PP
Writes flicker detection status (0xDB) register to AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP Flicker detection status register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_led_register (\fBas7341_handle_t\fP handle, const as7341_led_register_t reg)"

.PP
Writes LED register (0x74) to AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIreg\fP LED register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_smux_command (\fBas7341_handle_t\fP handle, const \fBas7341_smux_commands_t\fP command)"

.PP
Writes SMUX command to AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIcommand\fP SMUX command\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t as7341_set_spectral_gain (\fBas7341_handle_t\fP handle, const \fBas7341_spectral_gains_t\fP gain)"

.PP
Writes spectral gain setting to AS7341\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP AS7341 device handle\&. 
.br
\fIgain\fP AS7341 spectral gain setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bh1750_delete (\fBbh1750_handle_t\fP handle)"

.PP
removes an BH1750 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BH1750 device handle 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bh1750_disable_power (\fBbh1750_handle_t\fP handle)"

.PP
power-down BH1750 sensor\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BH1750 device handle 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bh1750_enable_power (\fBbh1750_handle_t\fP handle)"

.PP
power-up BH1750 sensor\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BH1750 device handle 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bh1750_get_ambient_light (\fBbh1750_handle_t\fP handle, float *const ambient_light)"

.PP
measure BH1750 illuminance\&. BH1750 goes into power-down mode after measurement when one-time measurements are configured\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BH1750 device handle 
.br
\fIambient_light\fP BH1750 illuminance measurement 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * bh1750_get_fw_version (void )"

.PP
Converts BH1750 firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* BH1750 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t bh1750_get_fw_version_number (void )"

.PP
Converts BH1750 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t BH1750 firmware version number\&. 
.RE
.PP

.SS "esp_err_t bh1750_init (i2c_master_bus_handle_t master_handle, const \fBbh1750_config_t\fP * bh1750_config, \fBbh1750_handle_t\fP * bh1750_handle)"

.PP
initializes an BH1750 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle 
.br
\fIbh1750_config\fP configuration of BH1750 device 
.br
\fIbh1750_handle\fP BH1750 device handle 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bh1750_remove (\fBbh1750_handle_t\fP handle)"

.PP
removes an BH1750 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BH1750 device handle 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bh1750_reset (\fBbh1750_handle_t\fP handle)"

.PP
soft-reset BH1750 sensor\&. Reset command is not acceptable in power-down mode\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BH1750 device handle 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bh1750_set_measurement_mode (\fBbh1750_handle_t\fP handle, const \fBbh1750_measurement_modes_t\fP mode)"

.PP
Writes measurement mode to bh1750\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP bh1750 device handle\&. 
.br
\fImode\fP bh1750 measurement mode\&. 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bh1750_set_measurement_time (\fBbh1750_handle_t\fP handle, const uint8_t timespan)"

.PP
sets bh1750 sensor measurement time\&. see datasheet for details\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP bh1750 device handle 
.br
\fItimespan\fP bh1750 measurement time duration from 31 to 254 (typical 69) 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "char * bme680_air_quality_to_string (float iaq_score)"

.PP
Air quality as a string based on the IAQ score\&. 
.PP
\fBParameters\fP
.RS 4
\fIiaq_score\fP Index of air quality score\&. 
.RE
.PP
\fBReturns\fP
.RS 4
char* Air quality as a string\&. 
.RE
.PP

.SS "esp_err_t bme680_delete (\fBbme680_handle_t\fP handle)"

.PP
Removes an BME680 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_adc_signals (\fBbme680_handle_t\fP handle, \fBbme680_adc_data_t\fP *const data)"

.PP
Reads humidity, temperature, and pressure ADC signals from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIdata\fP BME680 ADC data structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_chip_id_register (\fBbme680_handle_t\fP handle, uint8_t *const reg)"

.PP
Reads chip identification register from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP BME680 chip identifier\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_configuration_register (\fBbme680_handle_t\fP handle, bme680_config_register_t *const reg)"

.PP
Reads configuration register from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP Configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_control_gas0_register (\fBbme680_handle_t\fP handle, bme680_control_gas0_register_t *const reg)"

.PP
Reads control gas 0 register from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP Control gas 0 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_control_gas1_register (\fBbme680_handle_t\fP handle, bme680_control_gas1_register_t *const reg)"

.PP
Reads control gas 1 register from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP Control gas 1 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_control_humidity_register (\fBbme680_handle_t\fP handle, bme680_control_humidity_register_t *const reg)"

.PP
Reads control humidity register from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP Control humidity register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_control_measurement_register (\fBbme680_handle_t\fP handle, bme680_control_measurement_register_t *const reg)"

.PP
Reads control measurement register from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP Control measurement register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_data (\fBbme680_handle_t\fP handle, \fBbme680_data_t\fP *const data)"

.PP
Reads humidity, temperature, and pressure measurements from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIdata\fP BME680 data structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_data_status (\fBbme680_handle_t\fP handle, bool *const ready)"

.PP
Reads data status of the BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIready\fP Data is ready when asserted to true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * bme680_get_fw_version (void )"

.PP
Converts BME680 firmware version numbers (major, minor, patch, build) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* BME680 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t bme680_get_fw_version_number (void )"

.PP
Converts BME680 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t BME680 firmware version number\&. 
.RE
.PP

.SS "esp_err_t bme680_get_gas_lsb_register (\fBbme680_handle_t\fP handle, bme680_gas_lsb_register_t *const reg)"

.PP
Reads gas resistance LSB register from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP Gas LSB register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_gas_measurement_index (\fBbme680_handle_t\fP handle, uint8_t *const index)"

.PP
Reads gas measurement index from the BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIindex\fP Gas measurement index (0\&.\&.9)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_humidity_oversampling (\fBbme680_handle_t\fP handle, \fBbme680_humidity_oversampling_t\fP *const oversampling)"

.PP
Reads humidity oversampling setting from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIoversampling\fP BME680 humidity oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_iir_filter (\fBbme680_handle_t\fP handle, \fBbme680_iir_filters_t\fP *const iir_filter)"

.PP
Reads IIR filter setting from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIiir_filter\fP BME680 IIR filter setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_power_mode (\fBbme680_handle_t\fP handle, \fBbme680_power_modes_t\fP *const power_mode)"

.PP
Reads power mode setting from the BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIpower_mode\fP BME680 power mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_pressure_oversampling (\fBbme680_handle_t\fP handle, \fBbme680_pressure_oversampling_t\fP *const oversampling)"

.PP
Reads pressure oversampling setting from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIoversampling\fP BME680 pressure oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_status0_register (\fBbme680_handle_t\fP handle, bme680_status0_register_t *const reg)"

.PP
Reads status register from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP Status 0 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_temperature_oversampling (\fBbme680_handle_t\fP handle, \fBbme680_temperature_oversampling_t\fP *const oversampling)"

.PP
Reads temperature oversampling setting from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIoversampling\fP BME680 temperature oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_get_variant_id_register (\fBbme680_handle_t\fP handle, uint8_t *const reg)"

.PP
Reads variant identification register from BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP BME680 variant identifier\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_init (i2c_master_bus_handle_t master_handle, const \fBbme680_config_t\fP * bme680_config, \fBbme680_handle_t\fP * bme680_handle)"

.PP
Initializes an BME680 device onto the master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIbme680_config\fP BME680 device configuration\&. 
.br
\fIbme680_handle\fP BME680 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_remove (\fBbme680_handle_t\fP handle)"

.PP
Removes an BME680 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_reset (\fBbme680_handle_t\fP handle)"

.PP
Issues soft-reset sensor and initializes registers for BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_set_configuration_register (\fBbme680_handle_t\fP handle, const bme680_config_register_t reg)"

.PP
Writes configuration register to BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP Configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_set_control_gas0_register (\fBbme680_handle_t\fP handle, const bme680_control_gas0_register_t reg)"

.PP
Writes control gas 0 register to BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP Control gas 0 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_set_control_gas1_register (\fBbme680_handle_t\fP handle, const bme680_control_gas1_register_t reg)"

.PP
Writes control gas 1 register to BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP Control gas 1 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_set_control_humidity_register (\fBbme680_handle_t\fP handle, const bme680_control_humidity_register_t reg)"

.PP
Writes control humidity register to BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP Control humidity register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_set_control_measurement_register (\fBbme680_handle_t\fP handle, const bme680_control_measurement_register_t reg)"

.PP
Writes control measurement register to BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP Control measurement register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_set_gas_lsb_register (\fBbme680_handle_t\fP handle, const bme680_gas_lsb_register_t reg)"

.PP
Writes gas resistance LSB register to BME680\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIreg\fP Gas LSB register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_set_humidity_oversampling (\fBbme680_handle_t\fP handle, const \fBbme680_humidity_oversampling_t\fP oversampling)"

.PP
Writes humidity oversampling setting to BME680\&. See datasheet, section 3\&.3\&.1, table 4\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIoversampling\fP BME680 humidity oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_set_iir_filter (\fBbme680_handle_t\fP handle, const \fBbme680_iir_filters_t\fP iir_filter)"

.PP
Writes IIR filter setting to BME680\&. See datasheet, section 3\&.4, table 7\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIiir_filter\fP BME680 IIR filter setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_set_power_mode (\fBbme680_handle_t\fP handle, const \fBbme680_power_modes_t\fP power_mode)"

.PP
Writes power mode setting to BME680\&. See datasheet, section 3\&.6, table 10\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIpower_mode\fP BME680 power mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_set_pressure_oversampling (\fBbme680_handle_t\fP handle, const \fBbme680_pressure_oversampling_t\fP oversampling)"

.PP
Writes pressure oversampling setting to BME680\&. See datasheet, section 3\&.3\&.1, table 4\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIoversampling\fP BME680 pressure oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bme680_set_temperature_oversampling (\fBbme680_handle_t\fP handle, const \fBbme680_temperature_oversampling_t\fP oversampling)"

.PP
Writes temperature oversampling setting to BME680\&. See datasheet, section 3\&.3\&.1, table 4\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BME680 device handle\&. 
.br
\fIoversampling\fP BME680 temperature oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_delete (\fBbmp280_handle_t\fP handle)"

.PP
Removes an BMP280 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_get_chip_id_register (\fBbmp280_handle_t\fP handle, uint8_t *const reg)"

.PP
Reads chip identification register from BMP280\&. public function and subroutine declarations 

.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIreg\fP BMP280 chip identification register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_get_configuration_register (\fBbmp280_handle_t\fP handle, bmp280_configuration_register_t *const reg)"

.PP
Reads configuration register from BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIreg\fP BMP280 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_get_control_measurement_register (\fBbmp280_handle_t\fP handle, bmp280_control_measurement_register_t *const reg)"

.PP
Reads control measurement register from BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIreg\fP BMP280 control measurement register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_get_data_status (\fBbmp280_handle_t\fP handle, bool *const ready)"

.PP
Reads data status from BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP bmp280 device handle\&. 
.br
\fIready\fP data is ready when asserted to true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * bmp280_get_fw_version (void )"

.PP
Converts BMP280 firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* BMP280 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t bmp280_get_fw_version_number (void )"

.PP
Converts BMP280 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t BMP280 firmware version number\&. 
.RE
.PP

.SS "esp_err_t bmp280_get_iir_filter (\fBbmp280_handle_t\fP handle, \fBbmp280_iir_filters_t\fP *const iir_filter)"

.PP
Reads IIR filter setting to BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIiir_filter\fP IIR filter setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_get_measurements (\fBbmp280_handle_t\fP handle, float *const temperature, float *const pressure)"

.PP
Reads temperature and pressure measurements from BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fItemperature\fP Temperature in degree Celsius\&. 
.br
\fIpressure\fP Pressure in pascal\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_get_power_mode (\fBbmp280_handle_t\fP handle, \fBbmp280_power_modes_t\fP *const power_mode)"

.PP
Reads power mode setting from BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIpower_mode\fP Power mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_get_pressure (\fBbmp280_handle_t\fP handle, float *const pressure)"

.PP
Reads pressure measurement from BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIpressure\fP Pressure in pascal\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_get_pressure_oversampling (\fBbmp280_handle_t\fP handle, \fBbmp280_pressure_oversampling_t\fP *const oversampling)"

.PP
Reads pressure oversampling setting from BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIoversampling\fP Pressure oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_get_standby_time (\fBbmp280_handle_t\fP handle, \fBbmp280_standby_times_t\fP *const standby_time)"

.PP
Reads stand-by time setting from BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIstandby_time\fP Stand-by time setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_get_status_register (\fBbmp280_handle_t\fP handle, bmp280_status_register_t *const reg)"

.PP
Reads status register from BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle[in]\fP BMP280 device handle\&. 
.br
\fIreg\fP BMP280 status register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_get_temperature (\fBbmp280_handle_t\fP handle, float *const temperature)"

.PP
Reads temperature measurement from BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fItemperature\fP Temperature in degree Celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_get_temperature_oversampling (\fBbmp280_handle_t\fP handle, \fBbmp280_temperature_oversampling_t\fP *const oversampling)"

.PP
Reads temperature oversampling setting from BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIoversampling\fP Temperature oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_init (i2c_master_bus_handle_t master_handle, const \fBbmp280_config_t\fP * bmp280_config, \fBbmp280_handle_t\fP * bmp280_handle)"

.PP
Initializes an BMP280 device onto the master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIbmp280_config\fP BMP280 device configuration\&. 
.br
\fIbmp280_handle\fP BMP280 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_remove (\fBbmp280_handle_t\fP handle)"

.PP
Removes an BMP280 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_reset (\fBbmp280_handle_t\fP handle)"

.PP
Issues soft-reset sensor and initializes BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_set_configuration_register (\fBbmp280_handle_t\fP handle, const bmp280_configuration_register_t reg)"

.PP
Writes configuration register to BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIreg\fP BMP280 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_set_control_measurement_register (\fBbmp280_handle_t\fP handle, const bmp280_control_measurement_register_t reg)"

.PP
Writes control measurement register to BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIreg\fP BMP280 control measurement register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_set_iir_filter (\fBbmp280_handle_t\fP handle, const \fBbmp280_iir_filters_t\fP iir_filter)"

.PP
Writes IIR filter setting to BMP280\&. See datasheet, section 3\&.4, table 7\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIiir_filter\fP IIR filter setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_set_power_mode (\fBbmp280_handle_t\fP handle, const \fBbmp280_power_modes_t\fP power_mode)"

.PP
Writes power mode setting to the BMP280\&. See datasheet, section 3\&.6, table 10\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIpower_mode\fP Power mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_set_pressure_oversampling (\fBbmp280_handle_t\fP handle, const \fBbmp280_pressure_oversampling_t\fP oversampling)"

.PP
Writes pressure oversampling setting to BMP280\&. See datasheet, section 3\&.3\&.1, table 4\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIoversampling\fP Pressure oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_set_standby_time (\fBbmp280_handle_t\fP handle, const \fBbmp280_standby_times_t\fP standby_time)"

.PP
Writes stand-by time setting to BMP280\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIstandby_time\fP Stand-by time setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp280_set_temperature_oversampling (\fBbmp280_handle_t\fP handle, const \fBbmp280_temperature_oversampling_t\fP oversampling)"

.PP
Writes temperature oversampling setting to BMP280\&. See datasheet, section 3\&.3\&.1, table 4\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP280 device handle\&. 
.br
\fIoversampling\fP Temperature oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_delete (\fBbmp390_handle_t\fP handle)"

.PP
Removes an BMP390 device from master I2C bus and delete the handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_chip_id_register (\fBbmp390_handle_t\fP handle, uint8_t *const reg)"

.PP
Reads chip identification register from BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIreg\fP BMP390 chip identification register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_configuration_register (\fBbmp390_handle_t\fP handle, bmp390_configuration_register_t *const reg)"

.PP
Reads configuration register from BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIreg\fP BMP390 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_data_status (\fBbmp390_handle_t\fP handle, bool *const temperature_ready, bool *const pressure_ready)"

.PP
Reads data status of the BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fItemperature_ready\fP Temperature data is ready when asserted to true\&. 
.br
\fIpressure_ready\fP Pressure data is ready when asserted to true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * bmp390_get_fw_version (void )"

.PP
Converts BMP390 firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* BMP390 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t bmp390_get_fw_version_number (void )"

.PP
Converts BMP390 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t BMP390 firmware version number\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_iir_filter (\fBbmp390_handle_t\fP handle, \fBbmp390_iir_filters_t\fP *const iir_filter)"

.PP
Reads IIR filter setting to BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIiir_filter\fP BMP390 IIR filter setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_interrupt_control_register (\fBbmp390_handle_t\fP handle, bmp390_interrupt_control_register_t *const reg)"

.PP
Reads interrupt control register from BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIreg\fP BMP390 interrupt control register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_interrupt_status_register (\fBbmp390_handle_t\fP handle, bmp390_interrupt_status_register_t *const reg)"

.PP
Reads interrupt control register from BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIreg\fP BMP390 interrupt status register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_measurements (\fBbmp390_handle_t\fP handle, float *const temperature, float *const pressure)"

.PP
Reads high-level measurements (temperature & pressure) from BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fItemperature\fP Temperature in degree Celsius\&. 
.br
\fIpressure\fP Pressure in pascal\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_output_data_rate (\fBbmp390_handle_t\fP handle, \fBbmp390_output_data_rates_t\fP *const output_data_rate)"

.PP
Reads output data rate setting from BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIoutput_data_rate\fP BMP390 output data rate setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_output_data_rate_register (\fBbmp390_handle_t\fP handle, bmp390_output_data_rate_register_t *const reg)"

.PP
Reads output data rate register from BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIreg\fP BMP390 output data rate register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_oversampling_register (\fBbmp390_handle_t\fP handle, bmp390_oversampling_register_t *const reg)"

.PP
Reads oversampling register from BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIreg\fP BMP390 oversampling register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_power_control_register (\fBbmp390_handle_t\fP handle, bmp390_power_control_register_t *const reg)"

.PP
Reads power control register from BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIreg\fP BMP390 power control register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_power_mode (\fBbmp390_handle_t\fP handle, \fBbmp390_power_modes_t\fP *const power_mode)"

.PP
Reads power mode setting from the BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIpower_mode\fP BMP390 power mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_pressure_oversampling (\fBbmp390_handle_t\fP handle, \fBbmp390_pressure_oversampling_t\fP *const oversampling)"

.PP
Reads pressure oversampling setting from BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIoversampling\fP BMP390 pressure oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_status (\fBbmp390_handle_t\fP handle, bool *const temperature_ready, bool *const pressure_ready, bool *const command_ready)"

.PP
Reads status of the BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fItemperature_ready\fP Temperature data is ready when asserted to true\&. 
.br
\fIpressure_ready\fP Pressure data is ready when asserted to true\&. 
.br
\fIcommand_ready\fP Command is ready when asserted to true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_status_register (\fBbmp390_handle_t\fP handle, bmp390_status_register_t *const reg)"

.PP
Reads status register from BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIreg\fP BMP390 status register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_get_temperature_oversampling (\fBbmp390_handle_t\fP handle, \fBbmp390_temperature_oversampling_t\fP *const oversampling)"

.PP
Reads temperature oversampling setting from BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIoversampling\fP BMP390 temperature oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_init (i2c_master_bus_handle_t master_handle, const \fBbmp390_config_t\fP * bmp390_config, \fBbmp390_handle_t\fP * bmp280_handle)"

.PP
Initializes an BMP390 device onto the master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIbmp390_config\fP BMP390 device configuration\&. 
.br
\fIbmp390_handle\fP BMP390 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_remove (\fBbmp390_handle_t\fP handle)"

.PP
removes an BMP390 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_reset (\fBbmp390_handle_t\fP handle)"

.PP
Issues soft-reset sensor and initializes registers for BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_set_configuration_register (\fBbmp390_handle_t\fP handle, const bmp390_configuration_register_t reg)"

.PP
Writes configuration register to BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIreg\fP BMP390 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_set_iir_filter (\fBbmp390_handle_t\fP handle, const \fBbmp390_iir_filters_t\fP iir_filter)"

.PP
Writes IIR filter setting from BMP390\&. See datasheet, section 3\&.4, table 7\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIiir_filter\fP BMP390 IIR filter setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_set_interrupt_control_register (\fBbmp390_handle_t\fP handle, const bmp390_interrupt_control_register_t reg)"

.PP
Writes interrupt control register to BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIreg\fP BMP390 interrupt control register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_set_output_data_rate (\fBbmp390_handle_t\fP handle, const \fBbmp390_output_data_rates_t\fP output_data_rate)"

.PP
writes output data rate setting to bmp390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIoutput_data_rate\fP BMP390 output data rate setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_set_output_data_rate_register (\fBbmp390_handle_t\fP handle, const bmp390_output_data_rate_register_t reg)"

.PP
Writes output data rate register to BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIreg\fP BMP390 output data rate register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_set_oversampling_register (\fBbmp390_handle_t\fP handle, const bmp390_oversampling_register_t reg)"

.PP
Writes oversampling register to BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIreg\fP BMP390 oversampling register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_set_power_control_register (\fBbmp390_handle_t\fP handle, const bmp390_power_control_register_t reg)"

.PP
Writes power control register to BMP390\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIreg\fP BMP390 power control register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_set_power_mode (\fBbmp390_handle_t\fP handle, const \fBbmp390_power_modes_t\fP power_mode)"

.PP
Writes power mode setting to the BMP390\&. See datasheet, section 3\&.6, table 10\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIpower_mode\fP BMP390 power mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_set_pressure_oversampling (\fBbmp390_handle_t\fP handle, const \fBbmp390_pressure_oversampling_t\fP oversampling)"

.PP
Writes pressure oversampling setting to BMP390\&. See datasheet, section 3\&.3\&.1, table 4\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIoversampling\fP BMP390 pressure oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t bmp390_set_temperature_oversampling (\fBbmp390_handle_t\fP handle, const \fBbmp390_temperature_oversampling_t\fP oversampling)"

.PP
Writes temperature oversampling setting to BMP390\&. See datasheet, section 3\&.3\&.1, table 4\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP BMP390 device handle\&. 
.br
\fIoversampling\fP BMP390 temperature oversampling setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_delete (\fBccs811_handle_t\fP handle)"

.PP
Removes an CCS811 device from master I2C bus and delete the handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * ccs811_err_to_code (const ccs811_error_code_register_t error_reg)"

.PP
Decodes CCS811 device error to a textual code representation\&. 
.PP
\fBParameters\fP
.RS 4
\fIcode\fP CCS811 I2C register error\&. 
.RE
.PP
\fBReturns\fP
.RS 4
char textual representation of error code on success\&. 
.RE
.PP

.SS "const char * ccs811_err_to_message (const ccs811_error_code_register_t error_reg)"

.PP
Decodes CCS811 device error to a textual message representation\&. 
.PP
\fBParameters\fP
.RS 4
\fIcode\fP CCS811 I2C register error\&. 
.RE
.PP
\fBReturns\fP
.RS 4
char textual representation of error message on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_get_baseline_register (\fBccs811_handle_t\fP handle, uint16_t *const reg)"

.PP
Reads encoded version of the current baseline register from CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIreg\fP CCS811 encoded version of the baseline register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_get_data_status (\fBccs811_handle_t\fP handle, bool *const ready)"

.PP
Reads data ready status from CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIready\fP CCS811 data is ready when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_get_drive_mode (\fBccs811_handle_t\fP handle, \fBccs811_drive_modes_t\fP *const mode)"

.PP
Reads drive mode from CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fImode\fP CCS811 measurement drive mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_get_error_register (\fBccs811_handle_t\fP handle, ccs811_error_code_register_t *const reg)"

.PP
Reads error register from CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIreg\fP CCS811 error register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_get_error_status (\fBccs811_handle_t\fP handle, bool *const error)"

.PP
Reads error status from CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIerror\fP CCS811 error is present when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_get_firmware_mode (\fBccs811_handle_t\fP handle, \fBccs811_firmware_modes_t\fP *const mode)"

.PP
Reads firmware mode from CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fImode\fP CCS811 firmware mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * ccs811_get_fw_version (void )"

.PP
Converts CCS811 firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* CCS811 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t ccs811_get_fw_version_number (void )"

.PP
Converts CCS811 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t CCS811 firmware version number\&. 
.RE
.PP

.SS "esp_err_t ccs811_get_hardware_identifier_register (\fBccs811_handle_t\fP handle, uint8_t *const reg)"

.PP
Reads hardware identifier register from CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIreg\fP CCS811 hardware identifier register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_get_hardware_version_register (\fBccs811_handle_t\fP handle, uint8_t *const reg)"

.PP
Reads hardware version register from CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIreg\fP CCS811 hardware version register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_get_measure_mode_register (\fBccs811_handle_t\fP handle, ccs811_measure_mode_register_t *const reg)"

.PP
Reads measure mode register from CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIreg\fP CCS811 measure mode register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_get_measurement (\fBccs811_handle_t\fP handle, uint16_t * eco2, uint16_t * etvoc)"

.PP
Reads air quality measurement from CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIeco2\fP Equivalent CO2 in ppm (range is from 400 to 32768 ppm)\&. 
.br
\fIetvoc\fP Equivalent Total Volatile Oragnic Compound (TVOC) in ppb (range is from 0 to 29206 ppb)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_get_ntc_resistance (\fBccs811_handle_t\fP handle, const uint32_t r_ref, uint32_t *const resistance)"

.PP
Reads NTC resistance connected to CCS811 per AMS application note AN000372\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIr_ref\fP CCS811 resistance reference value\&. 
.br
\fIresistance\fP CCS811 NTC resistance value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_get_status_register (\fBccs811_handle_t\fP handle, ccs811_status_register_t *const reg)"

.PP
Reads status register from CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIreg\fP CCS811 status register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_init (i2c_master_bus_handle_t master_handle, const \fBccs811_config_t\fP * ccs811_config, \fBccs811_handle_t\fP * ccs811_handle)"

.PP
Initializes a CCS811 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIccs811_config\fP CCS811 device configuration\&. 
.br
\fIccs811_handle\fP CCS811 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_io_reset (\fBccs811_handle_t\fP handle)"

.PP
Resets the CCS811 through the configured reset GPIO pin number\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_io_sleep (\fBccs811_handle_t\fP handle)"

.PP
Puts the CCS811 a sleep through the configured wake GPIO pin number\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_io_wake (\fBccs811_handle_t\fP handle)"

.PP
Wakes the CCS811 through the configured wake GPIO pin number\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * ccs811_measure_mode_description (const \fBccs811_drive_modes_t\fP mode)"

.PP
Decodes enumerated drive mode to a textual descriptive representation\&. 
.PP
\fBParameters\fP
.RS 4
\fImode\fP measurement drive mode\&. 
.RE
.PP
\fBReturns\fP
.RS 4
char textual representation of measure mode on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_remove (\fBccs811_handle_t\fP handle)"

.PP
Removes a CCS811 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_reset (\fBccs811_handle_t\fP handle)"

.PP
Issues soft-reset to CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_set_baseline_register (\fBccs811_handle_t\fP handle, const uint16_t reg)"

.PP
Writes encoded version to the CCS811 baseline register\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIreg\fP CCS811 encoded version of the baseline register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_set_drive_mode (\fBccs811_handle_t\fP handle, const \fBccs811_drive_modes_t\fP mode)"

.PP
Writes drive mode to CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fImode\fP CCS811 measurement drive mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_set_environmental_data (\fBccs811_handle_t\fP handle, const float temperature, const float humidity)"

.PP
Writes environmental compensation factors data to CCS811 register\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fItemperature\fP Temperature compensation in degrees Celsius (default: 25 C)\&. 
.br
\fIhumidity\fP Relative humidity compensation in percentage (default: 50 %)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_set_environmental_data_register (\fBccs811_handle_t\fP handle, const float temperature, const float humidity)"

.PP
Writes environmental compensation factors data to CCS811 register\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fItemperature\fP temperature compensation in degrees Celsius (default: 25 C)\&. 
.br
\fIhumidity\fP relative humidity compensation in percentage (default: 50 %)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_set_measure_mode_register (\fBccs811_handle_t\fP handle, const ccs811_measure_mode_register_t reg)"

.PP
Writes measure mode register to CCS811\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIreg\fP CCS811 measure mode register structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_set_thresholds (\fBccs811_handle_t\fP handle, const uint16_t low_to_med, const uint16_t med_to_high, const uint8_t hysteresis)"

.PP
Writes eCO2 thresholds to CCS811 register\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIlow_to_med\fP Low to medium threshold within a range of 400 to 32768 ppm (1500 ppm)\&. 
.br
\fImed_to_high\fP Medium to high threshold within a range of 400 to 32768 ppm (2500 ppm)\&. 
.br
\fIhysteresis\fP Variance for thresholds in ppm (default: 50 ppm)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_set_thresholds_register (\fBccs811_handle_t\fP handle, const uint16_t low_to_med, const uint16_t med_to_high, const uint8_t hysteresis)"

.PP
Writes eCO2 thresholds to CCS811 register\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.br
\fIlow_to_med\fP Low to medium threshold within a range of 400 to 32768 ppm (1500 ppm)\&. 
.br
\fImed_to_high\fP Medium to high threshold within a range of 400 to 32768 ppm (2500 ppm)\&. 
.br
\fIhysteresis\fP Variance for thresholds in ppm (default: 50 ppm)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ccs811_start_application (\fBccs811_handle_t\fP handle)"

.PP
Starts the CCS811 application\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP CCS811 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_bool_smp_column (\fBdatatable_handle_t\fP datatable_handle, const char * name, uint8_t * index)"

.PP
Appends a bool based data-type column as a sample process-type to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname\fP Textual name of the data-table column to be added\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_float_avg_column (\fBdatatable_handle_t\fP datatable_handle, const char * name, uint8_t * index)"

.PP
Appends a float based data-type column as an average process-type to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname\fP Textual name of the data-table column to be added\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_float_max_column (\fBdatatable_handle_t\fP datatable_handle, const char * name, uint8_t * index)"

.PP
Appends a float based data-type column as a maximum process-type to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname\fP Textual name of the data-table column to be added\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_float_max_ts_column (\fBdatatable_handle_t\fP datatable_handle, const char * name, uint8_t * index)"

.PP
Appends a float based data-type column as a maximum with timestamp process-type to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname\fP Textual name of the data-table column to be added\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_float_min_column (\fBdatatable_handle_t\fP datatable_handle, const char * name, uint8_t * index)"

.PP
Appends a float based data-type column as a minimum process-type to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname\fP Textual name of the data-table column to be added\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_float_min_ts_column (\fBdatatable_handle_t\fP datatable_handle, const char * name, uint8_t * index)"

.PP
Appends a float based data-type column as a minimum with timestamp process-type to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname\fP Textual name of the data-table column to be added\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_float_smp_column (\fBdatatable_handle_t\fP datatable_handle, const char * name, uint8_t * index)"

.PP
Appends a float based data-type column as a sample process-type to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname\fP Textual name of the data-table column to be added\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_int16_avg_column (\fBdatatable_handle_t\fP datatable_handle, const char * name, uint8_t * index)"

.PP
Appends a int16 based data-type column as an average process-type to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname\fP Textual name of the data-table column to be added\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_int16_max_column (\fBdatatable_handle_t\fP datatable_handle, const char * name, uint8_t * index)"

.PP
Appends a int16 based data-type column as a maximum process-type to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname\fP Textual name of the data-table column to be added\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_int16_max_ts_column (\fBdatatable_handle_t\fP datatable_handle, const char * name, uint8_t * index)"

.PP
Appends a int16 based data-type column as a maximum with timestamp process-type to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname\fP Textual name of the data-table column to be added\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_int16_min_column (\fBdatatable_handle_t\fP datatable_handle, const char * name, uint8_t * index)"

.PP
Appends a int16 based data-type column as a minimum process-type to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname\fP Textual name of the data-table column to be added\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_int16_min_ts_column (\fBdatatable_handle_t\fP datatable_handle, const char * name, uint8_t * index)"

.PP
Appends a int16 based data-type column as a minimum with timestamp process-type to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname\fP Textual name of the data-table column to be added\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_int16_smp_column (\fBdatatable_handle_t\fP datatable_handle, const char * name, uint8_t * index)"

.PP
Appends a int16 based data-type column as a sample process-type to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname\fP Textual name of the data-table column to be added\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_vector_avg_column (\fBdatatable_handle_t\fP datatable_handle, const char * name_uc, const char * name_vc, uint8_t * index)"

.PP
Appends a vector based data-type column as an average to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname_uc\fP Textual name of the data-table column to be added for vector u-component\&. 
.br
\fIname_vc\fP Textual name of the data-table column to be added for vector v-component\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_vector_max_column (\fBdatatable_handle_t\fP datatable_handle, const char * name_uc, const char * name_vc, uint8_t * index)"

.PP
Appends a vector based data-type column as a v-component maximum to the data-table\&. The u-component at v-component maximum is sampled and stored\&.

.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname_uc\fP Textual name of the data-table column to be added for vector u-component\&. 
.br
\fIname_vc\fP Textual name of the data-table column to be added for vector v-component\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_vector_max_ts_column (\fBdatatable_handle_t\fP datatable_handle, const char * name_uc, const char * name_vc, uint8_t * index)"

.PP
Appends a vector based data-type column as a v-component maximum with timestamp to the data-table\&. The u-component at v-component maximum is sampled and stored\&.

.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname_uc\fP Textual name of the data-table column to be added for vector u-component\&. 
.br
\fIname_vc\fP Textual name of the data-table column to be added for vector v-component\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_vector_min_column (\fBdatatable_handle_t\fP datatable_handle, const char * name_uc, const char * name_vc, uint8_t * index)"

.PP
Appends a vector based data-type column as a v-component minimum to the data-table\&. The u-component at v-component minimum is sampled and stored\&.

.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname_uc\fP Textual name of the data-table column to be added for vector u-component\&. 
.br
\fIname_vc\fP Textual name of the data-table column to be added for vector v-component\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_vector_min_ts_column (\fBdatatable_handle_t\fP datatable_handle, const char * name_uc, const char * name_vc, uint8_t * index)"

.PP
Appends a vector based data-type column as a v-component minimum with timestamp to the data-table\&. The u-component at v-component minimum is sampled and stored\&.

.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname_uc\fP Textual name of the data-table column to be added for vector u-component\&. 
.br
\fIname_vc\fP Textual name of the data-table column to be added for vector v-component\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_add_vector_smp_column (\fBdatatable_handle_t\fP datatable_handle, const char * name_uc, const char * name_vc, uint8_t * index)"

.PP
Appends a vector based data-type column as a sample to the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIname_uc\fP Textual name of the data-table column to be added for vector u-component\&. 
.br
\fIname_vc\fP Textual name of the data-table column to be added for vector v-component\&. 
.br
\fIindex\fP Index of the column that was added to the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_delete (\fBdatatable_handle_t\fP datatable_handle)"

.PP
Deletes the data-table handle to frees up resources\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_get_column (\fBdatatable_handle_t\fP datatable_handle, const uint8_t index, \fBdatatable_column_t\fP ** column)"

.PP
Gets the column structure from the data-table based on the column index\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIindex\fP Data-table column index to output\&. 
.br
\fIcolumn\fP Data-table column structure output\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_get_columns_count (\fBdatatable_handle_t\fP datatable_handle, uint8_t * count)"

.PP
Gets the number of columns in the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIcount\fP Number of columns in the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_get_row (\fBdatatable_handle_t\fP datatable_handle, const uint8_t index, \fBdatatable_row_t\fP ** row)"

.PP
Gets the row structure from the data-table based on the row index\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIindex\fP Data-table row index to output\&. 
.br
\fIrow\fP Data-table row structure output\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_get_rows_count (\fBdatatable_handle_t\fP datatable_handle, uint8_t * count)"

.PP
Gets the number of rows in the data-table\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIcount\fP Number of rows in the data-table\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_init (const \fBdatatable_config_t\fP * datatable_config, \fBdatatable_handle_t\fP * datatable_handle)"

.PP
Initializes a data-table handle\&. A data-table handle instance is required before any other data-table functions can be called\&. Once the data-table is initialized the following functions are used to configure the data-table columns and within the sampling task\&. Use the \fRdatatable_add_[data-type]_[process-type]_column\fP functions to define data-table columns 
.br
 by data-type and process-type\&. The data-table columns are ordered as they are added and column index for the first user-defined column always starts at 2 given the record identifier and timestamp columns 
.br
 are created by default and consume column indexes 0 and 1 respectively\&.

.PP
Use the \fRdatatable_sampling_task_delay\fP function within the sampling task to sample measurements at the data-table's configured sampling interval\&.

.PP
Use the \fRdatatable_push_[data-type]_sample\fP functions within the sampling task to push samples onto the column data buffer stack for processing\&. These functions should be placed after the \fRdatatable_sampling_task_delay\fP function\&.

.PP
Use the \fRdatatable_process_samples\fP function within the sampling task to process column data buffer samples at the data-table's configured processing interval\&. This function should be placed after the \fRdatatable_push_[data-type]_sample\fP functions\&.

.PP
\fBParameters\fP
.RS 4
\fIdatatable_config\fP Data-table configuration\&. 
.br
\fIdatatable_handle\fP Data-table handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP
validate data-table sampling and processing type, period and offset arguments

.PP
the sampling rate must be lower than the processing interval\&. as an example, a 5-sec sampling rate with a 1-min processing interval would trigger processing of the row columns once every minute and would process 12 samples based on the desired processing type (i\&.e\&. avg, min, max)\&. if the processing type is configured to smp a sample would be updated every sampling interval and latest value would be recorded during the processing interval\&.
.SS "esp_err_t datatable_process_samples (\fBdatatable_handle_t\fP datatable_handle)"

.PP
Processes data-table samples on the data buffer stack in each column based on the data-table's 
.br
 configured processing interval\&. When the samples are processed, the data buffer stack is cleared for each column\&. This function must be called after data-table samples are pushed in the sampling task\&. If the sampling period exceeds the data-table's configured sampling interval, a skipped task event is recorded, and data-table may not process samples as expected\&.

.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_push_bool_sample (\fBdatatable_handle_t\fP datatable_handle, const uint8_t index, const bool value)"

.PP
Pushes a boolean data-type sample onto the column sample data buffer stack for processing\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIindex\fP Sample data-table column index\&. 
.br
\fIvalue\fP Boolean data-type sample to process\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_push_float_sample (\fBdatatable_handle_t\fP datatable_handle, const uint8_t index, const float value)"

.PP
Pushes a float data-type sample onto the column sample data buffer stack for processing\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIindex\fP Sample data-table column index\&.\&. 
.br
\fIvalue\fP Float data-type sample to process\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_push_int16_sample (\fBdatatable_handle_t\fP datatable_handle, const uint8_t index, const int16_t value)"

.PP
Pushes an int16 data-type sample onto the column sample data buffer stack for processing\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIindex\fP Sample data-table column index\&. 
.br
\fIvalue\fP Int16 data-type sample to process\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_push_vector_sample (\fBdatatable_handle_t\fP datatable_handle, const uint8_t index, const float uc_value, const float vc_value)"

.PP
Pushes a vector data-type sample onto the column sample data buffer stack for processing\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIindex\fP Sample data-table column index\&. 
.br
\fIuc_value\fP Vector data-type u-component sample to process\&. 
.br
\fIvc_value\fP Vector data-type v-component sample to process\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_sampling_task_delay (\fBdatatable_handle_t\fP datatable_handle)"

.PP
Delays the data-table's sampling task until the next scheduled task event\&. 
.br
 This function should be placed after the \fRfor (;;) {\fP syntax to delay the task based on the configured time-into-interval handle interval type, period, and offset parameters\&. 
.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t datatable_to_json (\fBdatatable_handle_t\fP datatable_handle, cJSON ** datatable)"

.PP
Converts a data-table to a \fRcJSON\fP object\&. \fRcJSON\fP data-table object output example;

.PP
{ "name": "1min_tbl", "process-interval": "minute", "process-period": 1, "columns": ["Record ID", "TS", "Pa_1-Min_Avg", "Ta_1-Min_Avg", "Ta_1-Min_Min", "Ta_1-Min_Max", "Hr_1-Min_Avg", "Td_1-Min_Avg", "Wd_1-Min_Avg", "Ws_1-Min_Avg"], "types": ["id", "ts", "float", "float", "float", "float", "int16", "float", "float", "float"], "processes": ["sample", "sample", "average", "average", "minimum", "maximum", "average", "average", "average", "average"], "rows": [ [1, 61684380120, 1001\&.3500366210938, 22\&.350000381469727, 22\&.340000152587891, 22\&.360000610351562, 51, 20\&.350000381469727, 210, 1\&.4500000476837158], [2, 61684380180, 1001\&.3533325195312, 22\&.35333251953125, 22\&.340000152587891, 22\&.360000610351562, 53, 20\&.353334426879883, 210, 1\&.4500000476837158], [3, 61684380240, 1001\&.3583374023438, 22\&.358335494995117, 22\&.350000381469727, 22\&.3700008392334, 55, 20\&.358333587646484, 210, 1\&.4500000476837158], [4, 61684380300, 1001\&.3417358398438, 22\&.341667175292969, 22\&.329999923706055, 22\&.350000381469727, 57, 20\&.341667175292969, 210, 1\&.4500000476837158]] }

.PP
\fBParameters\fP
.RS 4
\fIdatatable_handle\fP Data-table handle\&. 
.br
\fIdatatable\fP Data-table as a \fRcJSON\fP object\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ds18b20_alarm_triggered (\fBds18b20_handle_t\fP handle, bool *const alarm)"

.PP
Check if the DS18B20 temperature alarm triggered\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP DS18B20 device handle\&. 
.br
\fIalarm\fP DS18B20 alarm triggered when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ds18b20_connected (\fBds18b20_handle_t\fP handle, bool *const connected)"

.PP
Checks if the DS18B20 is connected to the 1-wire bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP DS18B20 device handle\&. 
.br
\fIconnected\fP DS18B20 is connected when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ds18b20_delete (\fBds18b20_handle_t\fP handle)"

.PP
Removes an DS18B20 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP DS18B20 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ds18b20_detect (\fBonewire_bus_handle_t\fP owb_handle, \fBonewire_device_t\fP *const devices, const uint8_t device_size, uint8_t *const device_count)"

.PP
Detects up to 10 DS18B20 devices on the 1-wire bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIowb_handle\fP 1-wire bus handle\&. 
.br
\fIdevices\fP Array of DS18B20 devices detected on the 1-wire bus\&. 
.br
\fIdevice_size\fP Size of DS18B20 devices array\&. The maximum number of detectable DS18B20 devices is 10\&. 
.br
\fIdevice_count\fP Number of DS18B20 devices detected\&. The maximum number of detectable DS18B20 devices is 10\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ds18b20_get_alarm_thresholds (\fBds18b20_handle_t\fP handle, int8_t *const high, int8_t *const low)"

.PP
Reads high and low temperature alarm thresholds from DS18B20\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP DS18B20 device handle\&. 
.br
\fIhigh\fP DS18B20 high temperature alarm threshold setting (-55 to 125 degrees Celsius)\&. 
.br
\fIlow\fP DS18B20 low temperature alarm threshold setting (-55 to 125 degrees Celsius)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * ds18b20_get_fw_version (void )"

.PP
Converts DS18B20 firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* DS18B20 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t ds18b20_get_fw_version_number (void )"

.PP
Converts DS18B20 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t DS18B20 firmware version number\&. 
.RE
.PP

.SS "esp_err_t ds18b20_get_measurement (\fBds18b20_handle_t\fP handle, float *const temperature)"

.PP
Reads temperature from DS18B20\&. 
.PP
\fBNote\fP
.RS 4
The trigger temperature conversion function must be called before reading the temperature\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP DS18B20 device handle\&. 
.br
\fItemperature\fP Temperature in degree Celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ds18b20_get_power_supply_mode (\fBds18b20_handle_t\fP handle, bool *const parasitic)"

.PP
Reads power supply mode setting from DS18B20\&. Parasitic-powered devices are powered by the data pin (DQ) and will pull the bus low during read time slot\&. Parasitic-powered devices are not supported at this time\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP DS18B20 device handle\&. 
.br
\fIparasitic\fP DS18B20 power supply mode setting is parasitic when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ds18b20_get_resolution (\fBds18b20_handle_t\fP handle, \fBds18b20_resolutions_t\fP *const resolution)"

.PP
Reads temperature conversion resolution from DS18B20\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP DS18B20 device handle\&. 
.br
\fIresolution\fP DS18B20 temperature conversion resolution setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ds18b20_get_temperature (\fBds18b20_handle_t\fP handle, float *const temperature)"

.PP
Triggers temperature conversion and reads temperature from DS18B20\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP DS18B20 device handle\&. 
.br
\fItemperature\fP Temperature in degree Celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ds18b20_init (\fBonewire_device_t\fP * device, const \fBds18b20_config_t\fP * ds18b20_config, \fBds18b20_handle_t\fP * ds18b20_handle)"

.PP
Initializes an DS18B20 device onto the 1-wire master bus\&. 
.PP
\fBNote\fP
.RS 4
Parasitic-powered devices are not supported at this time\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIdevice\fP 1-wire device\&. 
.br
\fIds18b20_config\fP DS18B20 device configuration\&. 
.br
\fIds18b20_handle\fP DS18B20 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ds18b20_set_alarm_thresholds (\fBds18b20_handle_t\fP handle, const int8_t high, const int8_t low)"

.PP
Writes high and low temperature alarm thresholds to DS18B20\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP DS18B20 device handle\&. 
.br
\fIhigh\fP DS18B20 high temperature alarm threshold setting (-55 to 125 degrees Celsius)\&. 
.br
\fIlow\fP DS18B20 low temperature alarm threshold setting (-55 to 125 degrees Celsius)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ds18b20_set_resolution (\fBds18b20_handle_t\fP handle, const \fBds18b20_resolutions_t\fP resolution)"

.PP
Writes temperature conversion resolution to DS18B20\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP DS18B20 device handle\&. 
.br
\fIresolution\fP DS18B20 temperature conversion resolution setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ds18b20_trigger_temperature_conversion (\fBds18b20_handle_t\fP handle)"

.PP
Triggers DS18B20 temperature conversion\&. This function must be called before reading the temperature from DS18B20\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP DS18B20 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "\fBens160_aqi_uba_row_t\fP ens160_aqi_index_to_definition (const \fBens160_aqi_uba_indexes_t\fP index)"

.PP
Decodes ENS160 air quality index to a uba definition row\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP ENS160 air quality index of the uba\&. 
.RE
.PP
\fBReturns\fP
.RS 4
i2c_ens160_aqi_uba_row_t air quality index of the uba definition row on success\&. 
.RE
.PP

.SS "esp_err_t ens160_clear_command_register (\fBens160_handle_t\fP handle)"

.PP
Resets command to operate normal and clears general purpose registers on ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_delete (\fBens160_handle_t\fP handle)"

.PP
Removes an ENS160 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_enable_deep_sleep_mode (\fBens160_handle_t\fP handle)"

.PP
Enables deep sleep operating mode to ENS160\&. 
.PP
\fBNote\fP
.RS 4
The ENS160 will not respond to commands unless it is placed in idle or operational mode\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_enable_idle_mode (\fBens160_handle_t\fP handle)"

.PP
Enables idle operating mode to ENS160 to respond to commands\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_enable_standard_mode (\fBens160_handle_t\fP handle)"

.PP
Enables standard operating mode to ENS160 to operate as a gas sensor and respond to commands\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_get_compensation_factors (\fBens160_handle_t\fP handle, float *const temperature, float *const humidity)"

.PP
Reads temperature and humidity compensation factors from ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fItemperature\fP ENS160 temperature compensation in degrees celsius\&. 
.br
\fIhumidity\fP ENS160 humidity compensation in percentage\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_get_compensation_registers (\fBens160_handle_t\fP handle, float *const temperature, float *const humidity)"

.PP
Reads temperature and humidity compensation registers from ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fItemperature\fP temperature compensation in degree Celsius\&. 
.br
\fIhumidity\fP humidity compensation in percentage\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_get_data_status (\fBens160_handle_t\fP handle, bool *const ready)"

.PP
Reads data ready status from ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fIready\fP ENS160 data ready status\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_get_error_status (\fBens160_handle_t\fP handle, bool *const error)"

.PP
Read error status from ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fIerror\fP ENS160 error status, true indicates an error\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * ens160_get_fw_version (void )"

.PP
Converts ENS160 firmware version numbers (major, minor, patch, build) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* ENS160 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t ens160_get_fw_version_number (void )"

.PP
Converts ENS160 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t ENS160 firmware version number\&. 
.RE
.PP

.SS "esp_err_t ens160_get_gpr_data_status (\fBens160_handle_t\fP handle, bool *const ready)"

.PP
Reads general purpose registers data ready status from ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fIready\fP ENS160 general purpose registers data ready status\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_get_interrupt_config_register (\fBens160_handle_t\fP handle, ens160_interrupt_config_register_t *const reg)"

.PP
Reads interrupt configuration register from ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fIreg\fP ENS160 interrupt configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_get_measurement (\fBens160_handle_t\fP handle, \fBens160_air_quality_data_t\fP *const data)"

.PP
Reads calculated air quality measurements from ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fIdata\fP ENS160 air quality data structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_get_mode_status (\fBens160_handle_t\fP handle, bool *const mode)"

.PP
Read operating mode status from ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fImode\fP ENS160 operating mode status, true indicates an operating mode is running\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_get_part_id_register (\fBens160_handle_t\fP handle, uint16_t *const reg)"

.PP
Reads part identifier register from ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fIreg\fP Part id register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_get_raw_measurement (\fBens160_handle_t\fP handle, \fBens160_air_quality_raw_data_t\fP *const data)"

.PP
Reads raw air quality measurements from ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fIdata\fP ENS160 air quality raw data structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_get_status (\fBens160_handle_t\fP handle, bool *const data_ready, bool *const gpr_data_ready, \fBens160_validity_flags_t\fP *const state, bool *const error, bool *const mode)"

.PP
Reads data ready, general purpose registers data ready, validity flag, and error status from ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fIdata_ready\fP ENS160 data ready status\&. 
.br
\fIgpr_data_ready\fP ENS160 general purpose registers data ready status\&. 
.br
\fIstate\fP ENS160 validity flag status\&. 
.br
\fIerror\fP ENS160 error status\&. 
.br
\fImode\fP ENS160 operating mode status\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_get_status_register (\fBens160_handle_t\fP handle, ens160_status_register_t *const reg)"

.PP
Reads status register from ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fIreg\fP ENS160 status configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_get_validity_status (\fBens160_handle_t\fP handle, \fBens160_validity_flags_t\fP *const state)"

.PP
Read validity flag status, device status and signal rating, from ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fIstate\fP ENS160 validity flag status\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_init (i2c_master_bus_handle_t master_handle, const \fBens160_config_t\fP * ens160_config, \fBens160_handle_t\fP * ens160_handle)"

.PP
Initializes an ENS160 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIens160_config\fP ENS160 device configuration\&. 
.br
\fIens160_handle\fP ENS160 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_remove (\fBens160_handle_t\fP handle)"

.PP
Removes an ENS160 device from master I2C bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_reset (\fBens160_handle_t\fP handle)"

.PP
Issues soft-reset and initializes ENS160 to idle mode\&. 
.PP
\fBNote\fP
.RS 4
ENS160 I2C device handle registers are initialized\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_set_compensation_factors (\fBens160_handle_t\fP handle, const float temperature, const float humidity)"

.PP
Writes temperature and humidity compensation factors to ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fItemperature\fP ENS160 temperature compensation in degrees celsius\&. 
.br
\fIhumidity\fP ENS160 humidity compensation in percentage\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_set_compensation_registers (\fBens160_handle_t\fP handle, const float temperature, const float humidity)"

.PP
Writes temperature and humidity compensation registers to ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fItemperature\fP temperature compensation in degree Celsius\&. 
.br
\fIhumidity\fP humidity compensation in percentage\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ens160_set_interrupt_config_register (\fBens160_handle_t\fP handle, const ens160_interrupt_config_register_t reg)"

.PP
Writes interrupt configuration register to ENS160\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP ENS160 device handle\&. 
.br
\fIreg\fP ENS160 interrupt configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_delete (\fBhdc1080_handle_t\fP handle)"

.PP
Removes an HDC1080 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_disable_heater (\fBhdc1080_handle_t\fP handle)"

.PP
Disables HDC1080 heater\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_enable_heater (\fBhdc1080_handle_t\fP handle)"

.PP
Enables HDC1080 heater\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_get_configuration_register (\fBhdc1080_handle_t\fP handle, hdc1080_configuration_register_t *const reg)"

.PP
Reads configuration register from HDC1080\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.br
\fIreg\fP HDC1080 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_get_device_id_register (\fBhdc1080_handle_t\fP handle, uint16_t *const reg)"

.PP
Reads device identifier register from HDC1080\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.br
\fIreg\fP HDC1080 device identifier register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * hdc1080_get_fw_version (void )"

.PP
Converts HDC1080 firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* HDC1080 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t hdc1080_get_fw_version_number (void )"

.PP
Converts HDC1080 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t HDC1080 firmware version number\&. 
.RE
.PP

.SS "esp_err_t hdc1080_get_humidity_resolution (\fBhdc1080_handle_t\fP handle, \fBhdc1080_humidity_resolutions_t\fP *const resolution)"

.PP
Reads relative humidity measurement resolution from HDC1080\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.br
\fIresolution\fP HDC1080 relative humidity measurement resolution setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_get_manufacturer_id_register (\fBhdc1080_handle_t\fP handle, uint16_t *const reg)"

.PP
Reads manufacturer identifier register from HDC1080\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.br
\fIreg\fP HDC1080 manufacturer identifier register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_get_measurement (\fBhdc1080_handle_t\fP handle, float *const temperature, float *const humidity)"

.PP
Reads temperature and relative humidity from HDC1080\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.br
\fItemperature\fP Temperature measurement in degrees Celsius\&. 
.br
\fIhumidity\fP Relative humidity measurement in percentage\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_get_measurements (\fBhdc1080_handle_t\fP handle, float *const temperature, float *const humidity, float *const dewpoint)"

.PP
Reads temperature, relative humidity, and dew-point from HDC1080\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.br
\fItemperature\fP Temperature measurement in degrees Celsius\&. 
.br
\fIhumidity\fP Relative humidity measurement in percentage\&. 
.br
\fIdewpoint\fP Calculated dewpoint in degrees Celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_get_serial_number_register (\fBhdc1080_handle_t\fP handle, uint64_t *const reg)"

.PP
Reads unique serial number register from HDC1080\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.br
\fIreg\fP HDC1080 serial number register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_get_temperature_resolution (\fBhdc1080_handle_t\fP handle, \fBhdc1080_temperature_resolutions_t\fP *const resolution)"

.PP
Reads temperature measurement resolution from HDC1080\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.br
\fIresolution\fP HDC1080 temperature measurement resolution setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_init (i2c_master_bus_handle_t master_handle, const \fBhdc1080_config_t\fP * hdc1080_config, \fBhdc1080_handle_t\fP * hdc1080_handle)"

.PP
Initializes an HDC1080 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIhdc1080_config\fP HDC1080 device configuration\&. 
.br
\fIhdc1080_handle\fP HDC1080 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_remove (\fBhdc1080_handle_t\fP handle)"

.PP
Removes an HDC1080 device from master I2C bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_reset (\fBhdc1080_handle_t\fP handle)"

.PP
Issues soft-reset to HDC1080\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_set_configuration_register (\fBhdc1080_handle_t\fP handle, const hdc1080_configuration_register_t reg)"

.PP
Writes configuration register to HDC1080\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.br
\fIreg\fP HDC1080 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_set_humidity_resolution (\fBhdc1080_handle_t\fP handle, const \fBhdc1080_humidity_resolutions_t\fP resolution)"

.PP
Writes relative humidity measurement resolution to HDC1080\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.br
\fIresolution\fP HDC1080 relative humidity measurement resolution setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hdc1080_set_temperature_resolution (\fBhdc1080_handle_t\fP handle, const \fBhdc1080_temperature_resolutions_t\fP resolution)"

.PP
Writes temperature measurement resolution to HDC1080\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HDC1080 device handle\&. 
.br
\fIresolution\fP HDC1080 temperature measurement resolution setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_delete (\fBhmc5883l_handle_t\fP handle)"

.PP
Removes an HMC5883L device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_get_bias (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_biases_t\fP *const bias)"

.PP
Reads measurement mode bias setting from HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIbias\fP HMC5883L measurement mode bias setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_get_configuration1_register (\fBhmc5883l_handle_t\fP handle, hmc5883l_configuration1_register_t *const reg)"

.PP
Reads configuration 1 register from HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIreg\fP HMC5883L configuration 1 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_get_configuration2_register (\fBhmc5883l_handle_t\fP handle, hmc5883l_configuration2_register_t *const reg)"

.PP
Reads configuration 2 register from HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIreg\fP HMC5883L configuration 2 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_get_data_rate (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_data_rates_t\fP *const rate)"

.PP
Reads data rate setting from HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIrate\fP HMC5883L data rate setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_get_data_status (\fBhmc5883l_handle_t\fP handle, bool *const ready, bool *const locked)"

.PP
Reads data status from HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIready\fP HMC5883L data is ready\&. 
.br
\fIlocked\fP HMC5883L data is locked\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_get_fixed_magnetic_axes (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_axes_data_t\fP *const axes_data)"

.PP
Reads uncompensated axes measurements from HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIaxes_data\fP Uncompensated axes measurements (x, y, and z axes)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * hmc5883l_get_fw_version (void )"

.PP
Converts HMC5883L firmware version numbers (major, minor, patch, build) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* HMC5883L firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t hmc5883l_get_fw_version_number (void )"

.PP
Converts HMC5883L firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t HMC5883L firmware version number\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_get_gain (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_gains_t\fP *const gain)"

.PP
Reads gain setting from HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIgain\fP HMC5883L gain setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_get_gain_sensitivity (\fBhmc5883l_handle_t\fP handle, float *const sensitivity)"

.PP
Reads gain sensitivity setting from HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIsensitivity\fP HMC5883L gain sensitivity setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_get_magnetic_axes (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_magnetic_axes_data_t\fP *const axes_data)"

.PP
Reads compensated magnetic axes measurements from HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIaxes_data\fP Compensated magnetic axes measurements (x, y, and z axes)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_get_mode (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_modes_t\fP *const mode)"

.PP
Reads operating mode setting from HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fImode\fP HMC5883L operating mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_get_mode_register (\fBhmc5883l_handle_t\fP handle, hmc5883l_mode_register_t *const reg)"

.PP
Reads mode register from HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIreg\fP HMC5883L mode register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_get_samples_averaged (\fBhmc5883l_handle_t\fP handle, \fBhmc5883l_sample_averages_t\fP *const sample)"

.PP
Reads samples averaged setting from HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIsample\fP HMC5883L samples averaged setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_get_status_register (\fBhmc5883l_handle_t\fP handle, hmc5883l_status_register_t *const reg)"

.PP
Reads status register from HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIreg\fP HMC5883L status register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_init (i2c_master_bus_handle_t master_handle, const \fBhmc5883l_config_t\fP * hmc5883l_config, \fBhmc5883l_handle_t\fP * hmc5883l_handle)"

.PP
Initializes an HMC5883L device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIhmc5883l_config\fP HMC5883L device configuration\&. 
.br
\fIhmc5883l_handle\fP HMC5883L device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_remove (\fBhmc5883l_handle_t\fP handle)"

.PP
Removes an HMC5883L device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_set_bias (\fBhmc5883l_handle_t\fP handle, const \fBhmc5883l_biases_t\fP bias)"

.PP
Writes measurement mode bias setting to HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIbias\fP HMC5883L measurement mode bias setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_set_configuration1_register (\fBhmc5883l_handle_t\fP handle, const hmc5883l_configuration1_register_t reg)"

.PP
Writes configuration 1 register to HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIreg\fP HMC5883L configuration 1 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_set_configuration2_register (\fBhmc5883l_handle_t\fP handle, const hmc5883l_configuration2_register_t reg)"

.PP
Writes configuration 2 register to HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIreg\fP HMC5883L configuration 2 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_set_data_rate (\fBhmc5883l_handle_t\fP handle, const \fBhmc5883l_data_rates_t\fP rate)"

.PP
Writes data rate setting to HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIrate\fP HMC5883L data rate setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_set_gain (\fBhmc5883l_handle_t\fP handle, const \fBhmc5883l_gains_t\fP gain)"

.PP
Writes gain setting to HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIgain\fP HMC5883L gain setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_set_mode (\fBhmc5883l_handle_t\fP handle, const \fBhmc5883l_modes_t\fP mode)"

.PP
Writes operating mode setting to HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fImode\fP HMC5883L operating mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_set_mode_register (\fBhmc5883l_handle_t\fP handle, const hmc5883l_mode_register_t reg)"

.PP
Writes mode register to HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIreg\fP HMC5883L mode register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t hmc5883l_set_samples_averaged (\fBhmc5883l_handle_t\fP handle, const \fBhmc5883l_sample_averages_t\fP sample)"

.PP
Writes samples averaged setting to HMC5883L\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP HMC5883L device handle\&. 
.br
\fIsample\fP HMC5883L samples averaged setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_calibrate (\fBina226_handle_t\fP handle, const float max_current, const float shunt_resistance)"

.PP
Calibrates the INA266\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle 
.br
\fImax_current\fP Maximum expected current, A 
.br
\fIshunt_resistance\fP Shunt resistance, Ohm 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_delete (\fBina226_handle_t\fP handle)"

.PP
Removes an INA226 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_get_bus_voltage (\fBina226_handle_t\fP handle, float *const voltage)"

.PP
Reads bus voltage (V) from INA226\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle\&. 
.br
\fIvoltage\fP INA226 bus voltage, V\&. 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_get_calibration_register (\fBina226_handle_t\fP handle, uint16_t *const reg)"

.PP
Reads the calibration register from the INA226\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle\&. 
.br
\fIreg\fP INA226 calibration register 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_get_configuration_register (\fBina226_handle_t\fP handle, ina226_config_register_t *const reg)"

.PP
Reads the configuration register from the INA226\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle\&. 
.br
\fIreg\fP INA226 configuration register 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_get_current (\fBina226_handle_t\fP handle, float *const current)"

.PP
Reads current (A) from INA226\&. 
.PP
\fBNote\fP
.RS 4
This function works properly only after calibration\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle\&. 
.br
\fIcurrent\fP INA226 current, A\&. 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "const char * ina226_get_fw_version (void )"

.PP
Converts INA226 firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* INA226 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t ina226_get_fw_version_number (void )"

.PP
Converts INA226 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t INA226 firmware version number\&. 
.RE
.PP

.SS "esp_err_t ina226_get_mask_enable_register (\fBina226_handle_t\fP handle, ina226_mask_enable_register_t *const reg)"

.PP
Reads the mask/enable register from the INA226\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle\&. 
.br
\fIreg\fP INA226 mask/enable register 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_get_operating_mode (\fBina226_handle_t\fP handle, \fBina226_operating_modes_t\fP *const mode)"

.PP
Reads operating mode from the INA226\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle 
.br
\fImode\fP Operating mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_get_power (\fBina226_handle_t\fP handle, float *const power)"

.PP
Reads power (W) from INA226\&. 
.PP
\fBNote\fP
.RS 4
This function works properly only after calibration\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle\&. 
.br
\fIpower\fP INA226 power, W\&. 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_get_shunt_voltage (\fBina226_handle_t\fP handle, float *const voltage)"

.PP
Reads shunt voltage (V) from INA226\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle\&. 
.br
\fIvoltage\fP INA226 shunt voltage, V\&. 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_get_triggered_bus_voltage (\fBina226_handle_t\fP handle, float *const voltage)"

.PP
Triggers and reads bus voltage (V) from INA226\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle\&. 
.br
\fIvoltage\fP INA226 bus voltage, V\&. 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_get_triggered_current (\fBina226_handle_t\fP handle, float *const current)"

.PP
Triggers and reads current (A) from INA226\&. 
.PP
\fBNote\fP
.RS 4
This function works properly only after calibration\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle\&. 
.br
\fIcurrent\fP INA226 current, A\&. 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_get_triggered_shunt_voltage (\fBina226_handle_t\fP handle, float *const voltage)"

.PP
Triggers and reads shunt voltage (V) from INA226\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle\&. 
.br
\fIvoltage\fP INA226 shunt voltage, V\&. 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_init (i2c_master_bus_handle_t master_handle, const \fBina226_config_t\fP * ina226_config, \fBina226_handle_t\fP * ina226_handle)"

.PP
initializes an INA226 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIina226_config\fP INA226 device configuration\&. 
.br
\fIina226_handle\fP INA226 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_remove (\fBina226_handle_t\fP handle)"

.PP
Removes an INA226 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_reset (\fBina226_handle_t\fP handle)"

.PP
Resets the INA226\&. Same as power-on reset\&. Resets all registers to default values\&. Calibration is conducted automatically after reset\&.

.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_set_calibration_register (\fBina226_handle_t\fP handle, const uint16_t reg)"

.PP
Writes the calibration register to the INA226\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle\&. 
.br
\fIreg\fP INA226 calibration register 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_set_configuration_register (\fBina226_handle_t\fP handle, const ina226_config_register_t reg)"

.PP
Writes the configuration register to the INA226\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle\&. 
.br
\fIreg\fP INA226 configuration register 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ina226_set_operating_mode (\fBina226_handle_t\fP handle, const \fBina226_operating_modes_t\fP mode)"

.PP
Writes operating mode to the INA226\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP INA226 device handle 
.br
\fImode\fP Operating mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_delete (\fBltr390uv_handle_t\fP handle)"

.PP
Removes an LTR390UV device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_disable (\fBltr390uv_handle_t\fP handle)"

.PP
Places LTR390UV on standby (default)\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_disable_interrupt (\fBltr390uv_handle_t\fP handle)"

.PP
Disables LTR390UV interrupts\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_enable (\fBltr390uv_handle_t\fP handle)"

.PP
Activates LTR390UV for measurements\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_enable_interrupt (\fBltr390uv_handle_t\fP handle, const \fBltr390uv_ls_interrupts_t\fP light_source)"

.PP
Enables LTR390UV interrupts\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIlight_source\fP LTR390UV interrupt light source (e\&.g\&. ALS or UVS)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_als (\fBltr390uv_handle_t\fP handle, uint32_t *const sensor_counts)"

.PP
Reads ALS sensor counts from LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIsensor_counts\fP Light\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_ambient_light (\fBltr390uv_handle_t\fP handle, float *const ambient_light)"

.PP
Reads ambient light from LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIambient_light\fP Ambient light in lux\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_control_register (\fBltr390uv_handle_t\fP handle, ltr390uv_control_register_t *const reg)"

.PP
Reads control register from LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIreg\fP LTR390UV control register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_data_status (\fBltr390uv_handle_t\fP handle, bool *const ready)"

.PP
Reads data ready status flag from LTR390UV\&. This flag is cleared after the register is read\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIready\fP LTR390UV data is new and ready to read when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * ltr390uv_get_fw_version (void )"

.PP
Converts LTR390UV firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* LTR390UV firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t ltr390uv_get_fw_version_number (void )"

.PP
Converts LTR390UV firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t LTR390UV firmware version number\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_gain (\fBltr390uv_handle_t\fP handle, \fBltr390uv_measurement_gains_t\fP *const gain)"

.PP
Reads measurement gain from LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIgain\fP LTR390UV measurement gain setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_gain_register (\fBltr390uv_handle_t\fP handle, ltr390uv_gain_register_t *const reg)"

.PP
Reads ALS UVS gain register from LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIreg\fP LTR390UV ALS UVS gain register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_interrupt_config_register (\fBltr390uv_handle_t\fP handle, ltr390uv_interrupt_config_register_t *const reg)"

.PP
Reads interrupt configuration register from LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIreg\fP LTR390UV interrupt configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_interrupt_status (\fBltr390uv_handle_t\fP handle, bool *const interrupt)"

.PP
Reads interrupt status flag from LTR390UV\&. This flag is cleared after the register is read\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIinterrupt\fP LTR390UV interrupt is active when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_measure_register (\fBltr390uv_handle_t\fP handle, ltr390uv_measure_register_t *const reg)"

.PP
Reads ALS UVS measure register from LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIreg\fP LTR390UV ALS UVS measure register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_mode (\fBltr390uv_handle_t\fP handle, \fBltr390uv_operation_modes_t\fP *const mode)"

.PP
Reads operation mode from LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fImode\fP LTR390UV operation mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_power_status (\fBltr390uv_handle_t\fP handle, bool *const power_on)"

.PP
Reads power status flag from LTR390UV\&. This flag is cleared after the register is read\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIpower_on\fP LTR390UV is power on event when true and all interrupt threshold settings in the registers have been reset to power on default state\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_rate (\fBltr390uv_handle_t\fP handle, \fBltr390uv_measurement_rates_t\fP *const rate)"

.PP
Reads measurement rate from LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIrate\fP LTR390UV measurement rate setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_resolution (\fBltr390uv_handle_t\fP handle, \fBltr390uv_sensor_resolutions_t\fP *const resolution)"

.PP
Reads sensor resolution from LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIresolution\fP LTR390UV sensor resolution setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_status (\fBltr390uv_handle_t\fP handle, bool *const data_ready, bool *const power_on, bool *const interrupt)"

.PP
Reads interrupt status flags from LTR390UV\&. The flags are cleared after the register is read\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIdata_ready\fP LTR390UV data is new and ready to read when true\&. 
.br
\fIpower_on\fP LTR390UV is power on event when true and all interrupt threshold settings in the registers have been reset to power on default state\&. 
.br
\fIinterrupt\fP LTR390UV interrupt is active when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_status_register (\fBltr390uv_handle_t\fP handle, ltr390uv_status_register_t *const reg)"

.PP
Reads status register from LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_thresholds (\fBltr390uv_handle_t\fP handle, uint32_t *const lower_threshold, uint32_t *const upper_threshold)"

.PP
Reads UVS/ALS lower and upper thresholds from LTR390UV\&. The thresholds are used to trigger an interrupt when the light level exceeds the upper threshold or falls below the lower threshold\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIlower_threshold\fP LTR390UV lower threshold in lux or mW/cm^2 setting\&. 
.br
\fIupper_threshold\fP LTR390UV upper threshold in lux or mW/cm^2 setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_ultraviolet_index (\fBltr390uv_handle_t\fP handle, float *const ultraviolet_index)"

.PP
Reads ultraviolet index (UVI) from LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIultraviolet_index\fP Ultraviolet index (UVI)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_get_uvs (\fBltr390uv_handle_t\fP handle, uint32_t *const sensor_counts)"

.PP
Reads UVS sensor counts from LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIsensor_counts\fP Ultraviolet light in mW/cm^2\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_init (i2c_master_bus_handle_t master_handle, const \fBltr390uv_config_t\fP * ltr390uv_config, \fBltr390uv_handle_t\fP * ltr390uv_handle)"

.PP
Initializes an LTR390UV device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIltr390uv_config\fP Configuration of LTR390UV device\&. 
.br
\fIltr390uv_handle\fP LTR390UV device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_remove (\fBltr390uv_handle_t\fP handle)"

.PP
Removes an LTR390UV device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_reset (\fBltr390uv_handle_t\fP handle)"

.PP
Issues soft-reset and initializes LTR390UV\&. See datasheet for details\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_set_control_register (\fBltr390uv_handle_t\fP handle, const ltr390uv_control_register_t reg)"

.PP
Writes control register to LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIreg\fP LTR390UV control register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_set_gain (\fBltr390uv_handle_t\fP handle, const \fBltr390uv_measurement_gains_t\fP gain)"

.PP
Writes measurement gain to LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIgain\fP LTR390UV measurement gain setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_set_gain_register (\fBltr390uv_handle_t\fP handle, const ltr390uv_gain_register_t reg)"

.PP
Writes ALS UVS gain register to LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIreg\fP LTR390UV ALS UVS gain register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_set_interrupt_config_register (\fBltr390uv_handle_t\fP handle, const ltr390uv_interrupt_config_register_t reg)"

.PP
Writes interrupt configuration register to LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIreg\fP LTR390UV interrupt configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_set_measure_register (\fBltr390uv_handle_t\fP handle, const ltr390uv_measure_register_t reg)"

.PP
Writes ALS UVS measure register to LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIreg\fP LTR390UV ALS UVS measure register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_set_mode (\fBltr390uv_handle_t\fP handle, const \fBltr390uv_operation_modes_t\fP mode)"

.PP
Writes operation mode to LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fImode\fP LTR390UV operation mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_set_rate (\fBltr390uv_handle_t\fP handle, const \fBltr390uv_measurement_rates_t\fP rate)"

.PP
Writes measurement rate to LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIrate\fP LTR390UV measurement rate setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_set_resolution (\fBltr390uv_handle_t\fP handle, const \fBltr390uv_sensor_resolutions_t\fP resolution)"

.PP
Writes sensor resolution to LTR390UV\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIresolution\fP LTR390UV sensor resolution setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ltr390uv_set_thresholds (\fBltr390uv_handle_t\fP handle, const uint32_t lower_threshold, const uint32_t upper_threshold)"

.PP
Writes UVS/ALS lower and upper thresholds to LTR390UV\&. The thresholds are used to trigger an interrupt when the light level exceeds the upper threshold or falls below the lower threshold\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP LTR390UV device handle\&. 
.br
\fIlower_threshold\fP Lower threshold in lux or mW/cm^2 setting\&. 
.br
\fIupper_threshold\fP Upper threshold in lux or mW/cm^2 setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_delete (\fBmax30105_handle_t\fP handle)"

.PP
Removes an MAX30105 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_get_control_mode (\fBmax30105_handle_t\fP handle, \fBmax30105_control_modes_t\fP *const control_mode)"

.PP
Reads control mode setting from MAX30105\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.br
\fIcontrol_mode\fP MAX30105 control mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_get_data_status (\fBmax30105_handle_t\fP handle, bool *const ready)"

.PP
Reads data status from MAX30105\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.br
\fIready\fP MAX30105 data is ready when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * max30105_get_fw_version (void )"

.PP
Converts MAX30105 firmware version numbers (major, minor, patch, build) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* MAX30105 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t max30105_get_fw_version_number (void )"

.PP
Converts MAX30105 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t MAX30105 firmware version number\&. 
.RE
.PP

.SS "esp_err_t max30105_get_interrupt_enable1_register (\fBmax30105_handle_t\fP handle, max30105_interrupt_enable1_register_t *const reg)"

.PP
Reads interrupt enable 1 register from MAX30105\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_get_interrupt_enable2_register (\fBmax30105_handle_t\fP handle, max30105_interrupt_enable2_register_t *const reg)"

.PP
Reads interrupt enable 2 register from MAX30105\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_get_interrupt_status1_register (\fBmax30105_handle_t\fP handle, max30105_interrupt_status1_register_t *const reg)"

.PP
Reads interrupt status 1 register from MAX30105\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_get_interrupt_status2_register (\fBmax30105_handle_t\fP handle, max30105_interrupt_status2_register_t *const reg)"

.PP
Reads interrupt status 2 register from MAX30105\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_get_mode_configuration_register (\fBmax30105_handle_t\fP handle, max30105_mode_configuration_register_t *const reg)"

.PP
Reads mode configuration register from MAX30105\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_get_optical_counts (\fBmax30105_handle_t\fP handle, float *const red_count, float *const ir_count, float *const green_count)"

.PP
Reads red, IR, and green LED ADC counts from MAX30105\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.br
\fIred_count\fP Red LED ADC count\&. 
.br
\fIir_count\fP IR LED ADC count\&. 
.br
\fIgreen_count\fP Green LED ADC count\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_init (i2c_master_bus_handle_t master_handle, const \fBmax30105_config_t\fP * max30105_config, \fBmax30105_handle_t\fP * max30105_handle)"

.PP
Initializes an MAX30105 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fImax30105_config\fP MAX30105 device configuration\&. 
.br
\fImax30105_handle\fP MAX30105 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_remove (\fBmax30105_handle_t\fP handle)"

.PP
Removes an MAX30105 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_set_control_mode (\fBmax30105_handle_t\fP handle, const \fBmax30105_control_modes_t\fP control_mode)"

.PP
Writes control mode setting to MAX30105\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.br
\fIcontrol_mode\fP MAX30105 control mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_set_interrupt_enable1_register (\fBmax30105_handle_t\fP handle, const max30105_interrupt_enable1_register_t reg)"

.PP
Writes interrupt enable 1 register to MAX30105\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.br
\fIreg\fP Interrupt enable 1 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_set_interrupt_enable2_register (\fBmax30105_handle_t\fP handle, const max30105_interrupt_enable2_register_t reg)"

.PP
Writes interrupt enable 2 register to MAX30105\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.br
\fIreg\fP Interrupt enable 2 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t max30105_set_mode_configuration_register (\fBmax30105_handle_t\fP handle, const max30105_mode_configuration_register_t reg)"

.PP
Writes mode configuration register to MAX30105\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MAX30105 device handle\&. 
.br
\fIreg\fP Mode configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_delete (\fBmlx90614_handle_t\fP handle)"

.PP
Removes an MLX90614 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_address (\fBmlx90614_handle_t\fP handle, uint8_t *const address)"

.PP
Reads I2C address setting from MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIaddress\fP MLX90614 I2C address setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_ambient_temperature (\fBmlx90614_handle_t\fP handle, float *const ambient_temperature)"

.PP
Reads the ambient temperature from MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIambient_temperature\fP Ambient temperature in degrees celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_ambient_temperature_range (\fBmlx90614_handle_t\fP handle, float *const ambient_temperature_range)"

.PP
Reads ambient temperature range from MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIambient_temperature_range\fP Ambient temperature range\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_config_register (\fBmlx90614_handle_t\fP handle, mlx90614_config_register_t *const reg)"

.PP
Reads configuration register from MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIreg\fP MLX90614 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_emissivity (\fBmlx90614_handle_t\fP handle, float *const coefficient)"

.PP
Reads emissivity coefficient (0\&.1 to 1\&.0) setting from MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIemissivity\fP MLX90614 emissivity coefficient (0\&.1 to 1\&.0) setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_flags_register (\fBmlx90614_handle_t\fP handle, mlx90614_flags_register_t *const reg)"

.PP
Reads flags register from MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIreg\fP MLX90614 flags register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * mlx90614_get_fw_version (void )"

.PP
Converts MLX90614 firmware version numbers (major, minor, patch, build) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* MLX90614 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t mlx90614_get_fw_version_number (void )"

.PP
Converts MLX90614 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t MLX90614 firmware version number\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_ir_channel1 (\fBmlx90614_handle_t\fP handle, int16_t *const ir_channel1)"

.PP
Reads IR channel 1 from MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIir_channel1\fP IR channel 1\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_ir_channel2 (\fBmlx90614_handle_t\fP handle, int16_t *const ir_channel2)"

.PP
Reads IR channel 2 from MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIir_channel1\fP IR channel 2\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_object1_temperature (\fBmlx90614_handle_t\fP handle, float *const object1_temperature)"

.PP
Reads object 1 temperature from mlx90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIobject1_temperature\fP Object 1 temperature in degrees celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_object2_temperature (\fBmlx90614_handle_t\fP handle, float *const object2_temperature)"

.PP
Reads object 2 temperature from MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIobject2_temperature\fP Object 2 temperature in degrees celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_object_maximum_temperature (\fBmlx90614_handle_t\fP handle, float *const temperature)"

.PP
Reads maximum object temperature setting from MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fItemperature\fP MLX90614 maximum object temperature setting in degrees Celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_object_minimum_temperature (\fBmlx90614_handle_t\fP handle, float *const temperature)"

.PP
Reads minimum object temperature setting from MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fItemperature\fP MLX90614 minimum object temperature setting in degrees Celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_pwmctrl_register (\fBmlx90614_handle_t\fP handle, mlx90614_pwmctrl_register_t *const reg)"

.PP
Reads PWM control register from MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIreg\fP MLX90614 PWM control register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_get_temperatures (\fBmlx90614_handle_t\fP handle, float *const ambient_temperature, float *const object1_temperature, float *const object2_temperature)"

.PP
Reads all three temperatures (ambient, object 1 and object 2) from the MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIambient_temperature\fP Ambient temperature in degrees celsius\&. 
.br
\fIobject1_temperature\fP Object 1 temperature in degrees celsius\&. 
.br
\fIobject2_temperature\fP Object 2 temperature in degrees celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_init (i2c_master_bus_handle_t master_handle, const \fBmlx90614_config_t\fP * mlx90614_config, \fBmlx90614_handle_t\fP * mlx90614_handle)"

.PP
Initializes an MLX90614 device onto the master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fImlx90614_config\fP MLX90614 device configuration\&. 
.br
\fImlx90614_handle\fP MLX90614 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_remove (\fBmlx90614_handle_t\fP handle)"

.PP
Removes an MLX90614 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_set_address (\fBmlx90614_handle_t\fP handle, const uint8_t address)"

.PP
Writes I2C address setting to MLX90614\&. 
.PP
\fBNote\fP
.RS 4
MLX90614 device handle must be reinitialized when I2C address is changed\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIaddress\fP MLX90614 I2C address setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_set_config_register (\fBmlx90614_handle_t\fP handle, const mlx90614_config_register_t reg)"

.PP
Writes configuration register to MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIreg\fP MLX90614 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_set_emissivity (\fBmlx90614_handle_t\fP handle, const float coefficient)"

.PP
Writes emissivity coefficient (0\&.1 to 1\&.0) setting to MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIemissivity\fP MLX90614 emissivity coefficient (0\&.1 to 1\&.0) setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_set_object_maximum_temperature (\fBmlx90614_handle_t\fP handle, const float temperature)"

.PP
Writes maximum object temperature setting to MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fItemperature\fP MLX90614 maximum object temperature setting in degrees Celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_set_object_minimum_temperature (\fBmlx90614_handle_t\fP handle, const float temperature)"

.PP
Writes minimum object temperature setting to MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fItemperature\fP MLX90614 minimum object temperature setting in degrees Celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_set_pwmctrl_register (\fBmlx90614_handle_t\fP handle, const mlx90614_pwmctrl_register_t reg)"

.PP
Writes PWM control register to MLX90614\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.br
\fIreg\fP MLX90614 PWM control register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_sleep (\fBmlx90614_handle_t\fP handle)"

.PP
Puts the MLX90614 into sleep mode\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mlx90614_wakeup (\fBmlx90614_handle_t\fP handle)"

.PP
Wakes-up the MLX90614 from sleep mode\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MLX90614 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "float mmc56x3_convert_to_heading (const \fBmmc56x3_magnetic_axes_data_t\fP axes_data)"

.PP
Converts magnetic axes data to a heading\&. See Honeywell application note AN-203 for details\&. 
.PP
\fBParameters\fP
.RS 4
\fIaxes_data\fP MMC56X3 magnetic axes data\&. 
.RE
.PP
\fBReturns\fP
.RS 4
float Heading in degrees\&. 
.RE
.PP

.SS "float mmc56x3_convert_to_true_heading (const float declination, const \fBmmc56x3_magnetic_axes_data_t\fP axes_data)"

.PP
Converts magnetic axes data with magnetic declination to a true heading\&. See Honeywell application note AN-203 for details\&. 
.PP
\fBParameters\fP
.RS 4
\fIdeclination\fP MMC56X3 magnetic declination angle in degrees (http://www.magnetic-declination.com/) setting\&. 
.br
\fIaxes_data\fP MMC56X3 magnetic axes data\&. 
.RE
.PP
\fBReturns\fP
.RS 4
float True heading in degrees\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_delete (\fBmmc56x3_handle_t\fP handle)"

.PP
Removes an MMC56X3 device from master I2C bus and delete the handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_disable_periodical_set (\fBmmc56x3_handle_t\fP handle)"

.PP
Disables MMC56X3 periodical set\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_enable_periodical_set (\fBmmc56x3_handle_t\fP handle, const \fBmmc56x3_measurement_samples_t\fP samples)"

.PP
Enables MMC56X3 periodical set when the number of samples threshold is met\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIsamples\fP MMC56X3 measurement samples setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_get_data_status (\fBmmc56x3_handle_t\fP handle, bool *const magnetic_ready, bool *const temperature_ready)"

.PP
Reads magnetic and temperature data status from MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fImagnetic_ready\fP Magnetic data is ready when true\&. 
.br
\fItemperature_ready\fP Temperature data is ready when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * mmc56x3_get_fw_version (void )"

.PP
Converts MMC56X3 firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* MMC56X3 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t mmc56x3_get_fw_version_number (void )"

.PP
Converts MMC56X3 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t MMC56X3 firmware version number\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_get_magnetic_axes (\fBmmc56x3_handle_t\fP handle, \fBmmc56x3_magnetic_axes_data_t\fP *const axes_data)"

.PP
Reads magnetic axes (x, y, z axes) from MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIaxes_data\fP Magnetic axes data (x, y, z axes) in mG\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_get_magnetic_data_status (\fBmmc56x3_handle_t\fP handle, bool *const ready)"

.PP
Reads magnetic data status from MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIready\fP Magnetic data is ready when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_get_product_id_register (\fBmmc56x3_handle_t\fP handle, uint8_t *const reg)"

.PP
Reads product identifier register from MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIreg\fP MMC56X3 product id register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_get_selftest_set_values (\fBmmc56x3_handle_t\fP handle, \fBmmc56x3_selftest_axes_data_t\fP *const axes_data)"

.PP
Reads self-test axes data set-values from MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIaxes_data\fP MMC56X3 axes data set-values setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_get_status_register (\fBmmc56x3_handle_t\fP handle, mmc56x3_status_register_t *const reg)"

.PP
Reads status register from MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIreg\fP MMC56X3 status register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_get_temperature (\fBmmc56x3_handle_t\fP handle, float *const temperature)"

.PP
Reads temperature from MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fItemperature\fP Temperature in degrees celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_get_temperature_data_status (\fBmmc56x3_handle_t\fP handle, bool *const ready)"

.PP
Reads temperature data status from MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIready\fP Temperature data is ready when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_init (i2c_master_bus_handle_t master_handle, const \fBmmc56x3_config_t\fP * mmc56x3_config, \fBmmc56x3_handle_t\fP * mmc56x3_handle)"

.PP
Initializes an MMC56X3 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fImmc56x3_config\fP MMC56X3 device configuration\&. 
.br
\fImmc56x3_handle\fP MMC56X3 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_magnetic_set_reset (\fBmmc56x3_handle_t\fP handle)"

.PP
Pulses large currents through the sense coils to clear any offset\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_remove (\fBmmc56x3_handle_t\fP handle)"

.PP
Removes an MMC56X3 device from master I2C bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_reset (\fBmmc56x3_handle_t\fP handle)"

.PP
Issues soft-reset to MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_set_control0_register (\fBmmc56x3_handle_t\fP handle, const mmc56x3_control0_register_t reg)"

.PP
Writes control 0 register to MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIreg\fP MMC56X3 control 0 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_set_control1_register (\fBmmc56x3_handle_t\fP handle, const mmc56x3_control1_register_t reg)"

.PP
Writes control 1 register to MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIreg\fP MMC56X3 control 1 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_set_control2_register (\fBmmc56x3_handle_t\fP handle, const mmc56x3_control2_register_t reg)"

.PP
Writes control 2 register to MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIreg\fP MMC56X3 control 2 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_set_data_rate (\fBmmc56x3_handle_t\fP handle, const uint16_t rate)"

.PP
Writes data rate to MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIrate\fP MMC56X3 data rate setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_set_measure_bandwidth (\fBmmc56x3_handle_t\fP handle, const \fBmmc56x3_measurement_times_t\fP bandwidth)"

.PP
Writes measurement bandwidth to MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIbandwith\fP MMC56X3 measurement bandwidth setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_set_measure_mode (\fBmmc56x3_handle_t\fP handle, const bool continuous)"

.PP
Writes measurement mode to MMC56X3\&. The data rate must be configured to a non-zero value before enabling continuous measurements\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIcontinuous\fP Measurement mode is continuous when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_set_selftest_set_values (\fBmmc56x3_handle_t\fP handle, const \fBmmc56x3_selftest_axes_data_t\fP axes_data)"

.PP
Writes self-test axes data set-values to MMC56X3\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIaxes_data\fP MMC56X3 axes data set-values setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mmc56x3_set_selftest_thresholds (\fBmmc56x3_handle_t\fP handle, const \fBmmc56x3_selftest_axes_data_t\fP axes_data)"

.PP
Writes axes configuration to MMC56X3 to enable or disable axes (x, y, z), axes are enabled by default\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIx_axis_disabled\fP X-axis is enabled by default, set to true to disable x-axis\&. 
.br
\fIy_axis_disabled\fP Y-axis is enabled by default, set to true to disable y-axis\&. 
.br
\fIz_axis_disabled\fP Y-axis is enabled by default, set to true to disable z-axis\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&.
.RE
.PP
Writes self-test axes data thresholds to MMC56X3\&.

.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MMC56X3 device handle\&. 
.br
\fIaxes_data\fP MMC56X3 axes data thresholds setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_configure_interrupts (\fBmpu6050_handle_t\fP handle, const \fBmpu6050_config_t\fP *const config)"

.PP
Configures interrupt pin behavior and setup target GPIO\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIconfig\fP MPU6050 device configuration\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_delete (\fBmpu6050_handle_t\fP handle)"

.PP
Removes an MPU6050 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_accel_config_register (\fBmpu6050_handle_t\fP handle, mpu6050_accel_config_register_t *const reg)"

.PP
Reads accelerometer configuration register from MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 accelerometer configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_config_register (\fBmpu6050_handle_t\fP handle, mpu6050_config_register_t *const reg)"

.PP
Reads configuration register from MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_data_status (\fBmpu6050_handle_t\fP handle, bool * ready)"

.PP
Reads interrupt status for data ready interrupt\&. 
.PP
\fBNote\fP
.RS 4
Interrupt status bits clear when read\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIready\fP Measurement data ready interrupt generated when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * mpu6050_get_fw_version (void )"

.PP
Converts MPU6050 firmware version numbers (major, minor, patch, build) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* MPU6050 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t mpu6050_get_fw_version_number (void )"

.PP
Converts MPU6050 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t MPU6050 firmware version number\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_gyro_config_register (\fBmpu6050_handle_t\fP handle, mpu6050_gyro_config_register_t *const reg)"

.PP
Reads gyroscope configuration register from MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 gyroscope configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_interrupt_enable_register (\fBmpu6050_handle_t\fP handle, mpu6050_interrupt_enable_register_t *const reg)"

.PP
Reads interrupt enable register from MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 interrupt enable register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_interrupt_pin_config_register (\fBmpu6050_handle_t\fP handle, mpu6050_interrupt_pin_config_register_t *const reg)"

.PP
Reads interrupt pin configuration register from MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 interrupt pin configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_interrupt_status_register (\fBmpu6050_handle_t\fP handle, mpu6050_interrupt_status_register_t *const reg)"

.PP
Reads interrupt status register from MPU6050\&. 
.PP
\fBNote\fP
.RS 4
Interrupt status bits clear when read\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 interrupt status register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_motion (\fBmpu6050_handle_t\fP handle, \fBmpu6050_gyro_data_axes_t\fP * gyro_data, \fBmpu6050_accel_data_axes_t\fP * accel_data, float * temperature)"

.PP
Reads gyroscope, accelerometer, and temperature measurements\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIgyro_data\fP Gyroscope data axes measurements in degrees per second\&. 
.br
\fIaccel_data\fP Accelerometer data axes measurements relative to standard gravity (g)\&. 
.br
\fItemperature\fP Temperature measurement in degrees Celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_power_management1_register (\fBmpu6050_handle_t\fP handle, mpu6050_power_management1_register_t *const reg)"

.PP
Reads power management 1 register from MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 power management 1 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_power_management2_register (\fBmpu6050_handle_t\fP handle, mpu6050_power_management2_register_t *const reg)"

.PP
Reads power management 2 register from MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 power management 2 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_sample_rate_divider_register (\fBmpu6050_handle_t\fP handle, uint8_t *const reg)"

.PP
Reads sample rate divider register from MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 sample rate divider value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_signal_path_reset_register (\fBmpu6050_handle_t\fP handle, mpu6050_signal_path_reset_register_t *const reg)"

.PP
Reads signal path reset register from MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 signal path reset register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_status (\fBmpu6050_handle_t\fP handle, bool * fifo_overflow, bool * i2c_master, bool * data_ready)"

.PP
Reads status for FIFO buffer overflow, I2C master, and data ready interrupts\&. 
.PP
\fBNote\fP
.RS 4
Interrupt status bits clear when read\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIfifo_overflow\fP FIFO buffer overflow interrupt generated when true\&. 
.br
\fIi2c_master\fP I2C master interrupt generated when true\&. 
.br
\fIdata_ready\fP Measurement data ready interrupt generated when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_user_control_register (\fBmpu6050_handle_t\fP handle, mpu6050_user_control_register_t *const reg)"

.PP
Reads user control register from MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 user control register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_get_who_am_i_register (\fBmpu6050_handle_t\fP handle, mpu6050_who_am_i_register_t *const reg)"

.PP
Reads who am i (i\&.e\&. device identifier) register from MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 who am i register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_init (i2c_master_bus_handle_t master_handle, const \fBmpu6050_config_t\fP * mpu6050_config, \fBmpu6050_handle_t\fP * mpu6050_handle)"

.PP
Initializes an MPU6050 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fImpu6050_config\fP MPU6050 device configuration\&. 
.br
\fImpu6050_handle\fP MPU6050 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_register_isr (\fBmpu6050_handle_t\fP handle, const \fBmpu6050_isr_t\fP isr)"

.PP
Registers an Interrupt Service Routine to handle MPU6050 interrupts\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIisr\fP Function to handle interrupts produced by MPU6050\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_remove (\fBmpu6050_handle_t\fP handle)"

.PP
Removes an MPU6050 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_reset (\fBmpu6050_handle_t\fP handle)"

.PP
Issues soft-reset to MPU6050 and initializes MPU6050 device handle registers\&. However, device configuration registers must be configured before reading data registers\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_set_accel_config_register (\fBmpu6050_handle_t\fP handle, const mpu6050_accel_config_register_t reg)"

.PP
Writes accelerometer configuration register to MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 accelerometer configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_set_config_register (\fBmpu6050_handle_t\fP handle, const mpu6050_config_register_t reg)"

.PP
Writes configuration register to MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_set_gyro_config_register (\fBmpu6050_handle_t\fP handle, const mpu6050_gyro_config_register_t reg)"

.PP
Writes gyroscope configuration register to MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 gyroscope configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_set_interrupt_enable_register (\fBmpu6050_handle_t\fP handle, const mpu6050_interrupt_enable_register_t reg)"

.PP
Writes interrupt enable register to MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 interrupt enable register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_set_interrupt_pin_config_register (\fBmpu6050_handle_t\fP handle, const mpu6050_interrupt_pin_config_register_t reg)"

.PP
Writes interrupt pin configuration register to MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 interrupt pin configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_set_power_management1_register (\fBmpu6050_handle_t\fP handle, const mpu6050_power_management1_register_t reg)"

.PP
Writes power management 1 register to MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 power management 1 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_set_power_management2_register (\fBmpu6050_handle_t\fP handle, const mpu6050_power_management2_register_t reg)"

.PP
Writes power management 2 register to MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 power management 2 register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_set_sample_rate_divider_register (\fBmpu6050_handle_t\fP handle, const uint8_t reg)"

.PP
Writes sample rate divider register to MPU6050\&. 
.PP
\fBNote\fP
.RS 4
The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV: 
.br
 Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV) where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled (see Register 26)\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 sample rate divider value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&.
.RE
.PP
sample rate = gyroscope output rate / (1 + sample rate divider) 8khz or 1khz 
.SS "esp_err_t mpu6050_set_signal_path_reset_register (\fBmpu6050_handle_t\fP handle, const mpu6050_signal_path_reset_register_t reg)"

.PP
Writes signal path reset register to MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 signal path reset register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t mpu6050_set_user_control_register (\fBmpu6050_handle_t\fP handle, const mpu6050_user_control_register_t reg)"

.PP
Writes user control register to MPU6050\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP MPU6050 device handle\&. 
.br
\fIreg\fP MPU6050 user control register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * nvs_ext_get_fw_version (void )"

.PP
Converts \fRnvs_ext\fP firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* \fRnvs_ext\fP firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t nvs_ext_get_fw_version_number (void )"

.PP
Converts \fRnvs_ext\fP firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t \fRnvs_ext\fP firmware version number\&. 
.RE
.PP

.SS "esp_err_t nvs_init (void )"

.PP
Initialization NVS storage\&. 
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_read_double (const char * key, double * read_value)"

.PP
Reads double typed value from NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIread_value\fP Pointer to the read value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_read_float (const char * key, float * read_value)"

.PP
Reads float typed value from NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIread_value\fP Pointer to the read value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_read_i16 (const char * key, int16_t * read_value)"

.PP
Reads int16_t typed value from NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIread_value\fP Pointer to the read value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_read_i32 (const char * key, int32_t * read_value)"

.PP
Reads int32_t typed value from NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIread_value\fP Pointer to the read value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_read_i64 (const char * key, int64_t * read_value)"

.PP
Reads int64_t typed value from NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIread_value\fP Pointer to the read value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_read_i8 (const char * key, int8_t * read_value)"

.PP
Reads int8_t typed value from NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIread_value\fP Pointer to the read value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_read_str (const char * key, char ** read_str)"

.PP
Reads string typed value from NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIvalue\fP Pointer to the read value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_read_struct (const char * key, void ** read_struct, size_t size)"

.PP
Reads struct type value from NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIread_struct\fP Pointer to the struct value\&. 
.br
\fIsize\fP Size of struct\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_read_u16 (const char * key, uint16_t * read_value)"

.PP
Reads uint16_t typed value from NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIread_value\fP Pointer to the read value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_read_u32 (const char * key, uint32_t * read_value)"

.PP
Reads uint32_t typed value from NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIread_value\fP Pointer to the read value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_read_u64 (const char * key, uint64_t * read_value)"

.PP
Reads uint64_t typed value from NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIread_value\fP Pointer to the read value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_read_u8 (const char * key, uint8_t * read_value)"

.PP
Reads uint8_t typed value from NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIread_value\fP Pointer to the read value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_write_double (const char * key, double write_value)"

.PP
Writes double typed value to NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIwrite_value\fP Write value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_write_float (const char * key, float write_value)"

.PP
Writes float typed value to NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIwrite_value\fP Write value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_write_i16 (const char * key, int16_t write_value)"

.PP
Writes int16_t typed value to NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIwrite_value\fP Write value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_write_i32 (const char * key, int32_t write_value)"

.PP
Writes int32_t typed value to NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIwrite_value\fP Write value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_write_i64 (const char * key, int64_t write_value)"

.PP
Writes int64_t typed value to NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIwrite_value\fP Write value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_write_i8 (const char * key, int8_t write_value)"

.PP
Writes int8_t typed value to NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIwrite_value\fP Write value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_write_str (const char * key, const char * write_str)"

.PP
Writes string typed value to NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIwrite_str\fP Write value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_write_struct (const char * key, void * write_struct, size_t size)"

.PP
Writes struct typed value to NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIwrite_struct\fP Write struct\&. 
.br
\fIsize\fP Size of struct\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_write_u16 (const char * key, uint16_t write_value)"

.PP
Writes uint16_t typed value to NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIwrite_value\fP Write value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_write_u32 (const char * key, uint32_t write_value)"

.PP
Writes uint32_t typed value to NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIwrite_value\fP Write value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_write_u64 (const char * key, uint64_t write_value)"

.PP
Writes uint64_t typed value to NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIwrite_value\fP Write value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t nvs_write_u8 (const char * key, uint8_t write_value)"

.PP
Writes uint8_t typed value to NVS\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP Storage key\&. 
.br
\fIwrite_value\fP Write value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "bool ods18b20_validate_address (const onewire_device_address_t address)"

.PP
Checks 1-wire device address against the ROM ID (i\&.e\&. family code of DS18B20 is 0x28) to determine if the device is a DS18B20\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddress\fP 1-wire device address\&. 
.RE
.PP
\fBReturns\fP
.RS 4
bool 1-wire device is a DS18B20 when true; 
.RE
.PP

.SS "esp_err_t s12sd_delete (\fBs12sd_handle_t\fP handle)"

.PP
Deinitialize S12SD device\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP S12SD device handle 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK: init success\&. 
.RE
.PP

.SS "const char * s12sd_get_fw_version (void )"

.PP
Converts S12SD firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* S12SD firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t s12sd_get_fw_version_number (void )"

.PP
Converts S12SD firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t S12SD firmware version number\&. 
.RE
.PP

.SS "esp_err_t s12sd_init (const \fBs12sd_config_t\fP * s12sd_config, \fBs12sd_handle_t\fP * s12sd_handle)"

.PP
Initializes an adc S12SD device\&. public function and subroutine declarations 

.PP
\fBParameters\fP
.RS 4
\fIs12sd_config\fP S12SD device configuration\&. 
.br
\fIs12sd_handle\fP S12SD device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK: init success\&. 
.RE
.PP

.SS "esp_err_t s12sd_measure (\fBs12sd_handle_t\fP handle, uint8_t * uv_index)"

.PP
Measure S12SD device\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP S12SD device handle\&. 
.br
\fIuv_index\fP uv index (1 to 11)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
ESP_OK: init success\&. 
.RE
.PP

.SS "esp_err_t sgp4x_delete (\fBsgp4x_handle_t\fP handle)"

.PP
Removes an SGP4X device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SGP4X device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sgp4x_execute_compensated_conditioning (\fBsgp4x_handle_t\fP handle, const float temperature, const float humidity, uint16_t * sraw_voc)"

.PP
Starts the conditioning with temperature and humidity compensation, i\&.e\&., the VOC pixel will be operated at the same temperature as it is by calling the sgp41_measure_raw_signals function while the NOx pixel will be operated at a different temperature for conditioning\&. The conditioning should be ran when the device is initially powered for 10-seconds but do not run the conditioning longer than 10-seconds, otherwise damage may occur to the SGP4X\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SGP4X device handle\&. 
.br
\fItemperature\fP Temperature compensation in degree celcius\&. 
.br
\fIhumidity\fP Humidity compensation in percentage\&. 
.br
\fIsraw_voc\fP Raw signal of VOC in ticks which is proportional to the logarithm of the resistance of the sensing element\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sgp4x_execute_conditioning (\fBsgp4x_handle_t\fP handle, uint16_t * sraw_voc)"

.PP
Starts the conditioning, i\&.e\&., the VOC pixel will be operated at the same temperature as it is by calling the sgp41_measure_raw_signals function while the NOx pixel will be operated at a different temperature for conditioning\&. The conditioning should be ran when the device is initially powered for 10-seconds but do not run the conditioning longer than 10-seconds, otherwise damage may occur to the SGP4X\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SGP4X device handle\&. 
.br
\fIsraw_voc\fP Raw signal of VOC in ticks which is proportional to the logarithm of the resistance of the sensing element\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sgp4x_execute_self_test (\fBsgp4x_handle_t\fP handle, sgp4x_self_test_result_t *const result)"

.PP
Performs the built-in self-test that checks for integrity of both hotplate and MOX material\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SGP4X device handle\&. 
.br
\fIresult\fP Results of the self-tests\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * sgp4x_get_fw_version (void )"

.PP
Converts SGP4X firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* SGP4X firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t sgp4x_get_fw_version_number (void )"

.PP
Converts SGP4X firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t SGP4X firmware version number\&. 
.RE
.PP

.SS "esp_err_t sgp4x_init (i2c_master_bus_handle_t master_handle, const \fBsgp4x_config_t\fP * sgp4x_config, \fBsgp4x_handle_t\fP * sgp4x_handle)"

.PP
Initializes an SGP4X device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIsgp4x_config\fP SGP4X device configuration\&. 
.br
\fIsgp4x_handle\fP SGP4X device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sgp4x_measure_compensated_signals (\fBsgp4x_handle_t\fP handle, const float temperature, const float humidity, uint16_t * sraw_voc, uint16_t * sraw_nox)"

.PP
Starts and/or continues the VOC and NOX measurement mode with temperature and humidity compensation\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SGP4X device handle\&. 
.br
\fItemperature\fP Temperature compensation in degree Celsius\&. 
.br
\fIhumidity\fP Humidity compensation in percentage\&. 
.br
\fIsraw_voc\fP Raw signal of VOC in ticks which is proportional to the logarithm of the resistance of the sensing element\&. 
.br
\fIsraw_nox\fP Raw signal of NOX in ticks which is proportional to the logarithm of the resistance of the sensing element\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sgp4x_measure_signals (\fBsgp4x_handle_t\fP handle, uint16_t * sraw_voc, uint16_t * sraw_nox)"

.PP
Starts and/or continues the VOC and NOX measurement mode using default temperature and humidity compensation\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SGP4X device handle\&. 
.br
\fIsraw_voc\fP Raw signal of VOC in ticks which is proportional to the logarithm of the resistance of the sensing element\&. 
.br
\fIsraw_nox\fP Raw signal of NOX in ticks which is proportional to the logarithm of the resistance of the sensing element\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sgp4x_remove (\fBsgp4x_handle_t\fP handle)"

.PP
Removes an SGP4X device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SGP4X device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sgp4x_reset (\fBsgp4x_handle_t\fP handle)"

.PP
Issues soft-reset and initializes SGP4X\&. See datasheet for details\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SGP4X device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sgp4x_turn_heater_off (\fBsgp4x_handle_t\fP handle)"

.PP
Turns the hotplate off, stops the measurement, and SGP4X enters idle mode\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SGP4X device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sht4x_delete (\fBsht4x_handle_t\fP handle)"

.PP
Removes an SHT4X device from master I2C bus and delete the handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SHT4X device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * sht4x_get_fw_version (void )"

.PP
Converts SHT4X firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* SHT4X firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t sht4x_get_fw_version_number (void )"

.PP
Converts SHT4X firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t SHT4X firmware version number\&. 
.RE
.PP

.SS "esp_err_t sht4x_get_heater_mode (\fBsht4x_handle_t\fP handle, \fBsht4x_heater_modes_t\fP *const mode)"

.PP
Reads measurement heater mode setting from SHT4X\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SHT4X device handle\&. 
.br
\fImode\fP Heater mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sht4x_get_measurement (\fBsht4x_handle_t\fP handle, float *const temperature, float *const humidity)"

.PP
Reads high-level measurements from SHT4X\&. This is a blocking function\&. 
.PP
\fBNote\fP
.RS 4
The function delays the calling task up to 1\&.1 s to wait for the measurement results\&. This might lead to problems when the function is called from a software timer callback function\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SHT4X device handle\&. 
.br
\fItemperature\fP Temperature in degree Celsius\&. 
.br
\fIhumidity\fP Relative humidity in percentage\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sht4x_get_measurements (\fBsht4x_handle_t\fP handle, float *const temperature, float *const humidity, float *const dewpoint)"

.PP
Similar to \fRi2c_sht4x_read_measurement\fP but it includes the dewpoint temperature in the results\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SHT4X device handle\&. 
.br
\fItemperature\fP Temperature in degree Celsius\&. 
.br
\fIhumidity\fP Relative humidity in percentage\&. 
.br
\fIdewpoint\fP Calculated dewpoint temperature in degree Celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sht4x_get_repeat_mode (\fBsht4x_handle_t\fP handle, \fBsht4x_repeat_modes_t\fP *const mode)"

.PP
Reads measurement repeatability mode setting from SHT4X\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SHT4X device handle\&. 
.br
\fImode\fP Repeatability mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sht4x_init (const i2c_master_bus_handle_t master_handle, const \fBsht4x_config_t\fP * sht4x_config, \fBsht4x_handle_t\fP *const sht4x_handle)"

.PP
Initializes an SHT4X device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIsht4x_config\fP SHT4X device configuration\&. 
.br
\fIsht4x_handle\fP SHT4X device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sht4x_remove (\fBsht4x_handle_t\fP handle)"

.PP
Removes an SHT4X device from master I2C bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SHT4X device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sht4x_reset (\fBsht4x_handle_t\fP handle)"

.PP
Issues soft-reset to SHT4X\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SHT4X device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sht4x_set_heater_mode (\fBsht4x_handle_t\fP handle, const \fBsht4x_heater_modes_t\fP mode)"

.PP
Writes measurement heater mode setting to SHT4X\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SHT4X device handle\&. 
.br
\fImode\fP Heater mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t sht4x_set_repeat_mode (\fBsht4x_handle_t\fP handle, const \fBsht4x_repeat_modes_t\fP mode)"

.PP
Writes measurement repeatability mode setting to SHT4X\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SHT4X device handle\&. 
.br
\fImode\fP Repeatability mode setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t spi_max31865_delete (\fBspi_max31865_handle_t\fP max31865_handle)"

.PP
Removes an MAX31865 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fImax31865_handle\fP MAX31865 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t spi_max31865_get_fault_status_register (\fBspi_max31865_handle_t\fP max31865_handle)"

.PP
Read fault status register from MAX31865\&. 
.PP
\fBParameters\fP
.RS 4
\fImax31865_handle\fP MAX31865 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t spi_max31865_get_measurement (\fBspi_max31865_handle_t\fP max31865_handle, float *const temperature)"

.PP
Reads temperature from MAX31865\&. 
.PP
\fBParameters\fP
.RS 4
\fImax31865_handle\fP MAX31865 device handle\&. 
.br
\fItemperature\fP Temperature in degree Celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t spi_max31865_init (const \fBspi_max31865_config_t\fP * max31865_config, \fBspi_max31865_handle_t\fP * max31865_handle)"

.PP
Initializes an MAX31865 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImax31865_config\fP Configuration of MAX31865 device\&. 
.br
\fImax31865_handle\fP MAX31865 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t spi_max31865_remove (\fBspi_max31865_handle_t\fP max31865_handle)"

.PP
Removes an MAX31865 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImax31865_handle\fP MAX31865 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_clear_display (\fBssd1306_handle_t\fP handle, bool invert)"

.PP
Clears the entire SSD1306 display\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIinvert\fP Background is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_clear_display_page (\fBssd1306_handle_t\fP handle, uint8_t page, bool invert)"

.PP
Clears a page from the SSD1306 display\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIpage\fP Index of page to clear from the display\&. 
.br
\fIinvert\fP Background is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_clear_display_software_scroll (\fBssd1306_handle_t\fP handle)"

.PP
Clears software based scrolling text from SSD1306 display\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "uint8_t ssd1306_copy_bit (uint8_t src, uint8_t src_bits, uint8_t dst, uint8_t dst_bits)"

.PP
Copies bit from source to destination\&. 
.PP
\fBParameters\fP
.RS 4
\fIsrc\fP 
.br
\fIsrc_bits\fP 
.br
\fIdst\fP 
.br
\fIdst_bits\fP 
.RE
.PP
\fBReturns\fP
.RS 4
uint8_t 
.RE
.PP

.SS "esp_err_t ssd1306_delete (\fBssd1306_handle_t\fP handle)"

.PP
Removes an SSD1306 device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_disable_display (\fBssd1306_handle_t\fP handle)"

.PP
Turns SSD1306 display panel off (sleep mode)\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_bdf_code (\fBssd1306_handle_t\fP handle, const uint8_t * font, int code, int xpos, int ypos)"

.PP
Displays BDF font code on the SSD1306\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIfont\fP BDF font bitmap data\&. 
.br
\fIcode\fP BDF font code to display\&. 
.br
\fIxpos\fP X-axis position of the font character\&. 
.br
\fIypos\fP Y-axis position of the font character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_bdf_text (\fBssd1306_handle_t\fP handle, const uint8_t * font, const char * text, int xpos, int ypos)"

.PP
Displays text on the SSD1306 with BDF font support\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIfont\fP BDF font bitmap data\&. 
.br
\fItext\fP Text characters to display\&. 
.br
\fIxpos\fP X-axis position of the font character\&. 
.br
\fIypos\fP Y-axis position of the font character\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_bitmap (\fBssd1306_handle_t\fP handle, uint8_t xpos, uint8_t ypos, const uint8_t * bitmap, uint8_t width, uint8_t height, bool invert)"

.PP
Displays a bitmap on the SSD1306\&. 
.PP
\fBNote\fP
.RS 4
Image to byte converter: https://mischianti.org/images-to-byte-array-online-converter-cpp-arduino/
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIxpos\fP X-axis position of the bitmap\&. 
.br
\fIypos\fP Y-axis position of the bitmap\&. 
.br
\fIbitmap\fP Bitmap data\&. 
.br
\fIwidth\fP Width of the bitmap\&. 
.br
\fIheight\fP Height of the bitmap 
.br
\fIinvert\fP Bitmap is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_circle (\fBssd1306_handle_t\fP handle, uint8_t x0, uint8_t y0, uint8_t r, bool invert)"

.PP
Sets SSD1306 pages and segments data for a circle and display's the circle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIx0\fP X-axis start position of the circle\&. 
.br
\fIy0\fP Y-axis start position of the circle\&. 
.br
\fIr\fP Radius of the circle\&. 
.br
\fIinvert\fP Circle is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_fadeout (\fBssd1306_handle_t\fP handle)"

.PP
SSD1306 display is faded out and cleared\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_filled_circle (\fBssd1306_handle_t\fP handle, uint8_t x0, uint8_t y0, uint8_t r, bool invert)"

.PP
Sets SSD1306 pages and segments data for a filled circle and display's the filled circle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIx0\fP X-axis start position of the circle\&. 
.br
\fIy0\fP Y-axis start position of the circle\&. 
.br
\fIr\fP Radius of the circle\&. 
.br
\fIinvert\fP Circle is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_filled_rectangle (\fBssd1306_handle_t\fP handle, uint8_t x, uint8_t y, uint8_t w, uint8_t h, bool invert)"

.PP
Sets SSD1306 pages and segments data for a filled rectangle and display's the filled rectangle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIx\fP X-axis start position of the rectangle\&. 
.br
\fIy\fP Y-axis start position of the rectangle\&. 
.br
\fIw\fP Width of the rectangle\&. 
.br
\fIh\fP Height of the rectangle\&. 
.br
\fIinvert\fP Rectangle is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t 
.RE
.PP

.SS "esp_err_t ssd1306_display_image (\fBssd1306_handle_t\fP handle, uint8_t page, uint8_t segment, const uint8_t * image, uint8_t width)"

.PP
Displays an image by page and segment on the SSD1306\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIpage\fP Index of page\&. 
.br
\fIsegment\fP Index of segment data\&. 
.br
\fIimage\fP Image data\&. 
.br
\fIwidth\fP Width of the image\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_pages (\fBssd1306_handle_t\fP handle)"

.PP
Displays segment data for each page supported by the SSD1306 display panel\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_rectangle (\fBssd1306_handle_t\fP handle, uint8_t x, uint8_t y, uint8_t w, uint8_t h, bool invert)"

.PP
Sets SSD1306 pages and segments data for a rectangle and display's the rectangle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIx\fP X-axis start position of the rectangle\&. 
.br
\fIy\fP Y-axis start position of the rectangle\&. 
.br
\fIw\fP Width of the rectangle\&. 
.br
\fIh\fP Height of the rectangle\&. 
.br
\fIinvert\fP Rectangle is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t 
.RE
.PP

.SS "esp_err_t ssd1306_display_software_scroll_text (\fBssd1306_handle_t\fP handle, const char * text, bool invert)"

.PP
Displays software based scrolling text on the SSD1306\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fItext\fP Text characters (16 characters maximum) to display\&. 
.br
\fIinvert\fP Text is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_text (\fBssd1306_handle_t\fP handle, uint8_t page, const char * text, bool invert)"

.PP
Displays text by page on the SSD1306 with a maximum of 16-characters\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIpage\fP Index of page\&. 
.br
\fItext\fP Text characters (16 characters maximum) to display\&. 
.br
\fIinvert\fP Text is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_text_x2 (\fBssd1306_handle_t\fP handle, uint8_t page, const char * text, bool invert)"

.PP
Displays text x2 larger by page on the SSD1306\&. 
.PP
\fBNote\fP
.RS 4
Text displayed uses 2-pages with a maximum of 8-characters\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIpage\fP Index of page\&. 
.br
\fItext\fP Text characters (8 characters maximum) to display\&. 
.br
\fIinvert\fP Text is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_text_x3 (\fBssd1306_handle_t\fP handle, uint8_t page, const char * text, bool invert)"

.PP
Displays text x3 larger by page on the SSD1306\&. 
.PP
\fBNote\fP
.RS 4
Text displayed uses 3-pages with a maximum of 5 characters\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIpage\fP Index of page\&. 
.br
\fItext\fP Text characters (5 characters maximum) to display\&. 
.br
\fIinvert\fP Text is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_textbox_banner (\fBssd1306_handle_t\fP handle, uint8_t page, uint8_t segment, const char * text, uint8_t box_width, bool invert, uint8_t delay)"

.PP
Displays scrolling text within a box as banner by page and segment on the SSD1306 with a maximum of 100-characters\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIpage\fP Index of page\&. 
.br
\fIseg\fP Index of segment data\&. 
.br
\fItext\fP Text characters (100 characters maximum) to display\&. 
.br
\fIbox_width\fP Width of the box\&. 
.br
\fIinvert\fP Text is inverted when true\&. 
.br
\fIdelay\fP Delay in milliseconds before information is displayed, a value 0 there is no wait\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_textbox_ticker (\fBssd1306_handle_t\fP handle, uint8_t page, uint8_t segment, const char * text, uint8_t box_width, bool invert, uint8_t delay)"

.PP
Displays scrolling text within a box as a ticker by page and segment on the SSD1306 with a maximum of 100-characters\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIpage\fP Index of page\&. 
.br
\fIseg\fP Index of segment data\&. 
.br
\fItext\fP Text characters (100 characters maximum) to display\&. 
.br
\fIbox_width\fP Width of the box\&. 
.br
\fIinvert\fP Text is inverted when true\&. 
.br
\fIdelay\fP Delay in milliseconds before information is displayed, a value 0 there is no wait\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_display_wrap_around (\fBssd1306_handle_t\fP handle, \fBssd1306_scroll_types_t\fP scroll, uint8_t start, uint8_t end, int8_t delay)"

.PP
Sets SSD1306 scroll orientation, start and end pages to wrap around the display\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIscroll\fP Scrolling orientation\&. 
.br
\fIstart\fP Index of page for left or right scroll, otherwise, height position for up or down scroll\&. 
.br
\fIend\fP Index of page for left or right scroll, otherwise, height position for up or down scroll\&. 
.br
\fIdelay\fP Delay in milliseconds (0-255) before information is displayed, a value 0 there is no wait, and nothing is displayed with a value of -1\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_enable_display (\fBssd1306_handle_t\fP handle)"

.PP
Turns SSD1306 display panel on\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "void ssd1306_flip_buffer (uint8_t * buf, size_t blen)"

.PP
Flips the buffer data (upsidedown)\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuf\fP Buffer data\&. 
.br
\fIblen\fP Length of buffer data\&. 
.RE
.PP

.SS "const char * ssd1306_get_fw_version (void )"

.PP
Converts SSD1306 firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* SSD1306 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t ssd1306_get_fw_version_number (void )"

.PP
Converts SSD1306 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t SSD1306 firmware version number\&. 
.RE
.PP

.SS "esp_err_t ssd1306_get_pages (\fBssd1306_handle_t\fP handle, uint8_t * buffer)"

.PP
Gets segment data for each page supported by the SSD1306 display panel\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIbuffer\fP Segment data in 128-byte blocks by page\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_init (i2c_master_bus_handle_t master_handle, const \fBssd1306_config_t\fP * ssd1306_config, \fBssd1306_handle_t\fP * ssd1306_handle)"

.PP
Initializes an SSD1306 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIssd1306_config\fP SSD1306 device configuration\&. 
.br
\fIssd1306_handle\fP SSD1306 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "void ssd1306_invert_buffer (uint8_t * buf, size_t blen)"

.PP
Inverts the buffer data\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuf\fP Buffer data\&. 
.br
\fIblen\fP Length of buffer data\&. 
.RE
.PP

.SS "esp_err_t ssd1306_load_bitmap_font (const uint8_t * font, int encoding, uint8_t * bitmap, \fBssd1306_bdf_font_t\fP *const bdf_font)"

.PP
Loads a BDF bitmap font and BDF font structure from a font file\&. public function and subroutine declarations 

.PP
\fBParameters\fP
.RS 4
\fIfont\fP BDF font bitmap data\&. 
.br
\fIencoding\fP BDF font encoding\&. 
.br
\fIbitmap\fP BDF font bitmap data\&. 
.br
\fIbdf_font\fP BDF font structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_remove (\fBssd1306_handle_t\fP handle)"

.PP
Removes an SSD1306 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "uint8_t ssd1306_rotate_byte (uint8_t ch1)"

.PP
Rotates 8-bits, as an example, 0x12 becomes 0x48\&. 
.PP
\fBParameters\fP
.RS 4
\fIch1\fP 8-bit value to rotate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
uint8_t rotated 8-bit value\&. 
.RE
.PP

.SS "esp_err_t ssd1306_set_bitmap (\fBssd1306_handle_t\fP handle, uint8_t xpos, uint8_t ypos, const uint8_t * bitmap, uint8_t width, uint8_t height, bool invert)"

.PP
Sets SSD1306 pages and segments data for a bitmap\&. 
.PP
\fBNote\fP
.RS 4
Call \fRssd1306_display_pages\fP to display the bitmap\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIxpos\fP X-axis position of the bitmap\&. 
.br
\fIypos\fP Y-axis position of the bitmap\&. 
.br
\fIbitmap\fP Bitmap data\&. 
.br
\fIwidth\fP Width of the bitmap\&. 
.br
\fIheight\fP Height of the bitmap 
.br
\fIinvert\fP Bitmap is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_set_circle (\fBssd1306_handle_t\fP handle, uint8_t x0, uint8_t y0, uint8_t r, bool invert)"

.PP
Sets SSD1306 pages and segments data for a circle\&. 
.PP
\fBNote\fP
.RS 4
Call \fRssd1306_display_pages\fP to display the circle\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIx0\fP X-axis start position of the circle\&. 
.br
\fIy0\fP Y-axis start position of the circle\&. 
.br
\fIr\fP Radius of the circle\&. 
.br
\fIinvert\fP Circle is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_set_contrast (\fBssd1306_handle_t\fP handle, uint8_t contrast)"

.PP
Sets contrast of the SSD1306 display panel\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIcontrast\fP Contrast of information being displayed (0 to 255)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_set_hardware_scroll (\fBssd1306_handle_t\fP handle, \fBssd1306_scroll_types_t\fP scroll, \fBssd1306_scroll_frames_t\fP frame_frequency)"

.PP
Sets SSD1306 scroll orientation and frame frequency for hardware based scrolling text\&. 
.PP
\fBNote\fP
.RS 4
Call \fRi2c_ssd1306_display_text\fP to display hardware based scrolling text\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIscroll\fP Scrolling orientation\&. 
.br
\fIframe_frequency\fP Frame rate of scrolling text\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_set_line (\fBssd1306_handle_t\fP handle, uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, bool invert)"

.PP
Sets SSD1306 pages and segments data for a line\&. 
.PP
\fBNote\fP
.RS 4
Call \fRssd1306_display_pages\fP to display the line\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIx1\fP X-axis start position of the line\&. 
.br
\fIy1\fP Y-axis start position of the line\&. 
.br
\fIx2\fP X-axis end position of the line\&. 
.br
\fIy2\fP Y-axis end position of the line\&. 
.br
\fIinvert\fP Line is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_set_pages (\fBssd1306_handle_t\fP handle, uint8_t * buffer)"

.PP
Sets segment data for each page supported by the SSD1306 display panel\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIbuffer\fP Segment data in 128-byte blocks by page\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_set_pixel (\fBssd1306_handle_t\fP handle, uint8_t xpos, uint8_t ypos, bool invert)"

.PP
Sets SSD1306 pages and segments data for a pixel\&. 
.PP
\fBNote\fP
.RS 4
Call \fRssd1306_display_pages\fP to display the pixel\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIxpos\fP X-axis position of the pixel\&. 
.br
\fIypos\fP Y-axis position of the pixel\&. 
.br
\fIinvert\fP Pixel is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t ssd1306_set_rectangle (\fBssd1306_handle_t\fP handle, uint8_t x, uint8_t y, uint8_t w, uint8_t h, bool invert)"

.PP
Sets SSD1306 pages and segments data for a rectangle\&. 
.PP
\fBNote\fP
.RS 4
Call \fRssd1306_display_pages\fP to display the rectangle\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIx\fP X-axis start position of the rectangle\&. 
.br
\fIy\fP Y-axis start position of the rectangle\&. 
.br
\fIw\fP Width of the rectangle\&. 
.br
\fIh\fP Height of the rectangle\&. 
.br
\fIinvert\fP Rectangle is inverted when true\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t 
.RE
.PP

.SS "esp_err_t ssd1306_set_software_scroll (\fBssd1306_handle_t\fP handle, uint8_t start, uint8_t end)"

.PP
Sets SSD1306 start and end page for software based scrolling text\&. 
.PP
\fBNote\fP
.RS 4
Call \fRi2c_ssd1306_display_scroll_text\fP to display software based scrolling text\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP SSD1306 device handle\&. 
.br
\fIstart\fP Index of start page\&. 
.br
\fIend\fP Index of end page\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t tbi2cxxx_delete (\fBtbi2cxxx_handle_t\fP handle)"

.PP
Removes an TBI2CXXX device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP TBI2CXXX device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t tbi2cxxx_get_ambient_temperature (\fBtbi2cxxx_handle_t\fP handle, float *const temperature)"

.PP
Reads ambient temperature from TBI2CXXX\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP TBI2CXXX device handle\&. 
.br
\fItemperature\fP Ambient temperature in degrees celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t tbi2cxxx_get_emissivity (\fBtbi2cxxx_handle_t\fP handle, float *const coefficient)"

.PP
Reads emissivity coefficient setting from TBI2CXXX\&. 
.PP
\fBNote\fP
.RS 4
Factory default emissivity coefficient setting is 0\&.97\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP TBI2CXXX device handle\&. 
.br
\fIcoefficient\fP TBI2CXXX emissivity coefficient setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * tbi2cxxx_get_fw_version (void )"

.PP
Converts TBI2CXXX firmware version numbers (major, minor, patch, build) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* TBI2CXXX firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t tbi2cxxx_get_fw_version_number (void )"

.PP
Converts TBI2CXXX firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t TBI2CXXX firmware version number\&. 
.RE
.PP

.SS "esp_err_t tbi2cxxx_get_object_temperature (\fBtbi2cxxx_handle_t\fP handle, float *const temperature)"

.PP
Reads object temperature from TBI2CXXX\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP TBI2CXXX device handle\&. 
.br
\fItemperature\fP Object temperature in degrees celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t tbi2cxxx_get_temperatures (\fBtbi2cxxx_handle_t\fP handle, float *const ambient_temperature, float *const object_temperature)"

.PP
Reads ambient and object temperatures from TBI2CXXX\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP TBI2CXXX device handle\&. 
.br
\fIambient_temperature\fP Ambient temperature in degrees celsius\&. 
.br
\fIobject_temperature\fP Object temperature in degrees celsius\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t tbi2cxxx_init (i2c_master_bus_handle_t master_handle, const \fBtbi2cxxx_config_t\fP * tbi2cxxx_config, \fBtbi2cxxx_handle_t\fP * tbi2cxxx_handle)"

.PP
Initializes an TBI2CXXX device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fItbi2cxxx_config\fP TBI2CXXX device configuration\&. 
.br
\fItbi2cxxx_handle\fP TBI2CXXX device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t tbi2cxxx_remove (\fBtbi2cxxx_handle_t\fP handle)"

.PP
Removes an TBI2CXXX device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP TBI2CXXX device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t tbi2cxxx_set_emissivity (\fBtbi2cxxx_handle_t\fP handle, const float coefficient)"

.PP
Writes emissivity coefficient setting to TBI2CXXX\&. 
.PP
\fBNote\fP
.RS 4
The manufacturer recommends restarting the sensor by cycling power off and on\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP TBI2CXXX device handle\&. 
.br
\fIcoefficient\fP TBI2CXXX emissivity coefficient setting, acceptable range is 0\&.1 to 1\&.0\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t tlv493d_delete (\fBtlv493d_handle_t\fP handle)"

.PP
Removes an TLV493D device from master bus and frees handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP TLV493D device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t tlv493d_init (i2c_master_bus_handle_t master_handle, const \fBtlv493d_config_t\fP * tlv493d_config, \fBtlv493d_handle_t\fP * tlv493d_handle)"

.PP
Initializes an TLV493D device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fItlv493d_config\fP TLV493D device configuration\&. 
.br
\fItlv493d_handle\fP TLV493D device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t tlv493d_remove (\fBtlv493d_handle_t\fP handle)"

.PP
Removes an TLV493D device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP TLV493D device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t tlv493d_reset (\fBtlv493d_handle_t\fP handle)"

.PP
Issues soft-reset and initializes TLV493D\&. See datasheet for details\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP TLV493D device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_delete (\fBveml6040_handle_t\fP handle)"

.PP
Removes an VEML6040 device from master I2C bus and delete the handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_disable (\fBveml6040_handle_t\fP handle)"

.PP
Shuts down VEML6040 until woken\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_enable (\fBveml6040_handle_t\fP handle)"

.PP
Wakes up VEML6040 from shutdown\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_get_als (\fBveml6040_handle_t\fP handle, float *const red_als, float *const green_als, float *const blue_als, float *const white_als)"

.PP
Reads red, green, blue, and white illuminance channels from VEML6040\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.br
\fIred_als\fP VEML6040 red illuminance in lux\&. 
.br
\fIgreen_als\fP VEML6040 green illuminance in lux\&. 
.br
\fIblue_als\fP VEML6040 blue illuminance in lux\&. 
.br
\fIwhite_als\fP VEML6040 white illuminance in lux\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_get_blue_als (\fBveml6040_handle_t\fP handle, float *const als)"

.PP
Reads blue illuminance channel from VEML6040\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.br
\fIals\fP VEML6040 blue illuminance in lux\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_get_configuration_register (\fBveml6040_handle_t\fP handle, veml6040_config_register_t *const reg)"

.PP
Reads configuration register from VEML6040\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.br
\fIreg\fP VEML6040 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * veml6040_get_fw_version (void )"

.PP
Converts VEML6040 firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* VEML6040 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t veml6040_get_fw_version_number (void )"

.PP
Converts VEML6040 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t VEML6040 firmware version number\&. 
.RE
.PP

.SS "esp_err_t veml6040_get_green_als (\fBveml6040_handle_t\fP handle, float *const als)"

.PP
Reads green illuminance channel from VEML6040\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.br
\fIals\fP VEML6040 green illuminance in lux\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_get_integration_time (\fBveml6040_handle_t\fP handle, \fBveml6040_integration_times_t\fP *const integration_time)"

.PP
Reads integration time from VEML6040\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.br
\fIintegration_time\fP VEML6040 integration time setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_get_mode (\fBveml6040_handle_t\fP handle, \fBveml6040_modes_t\fP *const mode)"

.PP
Reads mode from VEML6040\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.br
\fImode\fP VEML6040 mode seting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_get_red_als (\fBveml6040_handle_t\fP handle, float *const als)"

.PP
Reads red illuminance channel from VEML6040\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.br
\fIals\fP VEML6040 red illuminance in lux\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_get_trigger_method (\fBveml6040_handle_t\fP handle, \fBveml6040_triggers_t\fP *const trigger_method)"

.PP
Reads trigger method from VEML6040\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.br
\fItrigger_method\fP VEML6040 trigger method seting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_get_white_als (\fBveml6040_handle_t\fP handle, float *const als)"

.PP
Reads white illuminance channel from VEML6040\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.br
\fIals\fP VEML6040 white illuminance in lux\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_init (i2c_master_bus_handle_t master_handle, const \fBveml6040_config_t\fP * veml6040_config, \fBveml6040_handle_t\fP * veml6040_handle)"

.PP
Initializes an VEML6040 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIveml6040_config\fP VEML6040 device configuration\&. 
.br
\fIveml6040_handle\fP VEML6040 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_remove (\fBveml6040_handle_t\fP handle)"

.PP
Removes an VEML6040 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_set_configuration_register (\fBveml6040_handle_t\fP handle, const veml6040_config_register_t reg)"

.PP
Writes configuration register to VEML6040\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.br
\fIreg\fP VEML6040 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_set_integration_time (\fBveml6040_handle_t\fP handle, const \fBveml6040_integration_times_t\fP integration_time)"

.PP
Writes integration time to VEML6040\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.br
\fIintegration_time\fP VEML6040 integration time setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_set_mode (\fBveml6040_handle_t\fP handle, const \fBveml6040_modes_t\fP mode)"

.PP
Writes mode to VEML6040\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.br
\fImode\fP VEML6040 mode seting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml6040_set_trigger_method (\fBveml6040_handle_t\fP handle, const \fBveml6040_triggers_t\fP trigger_method)"

.PP
Write trigger method to VEML6040\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML6040 device handle\&. 
.br
\fItrigger_method\fP VEML6040 trigger method seting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_delete (\fBveml7700_handle_t\fP handle)"

.PP
Removes an VEML7700 device from master I2C bus and delete the handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_disable (\fBveml7700_handle_t\fP handle)"

.PP
Shuts down VEML7700 until woken\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_disable_irq (\fBveml7700_handle_t\fP handle)"

.PP
Disables interrupt assertion\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_enable (\fBveml7700_handle_t\fP handle)"

.PP
Wakes up VEML7700 from shut-down\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_enable_irq (\fBveml7700_handle_t\fP handle)"

.PP
Enables interrupt assertion\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_ambient_light (\fBveml7700_handle_t\fP handle, float *const ambient_light)"

.PP
Reads ambient light (0 lux to 140 klux) from VEML7700\&. 
.PP
\fBNote\fP
.RS 4
This follows the official Vishay VEML7700 Application Note, rev\&. 17-Jan-2024\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIambient_light\fP Ambient light illumination in lux\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_ambient_light_auto (\fBveml7700_handle_t\fP handle, float *const ambient_light)"

.PP
Reads optimal ambient light (0 lux to 140 klux) from VEML7700\&. 
.PP
\fBNote\fP
.RS 4
This follows the official Vishay VEML7700 Application Note, rev\&. 17-Jan-2024\&.

.PP
This doesn't seem to work all the time, results can vary, more testing required\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIambient_light\fP Ambient light illumination in lux\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_ambient_light_counts (\fBveml7700_handle_t\fP handle, uint16_t *const counts)"

.PP
Reads ambient light counts from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIcounts\fP Ambient light counts\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_configuration_register (\fBveml7700_handle_t\fP handle, veml7700_configuration_register_t *const reg)"

.PP
Reads configuration register from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIreg\fP VEML7700 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "const char * veml7700_get_fw_version (void )"

.PP
Converts VEML7700 firmware version numbers (major, minor, patch) into a string\&. 
.PP
\fBReturns\fP
.RS 4
char* VEML7700 firmware version as a string that is formatted as X\&.X\&.X (e\&.g\&. 4\&.0\&.0)\&. 
.RE
.PP

.SS "int32_t veml7700_get_fw_version_number (void )"

.PP
Converts VEML7700 firmware version numbers (major, minor, patch) into an integer value\&. 
.PP
\fBReturns\fP
.RS 4
int32_t VEML7700 firmware version number\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_gain (\fBveml7700_handle_t\fP handle, \fBveml7700_gains_t\fP *const gain)"

.PP
Reads als gain from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIgain\fP VEML7700 gain setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_identifier_register (\fBveml7700_handle_t\fP handle, veml7700_identifier_register_t *const reg)"

.PP
Reads identifier register from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIreg\fP VEML7700 identifier register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_integration_time (\fBveml7700_handle_t\fP handle, \fBveml7700_integration_times_t\fP *const integration_time)"

.PP
Reads als integration time from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIintegration_time\fP VEML7700 integration time setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_interrupt_status (\fBveml7700_handle_t\fP handle, bool *const hi_threshold_exceeded, bool *const lo_threshold_exceeded)"

.PP
Reads interrupt status from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIhi_threshold_exceeded\fP true when high threshold is exceeded\&. 
.br
\fIlo_threshold_exceeded\fP true when lo threshold is exceeded\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_interrupt_status_register (\fBveml7700_handle_t\fP handle, veml7700_interrupt_status_register_t *const reg)"

.PP
Reads interrupt status register from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIreg\fP VEML7700 interrupt status register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_persistence_protection (\fBveml7700_handle_t\fP handle, \fBveml7700_persistence_protections_t\fP *const persistence_protection)"

.PP
Reads als persistence protection from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIpersistence_protection\fP VEML7700 persistence protection setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_power_saving_mode (\fBveml7700_handle_t\fP handle, \fBveml7700_power_saving_modes_t\fP *const power_saving_mode, bool *const power_saving_enabled)"

.PP
Reads power saving mode from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIpower_saving_mode\fP VEML7700 power saving mode setting\&. 
.br
\fIpower_saving_enabled\fP VEML7700 power saving state setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_power_saving_mode_register (\fBveml7700_handle_t\fP handle, veml7700_power_saving_mode_register_t *const reg)"

.PP
Reads power saving mode register from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIreg\fP VEML7700 power saving mode register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_threshold_registers (\fBveml7700_handle_t\fP handle, uint16_t *const hi_threshold, uint16_t *const lo_threshold)"

.PP
Reads high and low threshold registers from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIhi_threshold\fP VEML7700 high threshold register\&. 
.br
\fIlo_threshold\fP VEML7700 lo threshold register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_thresholds (\fBveml7700_handle_t\fP handle, uint16_t *const hi_threshold, uint16_t *const lo_threshold)"

.PP
Reads high and low als thresholds (lux) from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIhi_threshold\fP VEML7700 high threshold setting\&. 
.br
\fIlo_threshold\fP VEML7700 low threshold setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_white_channel (\fBveml7700_handle_t\fP handle, float *const white_light)"

.PP
Reads white channel from VEML7700\&. 
.PP
\fBNote\fP
.RS 4
This follows the official Vishay VEML7700 Application Note, rev\&. 17-Jan-2024\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIwhite_light\fP White channel illumination in lux\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_white_channel_auto (\fBveml7700_handle_t\fP handle, float *const white_light)"

.PP
Reads optimal white channel from VEML7700\&. 
.PP
\fBNote\fP
.RS 4
This follows the official Vishay VEML7700 Application Note, rev\&. 17-Jan-2024\&.

.PP
This doesn't seem to work all the time, results can vary, more testing required\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIwhite_light\fP White channel illumination in lux\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_get_white_channel_counts (\fBveml7700_handle_t\fP handle, uint16_t *const counts)"

.PP
Reads white channel counts from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIcounts\fP White channel counts\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_init (i2c_master_bus_handle_t master_handle, const \fBveml7700_config_t\fP * veml7700_config, \fBveml7700_handle_t\fP * veml7700_handle)"

.PP
Initializes an VEML7700 device onto the I2C master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fImaster_handle\fP I2C master bus handle\&. 
.br
\fIveml7700_config\fP VEML7700 device configuration\&. 
.br
\fIveml7700_handle\fP VEML7700 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_optimize_configuration (\fBveml7700_handle_t\fP handle)"

.PP
Optimizes VEML7700 gain and integration time configuration\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_remove (\fBveml7700_handle_t\fP handle)"

.PP
Removes an VEML7700 device from master bus\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_set_configuration_register (\fBveml7700_handle_t\fP handle, const veml7700_configuration_register_t reg)"

.PP
Writes configuration register to VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIreg\fP VEML7700 configuration register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_set_gain (\fBveml7700_handle_t\fP handle, const \fBveml7700_gains_t\fP gain)"

.PP
Writes als gain to VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIgain\fP VEML7700 gain setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_set_integration_time (\fBveml7700_handle_t\fP handle, const \fBveml7700_integration_times_t\fP integration_time)"

.PP
Writes als integration time to VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIintegration_time\fP VEML7700 integration time setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_set_persistence_protection (\fBveml7700_handle_t\fP handle, const \fBveml7700_persistence_protections_t\fP persistence_protection)"

.PP
Writes als persistence protection to VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIpersistence_protection\fP VEML7700 persistence protection setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_set_power_saving_mode (\fBveml7700_handle_t\fP handle, const \fBveml7700_power_saving_modes_t\fP power_saving_mode, const bool power_saving_enabled)"

.PP
Reads power saving mode from VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIpower_saving_mode\fP VEML7700 power saving mode setting\&. 
.br
\fIpower_saving_enabled\fP VEML7700 power saving state setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_set_power_saving_mode_register (\fBveml7700_handle_t\fP handle, const veml7700_power_saving_mode_register_t reg)"

.PP
Writes power saving mode register to VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIreg\fP VEML7700 power saving mode register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_set_threshold_registers (\fBveml7700_handle_t\fP handle, const uint16_t hi_threshold, const uint16_t lo_threshold)"

.PP
Writes high and low threshold registers to VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIhi_threshold\fP VEML7700 high threshold register\&. 
.br
\fIlo_threshold\fP VEML7700 lo threshold register\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SS "esp_err_t veml7700_set_thresholds (\fBveml7700_handle_t\fP handle, const uint16_t hi_threshold, const uint16_t lo_threshold)"

.PP
Writes high and low als thresholds (lux) to VEML7700\&. 
.PP
\fBParameters\fP
.RS 4
\fIhandle\fP VEML7700 device handle\&. 
.br
\fIhi_threshold\fP VEML7700 high threshold setting\&. 
.br
\fIlo_threshold\fP VEML7700 low threshold setting\&. 
.RE
.PP
\fBReturns\fP
.RS 4
esp_err_t ESP_OK on success\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for ESP-IDF Components by K0I05 from the source code\&.
